"""
CONSOLIDATED APP.PY
All routes consolidated from separate blueprint files
WARNING: This is a very large file (~17,500+ lines)
Generated automatically by consolidate_routes.py
"""

from flask import Flask, render_template, request, redirect, url_for, flash, session, jsonify, send_file, current_app
from flask_wtf.csrf import CSRFProtect, generate_csrf
from dotenv import load_dotenv
from extensions import db, migrate, mail
from flask_login import LoginManager, login_user, login_required, current_user, logout_user
import os
import secrets
import calendar
from datetime import timedelta, datetime, date, timezone
import logging
import traceback
from werkzeug.utils import secure_filename
from utils.decorators import role_required
from utils.constants import Roles
from utils.email import send_verification_email, send_email
from utils.payroll_calculator import PayrollCalculator, PayrollBatch
from utils.workflow import create_approval_workflow, send_approval_notification
from models import *
import pandas as pd
from io import BytesIO
import xlsxwriter
from sqlalchemy import func
from sqlalchemy.exc import SQLAlchemyError
import random
import string
import uuid

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('app.log')
    ]
)

logger = logging.getLogger(__name__)

def create_app():
    app = Flask(__name__)
    
    # Load environment variables
    load_dotenv()
    
    # Security Configuration
    app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')
    app.config['WTF_CSRF_SECRET_KEY'] = os.environ.get('WTF_CSRF_SECRET_KEY')
    app.config['WTF_CSRF_ENABLED'] = True
    app.config['WTF_CSRF_TIME_LIMIT'] = 3600
    app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=60)
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['SESSION_COOKIE_HTTPONLY'] = True
    app.config['TEMPLATES_AUTO_RELOAD'] = True
    app.config['DEBUG'] = True
    
    # Database Configuration
    app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL') or 'sqlite:///sammy.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    # Mail Configuration
    app.config['MAIL_SERVER'] = os.environ.get('MAIL_SERVER')
    app.config['MAIL_PORT'] = int(os.environ.get('MAIL_PORT', 2525))
    app.config['MAIL_USE_TLS'] = os.environ.get('MAIL_USE_TLS', 'True').lower() == 'true'
    app.config['MAIL_USE_SSL'] = os.environ.get('MAIL_USE_SSL', 'False').lower() == 'true'
    app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
    app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')
    app.config['MAIL_DEFAULT_SENDER'] = os.environ.get('MAIL_DEFAULT_SENDER')
    app.config['MAIL_DEBUG'] = os.environ.get('MAIL_DEBUG', 'True').lower() == 'true'
    
    # Upload folder
    app.config['UPLOAD_FOLDER'] = os.path.join(app.root_path, 'uploads')
    
    # Initialize extensions
    mail.init_app(app)
    db.init_app(app)
    migrate.init_app(app, db)
    
    # Initialize CSRF protection
    csrf = CSRFProtect()
    csrf.init_app(app)
    
    # Add CSRF token to all templates
    @app.context_processor
    def inject_csrf_token():
        try:
            from flask import has_request_context, request as flask_request
            if has_request_context() and flask_request:
                token = generate_csrf()
                return dict(csrf_token=token)
            else:
                return dict(csrf_token='')
        except Exception as e:
            print(f"CSRF token generation error: {e}")
            return dict(csrf_token='')
    
    # Error handlers
    @app.errorhandler(400)
    def bad_request_error(error):
        if "CSRF" in str(error):
            flash("The form expired. Please refresh the page and try again.", "error")
            from flask import request as flask_request
            referer = flask_request.headers.get('Referer')
            if referer:
                return redirect(referer)
            return redirect(url_for('dashboard.super_hq_dashboard'))
        return render_template('errors/400.html'), 400

    @app.errorhandler(403)
    def forbidden_error(error):
        flash("You don't have permission to access this resource.", "error")
        return render_template('errors/403.html'), 403
    
    # Initialize LoginManager
    login_manager = LoginManager()
    login_manager.init_app(app)
    login_manager.login_view = 'login'
    login_manager.login_message = 'Please log in to access this page.'
    login_manager.login_message_category = 'info'
    
    @login_manager.user_loader
    def load_user(user_id):
        return db.session.get(User, int(user_id))
    
    # ============================================================================
    # HELPER FUNCTIONS
    # ============================================================================
    
    def get_dashboard_route(role):
        """Get dashboard route based on user role"""
        dashboard_routes = {
            Roles.SUPER_HQ: 'admin.dashboard',
            Roles.HQ_FINANCE: 'finance_home',
            Roles.HQ_HR: 'hr_home',
            Roles.HQ_PROCUREMENT: 'procurement_home',
            Roles.QUARRY_MANAGER: 'quarry_home',
            Roles.PROJECT_MANAGER: 'project_home',
            Roles.FINANCE_STAFF: 'staff_home',
            Roles.HR_STAFF: 'staff_home',
            Roles.PROCUREMENT_STAFF: 'staff_home',
            Roles.QUARRY_STAFF: 'staff_home',
            Roles.PROJECT_STAFF: 'staff_home'
        }
        return dashboard_routes.get(role, 'main_home')
    
    # ============================================================================
    # ROUTES FROM Email templates
    # ============================================================================
    def send_order_notification(user_email, order_number, status, reason=None):
        """Send email notification for purchase order status changes"""
        try:
            subject = f"Purchase Order {order_number} - Status Update"
            
            if status == 'Approved':
                body = f"""
Dear User,

Your Purchase Order {order_number} has been APPROVED.

The order is now approved and will proceed to the next stage in the procurement process.

Best regards,
Construction Management Team
                """
            elif status == 'Rejected':
                body = f"""
Dear User,

Your Purchase Order {order_number} has been REJECTED.

Reason: {reason or 'No specific reason provided'}

Please review the rejection reason and resubmit the order with necessary corrections if required.

Best regards,
Construction Management Team
                """
            
            msg = Message(subject,
                         sender=current_app.config['MAIL_DEFAULT_SENDER'],
                         recipients=[user_email])
            msg.body = body
            
            mail.send(msg)
            return True
        except Exception as e:
            current_app.logger.error(f"Failed to send order notification: {str(e)}")
            return False

    # ============================================================================
    # ROUTES FROM MAIN.PY
    # ============================================================================

    # Configure logger for this module
    logger = logging.getLogger(__name__)

    # Test email route
    @app.route('/test-email')
    def test_email():
        """Test route to verify email configuration"""
        try:
            from flask_mail import Message
            msg = Message('Test Email from SammyA',
                         sender=app.config['MAIL_DEFAULT_SENDER'],
                         recipients=['test@example.com'])
            msg.body = 'This is a test email to verify email configuration.'
            mail.send(msg)
            return jsonify({
                'success': True,
                'message': 'Test email sent successfully!',
                'config': {
                    'MAIL_SERVER': app.config.get('MAIL_SERVER'),
                    'MAIL_PORT': app.config.get('MAIL_PORT'),
                    'MAIL_USERNAME': app.config.get('MAIL_USERNAME'),
                    'MAIL_DEFAULT_SENDER': app.config.get('MAIL_DEFAULT_SENDER')
                }
            })
        except Exception as e:
            return jsonify({
                'success': False,
                'error': str(e),
                'config': {
                    'MAIL_SERVER': app.config.get('MAIL_SERVER'),
                    'MAIL_PORT': app.config.get('MAIL_PORT'),
                    'MAIL_USERNAME': app.config.get('MAIL_USERNAME'),
                    'MAIL_DEFAULT_SENDER': app.config.get('MAIL_DEFAULT_SENDER')
                }
            }), 500

    @app.route("/", endpoint='main_home')
    def main_home():
        return render_template("index.html")


    # ===== NOTIFICATION API ROUTES =====
    
    @app.route('/api/notifications', methods=['GET'], endpoint='api.get_notifications')
    @login_required
    def get_user_notifications():
        """Get notifications for current user"""
        from models import Notification
        from utils.workflow import get_user_notifications
        
        try:
            unread_only = request.args.get('unread_only', 'false').lower() == 'true'
            limit = request.args.get('limit', 50, type=int)
            
            notifications = get_user_notifications(
                user_id=current_user.id,
                unread_only=unread_only,
                limit=limit
            )
            
            notifications_data = []
            for notif in notifications:
                notifications_data.append({
                    'id': notif.id,
                    'title': notif.title,
                    'message': notif.message,
                    'type': notif.notification_type,
                    'is_read': notif.is_read,
                    'action_url': notif.action_url,
                    'priority': notif.priority,
                    'created_at': notif.created_at.isoformat() if notif.created_at else None,
                    'reference_type': notif.reference_type,
                    'reference_id': notif.reference_id
                })
            
            return jsonify({
                'success': True,
                'notifications': notifications_data,
                'count': len(notifications_data)
            })
            
        except Exception as e:
            current_app.logger.error(f"Error fetching notifications: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500
    
    
    @app.route('/api/notifications/unread-count', methods=['GET'], endpoint='api.unread_notification_count')
    @login_required
    def get_unread_notification_count():
        """Get count of unread notifications"""
        from models import Notification
        
        try:
            count = Notification.query.filter_by(
                user_id=current_user.id,
                is_read=False
            ).count()
            
            return jsonify({
                'success': True,
                'count': count
            })
            
        except Exception as e:
            current_app.logger.error(f"Error counting notifications: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500
    
    
    @app.route('/api/notifications/<int:notification_id>/read', methods=['POST'], endpoint='api.mark_notification_read')
    @login_required
    def mark_notification_as_read(notification_id):
        """Mark a notification as read"""
        from utils.workflow import mark_notification_read
        
        try:
            success = mark_notification_read(notification_id, current_user.id)
            
            if success:
                return jsonify({'success': True, 'message': 'Notification marked as read'})
            else:
                return jsonify({'success': False, 'error': 'Notification not found or already read'}), 404
                
        except Exception as e:
            current_app.logger.error(f"Error marking notification as read: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500
    
    
    @app.route('/api/notifications/mark-all-read', methods=['POST'], endpoint='api.mark_all_notifications_read')
    @login_required
    def mark_all_notifications_as_read():
        """Mark all notifications as read for current user"""
        from utils.workflow import mark_all_notifications_read
        
        try:
            count = mark_all_notifications_read(current_user.id)
            
            return jsonify({
                'success': True,
                'message': f'{count} notification(s) marked as read',
                'count': count
            })
                
        except Exception as e:
            current_app.logger.error(f"Error marking all notifications as read: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500
    
    
    @app.route('/notifications')
    @login_required
    def notifications_page():
        """Display notifications page"""
        return render_template('notifications.html')
    
    
    @app.route('/api/pending-approvals', methods=['GET'], endpoint='api.pending_approvals')
    @login_required
    def get_pending_approvals():
        """Get pending approvals for current user"""
        from models import ApprovalWorkflow
        from utils.workflow import get_pending_approvals_for_user
        
        try:
            workflows = get_pending_approvals_for_user(current_user)
            
            approvals_data = []
            for workflow in workflows:
                approvals_data.append({
                    'id': workflow.id,
                    'workflow_type': workflow.workflow_type,
                    'reference_number': workflow.reference_number,
                    'reference_id': workflow.reference_id,
                    'description': workflow.description,
                    'total_amount': workflow.total_amount,
                    'priority': workflow.priority,
                    'current_stage': workflow.current_stage,
                    'overall_status': workflow.overall_status,
                    'initiated_at': workflow.initiated_at.isoformat() if workflow.initiated_at else None
                })
            
            return jsonify({
                'success': True,
                'approvals': approvals_data,
                'count': len(approvals_data)
            })
            
        except Exception as e:
            current_app.logger.error(f"Error fetching pending approvals: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'error': str(e)}), 500


    # ===== MAIN ROUTES =====

    @app.route('/signup', methods=['GET', 'POST'], endpoint='signup')
    def signup():
        try:
            if request.method == 'POST':
                name = request.form.get("name")
                email = request.form.get("email")
                role = request.form.get("role")
                password = request.form.get("password")

            # Input validation
                if not all([name, email, role, password]):
                    flash("All fields are required", "error")
                    return redirect(url_for("signup"))

            # Role validation
                if role not in vars(Roles).values():
                    flash("Invalid role selected", "error")
                    return redirect(url_for("signup"))

            # Check existing user
                if User.query.filter_by(email=email).first():
                    flash("Email already registered", "error")
                    return redirect(url_for("signup"))

            # Always set SUPER_HQ for admin/super admin/super_hq
                if str(role).strip().lower() in ["super_hq", "super admin", "admin"]:
                    db_role = Roles.SUPER_HQ
                else:
                    db_role = role
                
                # Generate verification code
                import random
                verification_code = str(random.randint(100000, 999999))
                
                new_user = User(name=name, email=email, role=db_role, verification_code=verification_code)
                new_user.set_password(password)
                db.session.add(new_user)
                db.session.commit()
                
                # Send verification email
                try:
                    send_verification_email(email, verification_code)
                    print(f"Verification email sent to {email} with code {verification_code}")  # Debug
                except Exception as email_error:
                    print(f"Failed to send verification email: {str(email_error)}")  # Debug
                    # Don't fail signup if email fails
                
            # Only store user_id in session
                session["user_id"] = new_user.id
                print("Signed up with role:", db_role)  # Debug
                session.permanent = True
                flash("Account created! Please check your email for the verification code.", "success")
                return redirect(url_for("verify_email_page"))

        except Exception as e:
            db.session.rollback()  # Rollback failed transaction
            import traceback
            print(f"Signup error: {str(e)}")  # Debug print
            print(f"Full traceback:\n{traceback.format_exc()}")  # Full error details
            flash(f"An error occurred during signup: {str(e)}", "error")
            return redirect(url_for("signup"))
        
        return render_template("auth/signup.html")


    def get_dashboard_route(role):
        dashboard_routes = {
        # HQ Level Routes
            Roles.SUPER_HQ: 'admin.dashboard',      # Fixed endpoint name
            Roles.HQ_FINANCE: 'finance.finance_home',
            Roles.HQ_HR: 'hr.hr_home',
            Roles.HQ_PROCUREMENT: 'procurement.procurement_home',
            Roles.HQ_COST_CONTROL: 'cost_control_mgr.dashboard',
            Roles.QUARRY_MANAGER: 'quarry.quarry_home',
            Roles.PROJECT_MANAGER: 'project.project_home',
        # Staff Level Routes
            Roles.FINANCE_STAFF: 'finance.staff_home',
            Roles.HR_STAFF: 'hr.staff_home',
            Roles.PROCUREMENT_STAFF: 'procurement.staff_home',
            Roles.QUARRY_STAFF: 'quarry.staff_home',
            Roles.PROJECT_STAFF: 'project.staff_home'
        }
        return dashboard_routes.get(role, 'main_home')

# Login
    @app.route("/login", methods=["GET", "POST"], endpoint='login')
    def login():
        try:
            if request.method == "POST":
                email = request.form["email"]
                password = request.form["password"]

                user = User.query.filter_by(email=email).first()
                if not user:
                    flash("Invalid email or password", "error")
                    return render_template("auth/login.html")
                if not user.is_verified:
                    try:
                    # Generate new verification code
                        verification_code = ''.join(random.choices(string.digits, k=6))
                        user.verification_code = verification_code
                        db.session.commit()
                    
                    # Send verification email
                        send_verification_email(user.email, verification_code)
                        flash("Please verify your email first. A new verification code has been sent.", "info")
                        return redirect(url_for("main.verify_email_page", email=email))
                    
                    except Exception as e:
                        logger.error(f"Verification email error: {str(e)}")
                        db.session.rollback()
                        flash("Unable to send verification email. Please try again later.", "error")
                        return render_template("auth/login.html")
                if user.check_password(password):
                    login_user(user)
                    session["user_id"] = user.id
                # Normalize dashboard role for super admin, else use user.role
                    dashboard_role = user.role
                    if str(user.role).strip().upper() in ["super_hq", "super admin", "admin"]:
                        dashboard_role = Roles.SUPER_HQ
                    print("Logged in as user_id:", session["user_id"], "dashboard_role:", dashboard_role)  # Debug
                    session.permanent = True
                    return redirect(url_for(get_dashboard_route(dashboard_role)))
                flash("Invalid email or password", "error")
        except Exception as e:
            logger.error(f"Login error: {str(e)}")
            flash("An error occurred. Please try again.", "error")
        return render_template("auth/login.html")

    @app.route("/verify-email", methods=["GET", "POST"], endpoint='verify_email_page')
    def verify_email_page():
        if request.method == "POST":
            email = request.form.get("email")
            verification_code = request.form.get("verification_code")
        
            user = User.query.filter_by(email=email).first()
        
            if not user:
                flash("Email not found", "error")
                return render_template("auth/verification.html")
            
            if user.verification_code != verification_code:
                flash("Invalid verification code", "error")
                return render_template("auth/verification.html")
            
            user.is_verified = True
            user.verification_code = None
            db.session.commit()
        
            flash("Email verified successfully! You can now login.", "success")
            return redirect(url_for("login"))
        
        return render_template("auth/verification.html")


# Forgot Password
    @app.route("/forgot-password", methods=["GET", "POST"], endpoint='forgot_password')
    def forgot_password():
        if request.method == "POST":
            email = request.form["email"]
            user = User.query.filter_by(email=email).first()
            if user:
                token = str(uuid.uuid4())
                user.reset_token = token
                db.session.commit()
            # TODO: send reset email with link
                flash("Password reset link sent to your email.", "info")
            else:
                flash("Email not found", "error")
        return render_template("auth/forgot_password.html")


# Reset Password
    @app.route("/reset-password/<token>", methods=["GET", "POST"], endpoint='reset_password')
    def reset_password(token):
        user = User.query.filter_by(reset_token=token).first()
        if not user:
            flash("Invalid or expired token", "error")
            return redirect(url_for("login"))

        if request.method == "POST":
            new_password = request.form["password"]
            user.set_password(new_password)
            user.reset_token = None
            db.session.commit()
            flash("Password reset successful! You can now log in.", "success")
            return redirect(url_for("login"))

        return render_template("auth/reset_password.html", token=token)


# Email Verification (dummy for now)
    @app.route("/verify/<public_id>", endpoint='verify_email')
    def verify_email(public_id):
        user = User.query.filter_by(public_id=public_id).first()
        if user:
            user.email_verified = True
            db.session.commit()
            flash("Email verified! You can now log in.", "success")
        return redirect(url_for("main.login"))

    @app.route('/drop-db', methods=["GET", "POST"], endpoint='drop_db')
    def drop_db():
    # Only allow if logged in and role is Super Admin or SUPER_HQ
    # if 'user_id' not in session or session.get('role') not in ['Super Admin', 'SUPER_HQ']:
    #     flash('Unauthorized', 'error')
    #     return redirect(url_for('login'))
        try:
            db.drop_all()
            db.session.commit()
            flash('Database dropped successfully!', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error dropping database: {str(e)}', 'error')
        return redirect(url_for('main_home'))


    @app.route('/logout', endpoint='logout')
    def logout():

        logout_user()
        flash('You have been logged out.', 'success')
        return redirect(url_for('login'))




    # ============================================================================
    # ROUTES FROM FILES.PY
    # ============================================================================


    from werkzeug.utils import secure_filename
    from flask_wtf import FlaskForm
    from wtforms import StringField, FileField
    from wtforms.validators import DataRequired, Length
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address
    from mimetypes import guess_type


    UPLOAD_FOLDER = os.path.join(os.getcwd(), 'uploads')
    ALLOWED_EXTENSIONS = {'pdf', 'docx', 'xlsx', 'jpg', 'png', 'txt'}
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB

    class FileUploadForm(FlaskForm):
        name = StringField('Display Name', validators=[DataRequired(), Length(max=255)])
        file = FileField('File', validators=[DataRequired()])
        folder = StringField('Folder', validators=[Length(max=100)])
        tags = StringField('Tags', validators=[Length(max=200)])

    def allowed_file(filename):
        return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

    @app.route('/files/upload', methods=['GET', 'POST'], endpoint='files.upload_file')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])  # Added HQ_HR role
    def upload_file():
        form = FileUploadForm()
        if form.validate_on_submit():
            file = form.file.data
            name = form.name.data.strip()
            folder = form.folder.data.strip() or 'default'
            tags = form.tags.data.strip()
        
            if not allowed_file(file.filename):
                flash('File type not allowed.', 'danger')
                return redirect(url_for('files.upload_file'))
            
            filename = secure_filename(file.filename)
            folder_path = os.path.join(UPLOAD_FOLDER, folder)
            os.makedirs(folder_path, exist_ok=True)
            file_path = os.path.join(folder_path, filename)
        
        # Check file size
            file.seek(0, os.SEEK_END)
            size = file.tell()
            file.seek(0)
            if size > MAX_FILE_SIZE:
                flash('File exceeds maximum size (10MB).', 'danger')
                return redirect(url_for('files.upload_file'))
        
            file.save(file_path)
        
        # Get file type
            file_type = guess_type(filename)[0]
        
        # Create database record
            uploaded = UploadedFile(
                filename=filename,
                name=name,
                folder=folder,
                tags=tags,
                path=file_path,
                file_size=size,
                file_type=file_type,
                uploaded_by=current_user.id if current_user.is_authenticated else None
            )
            db.session.add(uploaded)
            db.session.commit()
        
            flash('File uploaded successfully!', 'success')
            return redirect(url_for('files.search_files'))
        return render_template('files/upload.html', form=form)

    @app.route('/files/folders/create', methods=['POST'], endpoint='files.create_folder')
    @role_required([Roles.SUPER_HQ])
    def create_folder():
        folder = request.form.get('folder', '').strip()
        if not folder:
            flash('Folder name is required.', 'danger')
            return redirect(url_for('files.upload_file'))
        folder_path = os.path.join(UPLOAD_FOLDER, folder)
        try:
            os.makedirs(folder_path, exist_ok=False)
            flash('Folder created successfully!', 'success')
        except FileExistsError:
            flash('Folder already exists.', 'warning')
        except Exception as e:
            flash(f'Error creating folder: {str(e)}', 'danger')
        return redirect(url_for('files.upload_file'))

    @app.route('/files/search', methods=['GET'], endpoint='files.search_files')
    @role_required([Roles.SUPER_HQ])
    def search_files():
        query = request.args.get('q', '').strip()
        folder = request.args.get('folder', '').strip()
        tags = request.args.get('tags', '').strip()
        files_query = UploadedFile.query
        if query:
            files_query = files_query.filter(UploadedFile.filename.ilike(f'%{query}%'))
        if folder:
            files_query = files_query.filter(UploadedFile.folder == folder)
        if tags:
            files_query = files_query.filter(UploadedFile.tags.ilike(f'%{tags}%'))
        files = files_query.order_by(UploadedFile.uploaded_at.desc()).all()
        return render_template('files/search.html', files=files, query=query, folder=folder, tags=tags)

    @app.route('/files/<int:file_id>', methods=['GET', 'POST', 'DELETE'], endpoint='files.file_detail')
    @role_required([Roles.SUPER_HQ])
    def file_detail(file_id):
        file_record = UploadedFile.query.get_or_404(file_id)
        if request.method == 'POST':
            tags = request.form.get('tags', '').strip()
            if tags:
                file_record.tags = tags
                db.session.commit()
                flash('Tags updated!', 'success')
            return redirect(url_for('files.file_detail', file_id=file_id))
        elif request.method == 'DELETE':
            try:
                os.remove(file_record.path)
            except Exception:
                pass  # Ignore file not found
            db.session.delete(file_record)
            db.session.commit()
            flash('File deleted!', 'success')
            return redirect(url_for('files.search_files'))
        return render_template('files/detail.html', file=file_record)

    @app.route('/files/<int:file_id>/download', endpoint='files.download_file')
    @role_required([Roles.SUPER_HQ])
    def download_file(file_id):
        file_record = UploadedFile.query.get_or_404(file_id)
        try:
            return send_file(file_record.path, as_attachment=True, download_name=file_record.filename)
        except Exception as e:
            flash('File not found or could not be downloaded.', 'danger')
            return redirect(url_for('files.search_files'))



    # ============================================================================
    # ROUTES FROM DASHBOARD.PY
    # ============================================================================



# Super HQ Dashboard
    @app.route('/dashboard/super-hq', endpoint='dashboard.super_hq_dashboard')
    @role_required([Roles.SUPER_HQ])
    def super_hq_dashboard():
    
    # Get summary data for the dashboard
        current_datetime = datetime.now()
    
    # Calculate summary statistics
        summary = {
            'total_roles': Role.query.count(),
            'total_employees': Employee.query.count(),
            'total_projects': Project.query.count(),
            'total_orders': PurchaseOrder.query.count()
        }
    
        return render_template('admin/index.html', 
                             current_datetime=current_datetime,
                             summary=summary)

# HQ Dashboards
    @app.route('/dashboard/hq-finance', endpoint='dashboard.hq_finance_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def hq_finance_dashboard():
        return render_template('finance/index.html')

    @app.route('/dashboard/hq-hr', endpoint='dashboard.hq_hr_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def hq_hr_dashboard():
        return render_template('hr/index.html')

    @app.route('/dashboard/hq-procurement', endpoint='dashboard.hq_procurement_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT])
    def hq_procurement_dashboard():
        return render_template('procurement/index.html')

    @app.route('/dashboard/hq-quarry', endpoint='dashboard.hq_quarry_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def hq_quarry_dashboard():
        return render_template('quarry/hq_quarry.html')

    @app.route('/dashboard/hq-project', endpoint='dashboard.hq_project_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def hq_project_dashboard():
        return render_template('project/index.html')

# Staff Dashboards
    @app.route('/dashboard/finance-staff', endpoint='dashboard.finance_staff_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE, Roles.FINANCE_STAFF])
    def finance_staff_dashboard():
        return render_template('finance/index.html')

    @app.route('/dashboard/hr-staff', endpoint='dashboard.hr_staff_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR, Roles.HR_STAFF])
    def hr_staff_dashboard():
        return render_template('staff/hr_staff.html')

    @app.route('/dashboard/procurement-staff', endpoint='dashboard.procurement_staff_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, Roles.PROCUREMENT_STAFF])
    def procurement_staff_dashboard():
        return render_template('staff/procurement_staff.html')

    @app.route('/dashboard/quarry-staff', endpoint='dashboard.quarry_staff_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER, Roles.QUARRY_STAFF])
    def quarry_staff_dashboard():
        return render_template('staff/quarry_staff.html')

    @app.route('/dashboard/project-staff', endpoint='dashboard.project_staff_dashboard')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def project_staff_dashboard():
        return render_template('staff/project_staff.html')


    # ============================================================================
    # ROUTES FROM COST_CONTROL.PY
    # ============================================================================



# POST /cost-control/categories
    @app.route('/cost-control/categories', methods=['POST'], endpoint='cost_control.add_category')
    def add_category():
        data = request.get_json()
        category = CostCategory(
            project_id=data.get('project_id'),
            name=data.get('name'),
            type=data.get('type')
        )
        db.session.add(category)
        db.session.commit()
        return jsonify({'status': 'success', 'id': category.id})

# POST /cost-control/machinery
    @app.route('/cost-control/machinery', methods=['POST'], endpoint='cost_control.add_machinery')
    def add_machinery():
        data = request.get_json()
        machinery = Machinery(
            serial_no=data.get('serial_no'),
            description=data.get('description'),
            model=data.get('model'),
            status=data.get('status'),
            rate=data.get('rate'),
            days_active=data.get('days_active'),
            monthly_cost=data.get('monthly_cost'),
            warning_flag=data.get('warning_flag', False)
        )
        db.session.add(machinery)
        db.session.commit()
        return jsonify({'status': 'success', 'id': machinery.id})

# POST /cost-control/fuel-log
    @app.route('/cost-control/fuel-log', methods=['POST'], endpoint='cost_control.add_fuel_log')
    def add_fuel_log():
        data = request.get_json()
        fuel_log = FuelLog(
            serial_no=data.get('serial_no'),
            description=data.get('description'),
            equipment_code=data.get('equipment_code'),
            reg_no=data.get('reg_no'),
            operator=data.get('operator'),
            start_meter=data.get('start_meter'),
            end_meter=data.get('end_meter'),
            total_hours=data.get('total_hours'),
            fuel_consumed=data.get('fuel_consumed')
        )
        db.session.add(fuel_log)
        db.session.commit()
        return jsonify({'status': 'success', 'id': fuel_log.id})

# GET /cost-control/reports?project_id=123&type=variance
    @app.route('/cost-control/reports', methods=['GET'], endpoint='cost_control.get_reports')
    def get_reports():
        project_id = request.args.get('project_id')
        report_type = request.args.get('type')
        if report_type == 'variance':
            reports = CostVarianceReport.query.filter_by(project_id=project_id).all()
            result = []
            for r in reports:
                result.append({
                    'id': r.id,
                    'category': r.category,
                    'planned_amount': r.planned_amount,
                    'actual_amount': r.actual_amount,
                    'variance': r.variance
                })
            return jsonify({'status': 'success', 'reports': result})
        return jsonify({'status': 'error', 'message': 'Invalid report type'}), 400


    @app.route('/cost-control', endpoint='cost_control.cost_control_home')
    def cost_control_home():
    # Actual dashboard logic: show summary stats
        project_count = len(set([c.project_id for c in CostCategory.query.all()]))
        total_categories = CostCategory.query.count()
        total_machinery = Machinery.query.count()
        total_fuel_logs = FuelLog.query.count()
        total_variance_reports = CostVarianceReport.query.count()
        summary = {
            'project_count': project_count,
            'total_categories': total_categories,
            'total_machinery': total_machinery,
            'total_fuel_logs': total_fuel_logs,
            'total_variance_reports': total_variance_reports
        }
        return render_template('cost_control/dashboard.html', summary=summary)

    # ===================================================================
    # COST CONTROL MANAGER - COMPREHENSIVE ENDPOINTS
    # ===================================================================
    
    @app.route('/cost-control/manager/dashboard', endpoint='cost_control_mgr.dashboard')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def cost_control_manager_dashboard():
        """Cost Control Manager dashboard with KPIs and alerts"""
        from sqlalchemy import func
        from datetime import datetime, timedelta
        
        # Get active projects
        active_projects = Project.query.filter_by(status='In Progress').all()
        project_count = len(active_projects)
        
        # Budget summary across all projects
        total_allocated = db.session.query(func.sum(Budget.allocated_amount)).scalar() or 0
        total_spent = db.session.query(func.sum(Budget.spent_amount)).scalar() or 0
        total_remaining = total_allocated - total_spent
        overall_usage = (total_spent / total_allocated * 100) if total_allocated > 0 else 0
        
        # Get budget alerts (projects over 80% budget usage)
        budget_alerts = []
        for project in active_projects:
            project_budgets = Budget.query.filter_by(project_id=project.id).all()
            for budget in project_budgets:
                if budget.usage_percentage > 80:
                    budget_alerts.append({
                        'project_name': project.name,
                        'category': budget.category,
                        'usage_percentage': budget.usage_percentage,
                        'remaining': budget.remaining_amount,
                        'severity': 'critical' if budget.usage_percentage > 95 else 'warning'
                    })
        
        # Recent cost tracking entries (last 10)
        recent_entries = CostTrackingEntry.query.order_by(
            CostTrackingEntry.created_at.desc()
        ).limit(10).all()
        
        # Pending approvals count
        pending_approvals = CostApproval.query.filter_by(
            status='pending',
            required_role=Roles.HQ_COST_CONTROL
        ).count()
        
        # Pending budget adjustments
        pending_adjustments = BudgetAdjustment.query.filter_by(status='pending').count()
        
        # Variance summary (positive vs negative)
        variance_data = db.session.query(
            func.sum(CostTrackingEntry.variance).label('total_variance'),
            func.count(CostTrackingEntry.id).label('entry_count')
        ).filter(
            CostTrackingEntry.variance != 0
        ).first()
        
        # Calculate monthly burn rate (last 30 days)
        thirty_days_ago = datetime.now(timezone.utc) - timedelta(days=30)
        monthly_spend = db.session.query(
            func.sum(CostTrackingEntry.actual_cost)
        ).filter(
            CostTrackingEntry.entry_date >= thirty_days_ago
        ).scalar() or 0
        
        # Top 5 projects by spending
        top_spending_projects = db.session.query(
            Project.name,
            func.sum(CostTrackingEntry.actual_cost).label('total_spend')
        ).join(
            CostTrackingEntry, Project.id == CostTrackingEntry.project_id
        ).group_by(
            Project.name
        ).order_by(
            func.sum(CostTrackingEntry.actual_cost).desc()
        ).limit(5).all()
        
        # Prepare chart data for spending by category
        spending_by_category = db.session.query(
            CostTrackingEntry.cost_type,
            func.sum(CostTrackingEntry.actual_cost).label('amount')
        ).group_by(
            CostTrackingEntry.cost_type
        ).all()
        
        dashboard_data = {
            'kpis': {
                'project_count': project_count,
                'total_allocated': total_allocated,
                'total_spent': total_spent,
                'total_remaining': total_remaining,
                'overall_usage': round(overall_usage, 2),
                'monthly_burn_rate': monthly_spend,
                'pending_approvals': pending_approvals,
                'pending_adjustments': pending_adjustments,
                'total_variance': (variance_data.total_variance if variance_data and variance_data.total_variance else 0),
                'variance_entries': (variance_data.entry_count if variance_data and variance_data.entry_count else 0)
            },
            'budget_alerts': budget_alerts[:10],  # Top 10 alerts
            'recent_entries': recent_entries,
            'top_spending_projects': [
                {'name': p[0], 'amount': p[1]} for p in top_spending_projects
            ],
            'spending_by_category': {
                cat: float(amt) for cat, amt in spending_by_category
            },
            'pending_approvals_count': pending_approvals,
            'notifications_count': pending_approvals + pending_adjustments
        }
        
        return render_template('cost_control/manager/dashboard.html', **dashboard_data)
    
    
    @app.route('/cost-control/manager/cost-tracking', methods=['GET', 'POST'], endpoint='cost_control_mgr.cost_tracking')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def cost_tracking():
        """Add and view cost tracking entries with budget updates"""
        if request.method == 'POST':
            try:
                data = request.form
                project_id = int(data.get('project_id'))
                category_id = int(data.get('category_id')) if data.get('category_id') else None
                actual_cost = float(data.get('actual_cost', 0))
                
                # Validate project exists
                project = Project.query.get(project_id)
                if not project:
                    flash('Invalid project selected', 'error')
                    return redirect(url_for('cost_control_mgr.cost_tracking'))
                
                # Get category to determine budget category
                category = CostCategory.query.get(category_id) if category_id else None
                budget_category = category.type if category else data.get('cost_type')
                
                # Create new cost tracking entry
                entry = CostTrackingEntry(
                    project_id=project_id,
                    category_id=category_id,
                    entry_date=datetime.strptime(data.get('entry_date'), '%Y-%m-%d').date(),
                    description=data.get('description'),
                    planned_cost=float(data.get('planned_cost', 0)),
                    actual_cost=actual_cost,
                    cost_type=data.get('cost_type'),
                    quantity=float(data.get('quantity', 0)) if data.get('quantity') else None,
                    unit=data.get('unit'),
                    unit_cost=float(data.get('unit_cost', 0)) if data.get('unit_cost') else None,
                    created_by=current_user.id
                )
                
                # Calculate variance
                entry.calculate_variance()
                
                # Add entry first to get ID
                db.session.add(entry)
                
                # Check if approval required (variance > 10%)
                if abs(entry.variance_percentage) > 10:
                    entry.requires_approval = True
                    entry.status = 'pending'
                    
                    # Flush to get entry.id before creating approval
                    db.session.flush()
                    
                    # Create approval request (now entry.id exists)
                    approval = CostApproval(
                        reference_type='cost_entry',
                        reference_id=entry.id,
                        project_id=entry.project_id,
                        required_role=Roles.HQ_COST_CONTROL,
                        amount=entry.actual_cost,
                        description=f"Cost variance: {entry.variance_percentage:.1f}% - {entry.description}",
                        created_by=current_user.id
                    )
                    db.session.add(approval)
                    
                    # Notify Cost Control managers about the approval request
                    cost_control_users = User.query.filter(
                        User.role.in_([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
                    ).all()
                    
                    for user in cost_control_users:
                        notification = Notification(
                            user_id=user.id,
                            title='Cost Entry Approval Required',
                            message=f'High variance cost entry requires approval: {entry.description} ({entry.variance_percentage:.1f}% variance)',
                            notification_type='approval_required',
                            reference_type='cost_approval',
                            reference_id=approval.id
                        )
                        db.session.add(notification)
                    
                    flash(f'Cost entry created with {entry.variance_percentage:.1f}% variance. Approval required.', 'warning')
                else:
                    entry.status = 'approved'
                    flash('Cost entry added successfully', 'success')
                
                # Update budget spent_amount
                budget = Budget.query.filter_by(
                    project_id=project_id,
                    category=budget_category
                ).first()
                
                if budget:
                    budget.spent_amount += actual_cost
                    budget.updated_at = datetime.now(timezone.utc)
                    
                    # Check if budget is exceeded
                    if budget.spent_amount > budget.allocated_amount:
                        overage = budget.spent_amount - budget.allocated_amount
                        flash(f'Warning: Budget exceeded by {overage:.2f} for {budget_category}', 'warning')
                        
                        # Log audit
                        current_app.logger.warning(
                            f"Budget exceeded - Project: {project.name}, Category: {budget_category}, "
                            f"Overage: {overage:.2f}, Entry: {entry.id}, User: {current_user.id}"
                        )
                else:
                    # Create new budget entry if it doesn't exist
                    budget = Budget(
                        project_id=project_id,
                        category=budget_category,
                        allocated_amount=0.0,  # Will need to be set by admin
                        spent_amount=actual_cost,
                        status='active',
                        fiscal_year=datetime.now().year
                    )
                    db.session.add(budget)
                    flash(f'Note: No budget exists for {budget_category}. Budget tracking created.', 'info')
                
                # Log audit trail
                current_app.logger.info(
                    f"Cost entry created - Project: {project.name}, Category: {budget_category}, "
                    f"Amount: {actual_cost}, Variance: {entry.variance_percentage:.1f}%, User: {current_user.id}"
                )
                
                db.session.commit()
                return redirect(url_for('cost_control_mgr.cost_tracking'))
                
            except Exception as e:
                db.session.rollback()
                current_app.logger.error(f"Error adding cost entry: {str(e)}\n{traceback.format_exc()}")
                flash(f'Error adding cost entry: {str(e)}', 'error')
                return redirect(url_for('cost_control_mgr.cost_tracking'))
        
        # GET request - show all entries with filters
        project_id = request.args.get('project_id', type=int)
        cost_type = request.args.get('cost_type')
        date_from = request.args.get('date_from')
        date_to = request.args.get('date_to')
        
        query = CostTrackingEntry.query
        
        if project_id:
            query = query.filter_by(project_id=project_id)
        if cost_type:
            query = query.filter_by(cost_type=cost_type)
        if date_from:
            query = query.filter(CostTrackingEntry.entry_date >= date_from)
        if date_to:
            query = query.filter(CostTrackingEntry.entry_date <= date_to)
        
        entries = query.order_by(CostTrackingEntry.entry_date.desc()).all()
        
        # Get projects and categories for dropdowns
        projects = Project.query.filter_by(status='In Progress').all()
        
        # Get all categories (will be filtered by project in frontend via AJAX)
        categories = CostCategory.query.all()
        
        # Get budget summary for context
        budget_summary = {}
        if project_id:
            budgets = Budget.query.filter_by(project_id=project_id).all()
            for budget in budgets:
                budget_summary[budget.category] = {
                    'allocated': budget.allocated_amount,
                    'spent': budget.spent_amount,
                    'remaining': budget.remaining_amount,
                    'usage_percentage': budget.usage_percentage
                }
        
        return render_template('cost_control/manager/cost_tracking.html',
                             entries=entries,
                             projects=projects,
                             categories=categories,
                             budget_summary=budget_summary,
                             selected_project_id=project_id)
    
    
    @app.route('/cost-control/manager/api/categories/<int:project_id>', endpoint='cost_control_mgr.get_project_categories')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def get_project_categories(project_id):
        """API endpoint to fetch categories for a specific project"""
        try:
            categories = CostCategory.query.filter_by(project_id=project_id).all()
            return jsonify({
                'success': True,
                'categories': [
                    {
                        'id': cat.id,
                        'name': cat.name,
                        'type': cat.type
                    }
                    for cat in categories
                ]
            })
        except Exception as e:
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500
    
    
    @app.route('/cost-control/manager/variance-analysis', endpoint='cost_control_mgr.variance_analysis')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def variance_analysis():
        """Detailed variance analysis - planned vs actual"""
        from sqlalchemy import func
        
        project_id = request.args.get('project_id', type=int)
        period = request.args.get('period', 'month')  # week, month, quarter, year
        
        # Calculate date range based on period
        today = datetime.now(timezone.utc)
        if period == 'week':
            date_from = today - timedelta(days=7)
        elif period == 'month':
            date_from = today - timedelta(days=30)
        elif period == 'quarter':
            date_from = today - timedelta(days=90)
        else:  # year
            date_from = today - timedelta(days=365)
        
        # Build query
        query = db.session.query(
            CostTrackingEntry.cost_type,
            func.sum(CostTrackingEntry.planned_cost).label('total_planned'),
            func.sum(CostTrackingEntry.actual_cost).label('total_actual'),
            func.sum(CostTrackingEntry.variance).label('total_variance'),
            func.count(CostTrackingEntry.id).label('entry_count')
        ).filter(
            CostTrackingEntry.entry_date >= date_from
        )
        
        if project_id:
            query = query.filter(CostTrackingEntry.project_id == project_id)
        
        variance_by_type = query.group_by(CostTrackingEntry.cost_type).all()
        
        # Project-wise variance summary
        project_variance = db.session.query(
            Project.name,
            Project.id,
            func.sum(CostTrackingEntry.planned_cost).label('planned'),
            func.sum(CostTrackingEntry.actual_cost).label('actual'),
            func.sum(CostTrackingEntry.variance).label('variance')
        ).join(
            CostTrackingEntry, Project.id == CostTrackingEntry.project_id
        ).filter(
            CostTrackingEntry.entry_date >= date_from
        ).group_by(
            Project.name, Project.id
        ).all()
        
        # Worst performing categories (highest negative variance)
        worst_categories = db.session.query(
            CostCategory.name,
            CostTrackingEntry.cost_type,
            func.sum(CostTrackingEntry.variance).label('total_variance')
        ).join(
            CostTrackingEntry, CostCategory.id == CostTrackingEntry.category_id
        ).filter(
            CostTrackingEntry.entry_date >= date_from
        ).group_by(
            CostCategory.name, CostTrackingEntry.cost_type
        ).order_by(
            func.sum(CostTrackingEntry.variance).asc()
        ).limit(10).all()
        
        # Prepare chart data
        chart_data = {
            'labels': [v[0] for v in variance_by_type],
            'planned': [float(v[1]) for v in variance_by_type],
            'actual': [float(v[2]) for v in variance_by_type],
            'variance': [float(v[3]) for v in variance_by_type]
        }
        
        projects = Project.query.filter_by(status='In Progress').all()
        
        return render_template('cost_control/manager/variance_analysis.html',
                             variance_by_type=variance_by_type,
                             project_variance=project_variance,
                             worst_categories=worst_categories,
                             chart_data=chart_data,
                             projects=projects,
                             selected_project=project_id,
                             selected_period=period)
    
    
    @app.route('/cost-control/manager/budget-adjustments', methods=['GET', 'POST'], endpoint='cost_control_mgr.budget_adjustments')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def budget_adjustments():
        """Request and manage budget adjustments"""
        if request.method == 'POST':
            try:
                data = request.form
                
                budget_id = data.get('budget_id')
                budget = Budget.query.get(budget_id)
                
                if not budget:
                    flash('Budget not found', 'error')
                    return redirect(url_for('cost_control_mgr.budget_adjustments'))
                
                new_amount = float(data.get('new_amount'))
                adjustment_amount = new_amount - budget.allocated_amount
                
                # Create budget adjustment request
                adjustment = BudgetAdjustment(
                    project_id=budget.project_id,
                    budget_id=budget_id,
                    category=budget.category,
                    old_amount=budget.allocated_amount,
                    new_amount=new_amount,
                    adjustment_amount=adjustment_amount,
                    adjustment_type='increase' if adjustment_amount > 0 else 'decrease',
                    reason=data.get('reason'),
                    impact_analysis=data.get('impact_analysis'),
                    requested_by=current_user.id
                )
                
                db.session.add(adjustment)
                db.session.flush()  # Flush to get the adjustment.id before creating approval
                
                # Create approval workflow
                approval = CostApproval(
                    reference_type='budget_adjustment',
                    reference_id=adjustment.id,
                    project_id=budget.project_id,
                    required_role=Roles.HQ_FINANCE,
                    amount=abs(adjustment_amount),
                    description=f"Budget adjustment: {budget.category} - {adjustment.adjustment_type}",
                    created_by=current_user.id
                )
                db.session.add(approval)
                
                # Notify Finance users about budget adjustment request
                finance_users = User.query.filter(
                    User.role.in_([Roles.HQ_FINANCE, Roles.SUPER_HQ])
                ).all()
                
                for user in finance_users:
                    notification = Notification(
                        user_id=user.id,
                        title='Budget Adjustment Approval Required',
                        message=f'Budget adjustment request: {budget.category} - {adjustment.adjustment_type} of {abs(adjustment_amount):,.2f}',
                        notification_type='approval_required',
                        reference_type='cost_approval',
                        reference_id=approval.id
                    )
                    db.session.add(notification)
                
                db.session.commit()
                flash('Budget adjustment request submitted to Finance for approval', 'success')
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error submitting adjustment request: {str(e)}', 'error')
        
        # GET request - show all adjustments
        status_filter = request.args.get('status', 'all')
        project_id = request.args.get('project_id', type=int)
        
        query = BudgetAdjustment.query
        
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        if project_id:
            query = query.filter_by(project_id=project_id)
        
        adjustments = query.order_by(BudgetAdjustment.requested_at.desc()).all()
        
        # Get projects and budgets for forms
        projects = Project.query.filter_by(status='In Progress').all()
        budgets = Budget.query.all()
        
        return render_template('cost_control/manager/budget_adjustments.html',
                             adjustments=adjustments,
                             projects=projects,
                             budgets=budgets)
    
    
    @app.route('/cost-control/manager/budget-adjustment/<int:adjustment_id>/approve', methods=['POST'], endpoint='cost_control_mgr.approve_adjustment')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def approve_budget_adjustment(adjustment_id):
        """Approve budget adjustment request"""
        adjustment = BudgetAdjustment.query.get_or_404(adjustment_id)
        
        action = request.form.get('action')  # approve or reject
        comments = request.form.get('comments')
        
        if action == 'approve':
            adjustment.status = 'approved'
            adjustment.approved_by = current_user.id
            adjustment.approved_at = datetime.now(timezone.utc)
            adjustment.approval_comments = comments
            
            # Update the actual budget
            budget = Budget.query.get(adjustment.budget_id)
            budget.allocated_amount = adjustment.new_amount
            
            flash('Budget adjustment approved successfully', 'success')
        else:
            adjustment.status = 'rejected'
            adjustment.reviewed_by = current_user.id
            adjustment.reviewed_at = datetime.now(timezone.utc)
            adjustment.review_comments = comments
            
            flash('Budget adjustment rejected', 'info')
        
        db.session.commit()
        return redirect(url_for('cost_control_mgr.budget_adjustments'))
    
    
    @app.route('/cost-control/manager/cash-flow', methods=['GET', 'POST'], endpoint='cost_control_mgr.cash_flow')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def cash_flow_forecast():
        """Cash flow forecasting and monitoring"""
        if request.method == 'POST':
            try:
                data = request.form
                
                forecast = CashFlowForecast(
                    project_id=data.get('project_id'),
                    forecast_period=data.get('forecast_period'),
                    period_start=datetime.strptime(data.get('period_start'), '%Y-%m-%d').date(),
                    period_end=datetime.strptime(data.get('period_end'), '%Y-%m-%d').date(),
                    expected_inflow=float(data.get('expected_inflow', 0)),
                    actual_inflow=float(data.get('actual_inflow', 0)),
                    expected_outflow=float(data.get('expected_outflow', 0)),
                    actual_outflow=float(data.get('actual_outflow', 0)),
                    opening_balance=float(data.get('opening_balance', 0)),
                    labor_cost=float(data.get('labor_cost', 0)),
                    material_cost=float(data.get('material_cost', 0)),
                    equipment_cost=float(data.get('equipment_cost', 0)),
                    subcontractor_cost=float(data.get('subcontractor_cost', 0)),
                    overhead_cost=float(data.get('overhead_cost', 0)),
                    notes=data.get('notes'),
                    created_by=current_user.id
                )
                
                forecast.calculate_net_flow()
                
                db.session.add(forecast)
                db.session.commit()
                
                flash('Cash flow forecast added successfully', 'success')
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding cash flow forecast: {str(e)}', 'error')
        
        # GET request
        project_id = request.args.get('project_id', type=int)
        period = request.args.get('period', 'monthly')
        
        query = CashFlowForecast.query
        
        if project_id:
            query = query.filter_by(project_id=project_id)
        if period:
            query = query.filter_by(forecast_period=period)
        
        forecasts = query.order_by(CashFlowForecast.period_start.desc()).all()
        
        # Calculate aggregated cash flow
        total_expected_in = sum(f.expected_inflow for f in forecasts)
        total_actual_in = sum(f.actual_inflow for f in forecasts)
        total_expected_out = sum(f.expected_outflow for f in forecasts)
        total_actual_out = sum(f.actual_outflow for f in forecasts)
        
        # Prepare chart data
        chart_data = {
            'labels': [f"{f.period_start.strftime('%b %Y')}" for f in forecasts[:12]],
            'expected_inflow': [float(f.expected_inflow) for f in forecasts[:12]],
            'actual_inflow': [float(f.actual_inflow) for f in forecasts[:12]],
            'expected_outflow': [float(f.expected_outflow) for f in forecasts[:12]],
            'actual_outflow': [float(f.actual_outflow) for f in forecasts[:12]],
            'net_flow': [float(f.net_cash_flow) for f in forecasts[:12]]
        }
        
        projects = Project.query.filter_by(status='In Progress').all()
        
        return render_template('cost_control/manager/cash_flow.html',
                             forecasts=forecasts,
                             projects=projects,
                             chart_data=chart_data,
                             summary={
                                 'total_expected_in': total_expected_in,
                                 'total_actual_in': total_actual_in,
                                 'total_expected_out': total_expected_out,
                                 'total_actual_out': total_actual_out
                             })
    
    
    @app.route('/cost-control/manager/approvals', methods=['GET', 'POST'], endpoint='cost_control_mgr.approvals')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def cost_approvals():
        """Cost approval queue and processing"""
        if request.method == 'POST':
            approval_id = request.form.get('approval_id')
            action = request.form.get('action')
            comments = request.form.get('comments')
            
            approval = CostApproval.query.get_or_404(approval_id)
            
            if action == 'approve':
                approval.status = 'approved'
                approval.approver_id = current_user.id
                approval.approved_at = datetime.now(timezone.utc)
                approval.comments = comments
                approval.action_taken = 'approved'
                
                # Update referenced entry if it's a cost entry
                if approval.reference_type == 'cost_entry':
                    entry = CostTrackingEntry.query.get(approval.reference_id)
                    if entry:
                        entry.status = 'approved'
                        entry.approved_by = current_user.id
                        entry.approved_at = datetime.now(timezone.utc)
                        
                        # Notify the creator
                        creator = User.query.get(entry.created_by)
                        if creator:
                            notification = Notification(
                                user_id=creator.id,
                                title='Cost Entry Approved',
                                message=f'Your cost entry has been approved: {entry.description}',
                                notification_type='approval_update',
                                reference_type='cost_entry',
                                reference_id=entry.id
                            )
                            db.session.add(notification)
                
                # Update budget if it's a budget adjustment
                elif approval.reference_type == 'budget_adjustment':
                    adjustment = BudgetAdjustment.query.get(approval.reference_id)
                    if adjustment:
                        adjustment.status = 'approved'
                        adjustment.approved_by = current_user.id
                        adjustment.approved_at = datetime.now(timezone.utc)
                        adjustment.approval_comments = comments
                        
                        # Update the actual budget
                        budget = Budget.query.get(adjustment.budget_id)
                        if budget:
                            budget.allocated_amount = adjustment.new_amount
                            budget.updated_at = datetime.now(timezone.utc)
                        
                        # Notify the requester
                        requester = User.query.get(adjustment.requested_by)
                        if requester:
                            notification = Notification(
                                user_id=requester.id,
                                title='Budget Adjustment Approved',
                                message=f'Budget adjustment approved: {adjustment.category} - New amount: {adjustment.new_amount:,.2f}',
                                notification_type='approval_update',
                                reference_type='budget_adjustment',
                                reference_id=adjustment.id
                            )
                            db.session.add(notification)
                
                flash('Approval processed successfully', 'success')
                
            elif action == 'reject':
                approval.status = 'rejected'
                approval.approver_id = current_user.id
                approval.approved_at = datetime.now(timezone.utc)
                approval.comments = comments
                approval.action_taken = 'rejected'
                
                # Update referenced entry
                if approval.reference_type == 'cost_entry':
                    entry = CostTrackingEntry.query.get(approval.reference_id)
                    if entry:
                        entry.status = 'rejected'
                        
                        # Notify the creator
                        creator = User.query.get(entry.created_by)
                        if creator:
                            notification = Notification(
                                user_id=creator.id,
                                title='Cost Entry Rejected',
                                message=f'Your cost entry was rejected: {entry.description}. Reason: {comments}',
                                notification_type='approval_update',
                                reference_type='cost_entry',
                                reference_id=entry.id
                            )
                            db.session.add(notification)
                
                # Update budget adjustment status
                elif approval.reference_type == 'budget_adjustment':
                    adjustment = BudgetAdjustment.query.get(approval.reference_id)
                    if adjustment:
                        adjustment.status = 'rejected'
                        adjustment.approval_comments = comments
                        
                        # Notify the requester
                        requester = User.query.get(adjustment.requested_by)
                        if requester:
                            notification = Notification(
                                user_id=requester.id,
                                title='Budget Adjustment Rejected',
                                message=f'Budget adjustment rejected: {adjustment.category}. Reason: {comments}',
                                notification_type='approval_update',
                                reference_type='budget_adjustment',
                                reference_id=adjustment.id
                            )
                            db.session.add(notification)
                
                flash('Approval rejected', 'info')
                
            elif action == 'escalate':
                approval.escalate_to_next_level()
                approval.comments = comments
                flash('Approval escalated to next level', 'info')
            
            db.session.commit()
            return redirect(url_for('cost_control_mgr.approvals'))
        
        # GET request - show pending approvals
        status_filter = request.args.get('status', 'pending')
        
        query = CostApproval.query
        
        if current_user.role != Roles.SUPER_HQ:
            query = query.filter_by(required_role=current_user.role)
        
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        approvals = query.order_by(CostApproval.created_at.desc()).all()
        
        # Enrich approval data with project and reference info
        enriched_approvals = []
        for approval in approvals:
            project = Project.query.get(approval.project_id)
            
            ref_details = {}
            if approval.reference_type == 'cost_entry':
                entry = CostTrackingEntry.query.get(approval.reference_id)
                if entry:
                    ref_details = {
                        'description': entry.description,
                        'actual_cost': entry.actual_cost,
                        'variance_percentage': entry.variance_percentage
                    }
            elif approval.reference_type == 'budget_adjustment':
                adjustment = BudgetAdjustment.query.get(approval.reference_id)
                if adjustment:
                    ref_details = {
                        'category': adjustment.category,
                        'old_amount': adjustment.old_amount,
                        'new_amount': adjustment.new_amount,
                        'reason': adjustment.reason
                    }
            
            enriched_approvals.append({
                'approval': approval,
                'project': project,
                'reference_details': ref_details
            })
        
        return render_template('cost_control/manager/approvals.html',
                             approvals=enriched_approvals)
    
    
    @app.route('/cost-control/manager/purchase-order-approvals', methods=['GET'], endpoint='cost_control_mgr.purchase_order_approvals')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def cost_control_purchase_order_approvals():
        """View pending purchase orders for Cost Control approval"""
        from models import ApprovalWorkflow, WorkflowStep
        from utils.workflow import get_pending_approvals_for_user
        
        # Get workflows pending Cost Control approval
        pending_workflows = get_pending_approvals_for_user(current_user)
        
        # Filter for purchase orders only
        po_workflows = [w for w in pending_workflows if w.workflow_type == 'purchase_order']
        
        # Enrich with PO details
        enriched_workflows = []
        for workflow in po_workflows:
            po = PurchaseOrder.query.get(workflow.reference_id)
            if po:
                # Get current step
                current_step = WorkflowStep.query.filter_by(
                    workflow_id=workflow.id,
                    required_role=current_user.role,
                    status='pending'
                ).first()
                
                enriched_workflows.append({
                    'workflow': workflow,
                    'po': po,
                    'current_step': current_step,
                    'line_items': po.line_items
                })
        
        return render_template('cost_control/manager/purchase_order_approvals.html',
                             workflows=enriched_workflows)
    
    
    @app.route('/cost-control/manager/purchase-orders/<int:po_id>/approve', methods=['POST'], endpoint='cost_control_mgr.approve_purchase_order')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def cost_control_approve_purchase_order(po_id):
        """Approve or reject purchase order at Cost Control stage"""
        from models import ApprovalWorkflow, WorkflowStep
        from utils.workflow import approve_workflow_step, reject_workflow_step, log_audit as workflow_log_audit
        
        try:
            po = PurchaseOrder.query.get_or_404(po_id)
            
            if not po.workflow_id:
                flash('Purchase order does not have an approval workflow', 'error')
                return redirect(url_for('cost_control_mgr.purchase_order_approvals'))
            
            action = request.form.get('action')
            comments = request.form.get('comments', '').strip()
            
            workflow = ApprovalWorkflow.query.get(po.workflow_id)
            if not workflow:
                flash('Workflow not found', 'error')
                return redirect(url_for('cost_control_mgr.purchase_order_approvals'))
            
            # Get current step
            current_step = WorkflowStep.query.filter_by(
                workflow_id=workflow.id,
                required_role=current_user.role,
                status='pending'
            ).first()
            
            if not current_step:
                flash('No pending approval step found', 'error')
                return redirect(url_for('cost_control_mgr.purchase_order_approvals'))
            
            if action == 'approve':
                # Approve workflow step
                success, message, next_step = approve_workflow_step(
                    workflow_id=workflow.id,
                    step_order=current_step.step_order,
                    approver_id=current_user.id,
                    comments=comments
                )
                
                if success:
                    # Update PO details
                    po.cost_control_approved_by = current_user.id
                    po.cost_control_approved_at = datetime.now(timezone.utc)
                    po.cost_control_comments = comments
                    
                    if next_step:
                        # Moving to Finance approval
                        po.status = 'Pending_Finance'
                    else:
                        # Final approval
                        po.status = 'Approved'
                        po.approval_date = datetime.now(timezone.utc)
                    
                    db.session.commit()
                    flash(message, 'success')
                else:
                    flash(message, 'error')
                    
            elif action == 'reject':
                if not comments:
                    flash('Rejection reason is required', 'error')
                    return redirect(url_for('cost_control_mgr.purchase_order_approvals'))
                
                # Reject workflow
                success, message = reject_workflow_step(
                    workflow_id=workflow.id,
                    step_order=current_step.step_order,
                    rejector_id=current_user.id,
                    comments=comments
                )
                
                if success:
                    # Update PO status
                    po.status = 'Rejected'
                    po.notes = (po.notes or '') + f"\n[{datetime.now().strftime('%Y-%m-%d %H:%M')}] Cost Control Rejected: {comments}"
                    
                    db.session.commit()
                    flash(message, 'info')
                else:
                    flash(message, 'error')
            
            return redirect(url_for('cost_control_mgr.purchase_order_approvals'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error processing PO approval: {str(e)}", exc_info=True)
            flash(f'Error processing approval: {str(e)}', 'error')
            return redirect(url_for('cost_control_mgr.purchase_order_approvals'))
    
    
    @app.route('/cost-control/manager/expenditure-reports', endpoint='cost_control_mgr.expenditure_reports')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def expenditure_reports():
        """Detailed expenditure reports by category using cost tracking entries"""
        from sqlalchemy import func
        
        project_id = request.args.get('project_id', type=int)
        date_from = request.args.get('date_from')
        date_to = request.args.get('date_to')
        cost_type = request.args.get('cost_type')
        
        query = CostTrackingEntry.query
        
        if project_id:
            query = query.filter_by(project_id=project_id)
        if cost_type:
            query = query.filter_by(cost_type=cost_type)
        if date_from:
            query = query.filter(CostTrackingEntry.entry_date >= date_from)
        if date_to:
            query = query.filter(CostTrackingEntry.entry_date <= date_to)
        
        expenditures = query.order_by(CostTrackingEntry.entry_date.desc()).all()
        
        # Summary by cost type
        type_summary = db.session.query(
            CostTrackingEntry.cost_type,
            func.sum(CostTrackingEntry.actual_cost).label('total'),
            func.count(CostTrackingEntry.id).label('count')
        )
        
        if project_id:
            type_summary = type_summary.filter_by(project_id=project_id)
        if date_from:
            type_summary = type_summary.filter(CostTrackingEntry.entry_date >= date_from)
        if date_to:
            type_summary = type_summary.filter(CostTrackingEntry.entry_date <= date_to)
        
        type_summary = type_summary.group_by(CostTrackingEntry.cost_type).all()
        
        # Summary by project
        project_summary = db.session.query(
            Project.name,
            func.sum(CostTrackingEntry.actual_cost).label('total'),
            func.count(CostTrackingEntry.id).label('count')
        ).join(Project, Project.id == CostTrackingEntry.project_id)
        
        if date_from:
            project_summary = project_summary.filter(CostTrackingEntry.entry_date >= date_from)
        if date_to:
            project_summary = project_summary.filter(CostTrackingEntry.entry_date <= date_to)
        
        project_summary = project_summary.group_by(Project.name).order_by(
            func.sum(CostTrackingEntry.actual_cost).desc()
        ).all()
        
        # Calculate totals
        total_expenditure = sum(e.actual_cost for e in expenditures)
        total_planned = sum(e.planned_cost for e in expenditures)
        total_variance = total_expenditure - total_planned
        
        projects = Project.query.filter_by(status='In Progress').all()
        
        return render_template('cost_control/manager/expenditure_reports.html',
                             expenditures=expenditures,
                             type_summary=type_summary,
                             project_summary=project_summary,
                             projects=projects,
                             total_expenditure=total_expenditure,
                             total_planned=total_planned,
                             total_variance=total_variance,
                             selected_project_id=project_id,
                             selected_cost_type=cost_type)
    
    
    @app.route('/cost-control/manager/reports', endpoint='cost_control_mgr.reports')
    @role_required([Roles.HQ_COST_CONTROL, Roles.SUPER_HQ])
    def cost_control_reports():
        """Comprehensive cost performance reports"""
        from sqlalchemy import func
        
        # Overall project performance
        project_performance = db.session.query(
            Project.name,
            Project.id,
            Project.budget,
            func.sum(Budget.allocated_amount).label('budgeted'),
            func.sum(Budget.spent_amount).label('spent'),
            func.sum(CostTrackingEntry.variance).label('variance')
        ).outerjoin(
            Budget, Project.id == Budget.project_id
        ).outerjoin(
            CostTrackingEntry, Project.id == CostTrackingEntry.project_id
        ).group_by(
            Project.name, Project.id, Project.budget
        ).all()
        
        # Cost trend analysis (last 6 months)
        six_months_ago = datetime.now(timezone.utc) - timedelta(days=180)
        monthly_trends = db.session.query(
            func.strftime('%Y-%m', CostTrackingEntry.entry_date).label('month'),
            func.sum(CostTrackingEntry.actual_cost).label('total_cost')
        ).filter(
            CostTrackingEntry.entry_date >= six_months_ago
        ).group_by(
            'month'
        ).order_by(
            'month'
        ).all()
        
        # Top variance items (highest cost overruns)
        top_variances = db.session.query(
            CostTrackingEntry.description,
            Project.name,
            CostTrackingEntry.variance,
            CostTrackingEntry.variance_percentage,
            CostTrackingEntry.actual_cost
        ).join(
            Project, CostTrackingEntry.project_id == Project.id
        ).filter(
            CostTrackingEntry.variance > 0
        ).order_by(
            CostTrackingEntry.variance.desc()
        ).limit(20).all()
        
        # Efficiency metrics
        total_entries = CostTrackingEntry.query.count()
        approved_count = CostTrackingEntry.query.filter_by(status='approved').count()
        pending_count = CostTrackingEntry.query.filter_by(status='pending').count()
        
        return render_template('cost_control/manager/reports.html',
                             project_performance=project_performance,
                             monthly_trends=monthly_trends,
                             top_variances=top_variances,
                             metrics={
                                 'total_entries': total_entries,
                                 'approved_count': approved_count,
                                 'pending_count': pending_count,
                                 'approval_rate': (approved_count / total_entries * 100) if total_entries > 0 else 0
                             })

    # ===================================================================
    # HR MANAGER - COMPREHENSIVE ENDPOINTS
    # ===================================================================
    
    @app.route('/hr/manager/dashboard', endpoint='hr_mgr.dashboard')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def hr_manager_dashboard():
        """HR Manager dashboard with employee metrics and pending requests"""
        from sqlalchemy import func
        from datetime import datetime, timedelta
        
        # Employee statistics
        total_employees = Employee.query.filter_by(status='Active').count()
        total_departments = db.session.query(func.count(func.distinct(Employee.department))).scalar()
        
        # Recent hires (last 30 days)
        thirty_days_ago = datetime.now(timezone.utc) - timedelta(days=30)
        recent_hires = Employee.query.filter(
            Employee.date_of_employment >= thirty_days_ago.date()
        ).count()
        
        # Pending requests
        pending_leave_requests = Leave.query.filter_by(status='Pending').count()
        open_positions = 0  # RecruitmentRequest model not yet implemented
        pending_interviews = 0  # Interview model not yet implemented
        pending_appraisals = 0  # PerformanceAppraisal model not yet implemented
        
        # Attendance summary (today)
        today = datetime.now(timezone.utc).date()
        today_attendance = Attendance.query.filter_by(date=today).count()
        today_present = Attendance.query.filter_by(date=today, status='Present').count()
        today_late = Attendance.query.filter_by(date=today, status='Late').count()
        today_absent = Attendance.query.filter_by(date=today, status='Absent').count()
        
        # Department breakdown
        dept_breakdown = db.session.query(
            Employee.department,
            func.count(Employee.id).label('count')
        ).filter(
            Employee.status == 'Active'
        ).group_by(
            Employee.department
        ).all()
        
        # Upcoming leave (next 7 days)
        next_week = datetime.now(timezone.utc).date() + timedelta(days=7)
        upcoming_leaves = Leave.query.filter(
            Leave.status == 'Approved',
            Leave.start <= next_week,
            Leave.end >= datetime.now(timezone.utc).date()
        ).all()
        
        # Recent recruitment activities
        recent_interviews = []  # Interview model not yet implemented
        
        # Training completion rate
        total_trainings = 0  # TrainingRecord model not yet implemented
        completed_trainings = 0
        training_completion_rate = 0
        
        # Chart data: Employees by department
        chart_dept_labels = [d[0] or 'Unassigned' for d in dept_breakdown]
        chart_dept_data = [d[1] for d in dept_breakdown]
        
        dashboard_data = {
            'kpis': {
                'total_employees': total_employees,
                'total_departments': total_departments,
                'recent_hires': recent_hires,
                'pending_leaves': pending_leave_requests,
                'open_positions': open_positions,
                'pending_interviews': pending_interviews,
                'pending_appraisals': pending_appraisals,
                'today_present': today_present,
                'today_late': today_late,
                'today_absent': today_absent,
                'attendance_percentage': (today_present / total_employees * 100) if total_employees > 0 else 0,
                'training_completion_rate': training_completion_rate
            },
            'upcoming_leaves': upcoming_leaves,
            'recent_interviews': recent_interviews,
            'chart_data': {
                'dept_labels': chart_dept_labels,
                'dept_data': chart_dept_data
            }
        }
        
        return render_template('hr/manager/dashboard.html', **dashboard_data)
    
    
    @app.route('/hr/manager/employees', methods=['GET'], endpoint='hr_mgr.employees')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_employees():
        """View and manage all employees"""
        # Filters
        department = request.args.get('department')
        status = request.args.get('status', 'Active')
        search = request.args.get('search')
        
        query = Employee.query
        
        if department:
            query = query.filter_by(department=department)
        if status:
            query = query.filter_by(status=status)
        if search:
            query = query.filter(
                (Employee.name.ilike(f'%{search}%')) |
                (Employee.staff_code.ilike(f'%{search}%')) |
                (Employee.email.ilike(f'%{search}%'))
            )
        
        employees = query.order_by(Employee.name).all()
        
        # Get unique departments for filter
        departments = db.session.query(func.distinct(Employee.department)).filter(
            Employee.department.isnot(None)
        ).all()
        departments = [d[0] for d in departments]
        
        return render_template('hr/manager/employees.html',
                             employees=employees,
                             departments=departments)
    
    
    @app.route('/hr/manager/recruitment', methods=['GET', 'POST'], endpoint='hr_mgr.recruitment')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_recruitment():
        """Manage job postings and recruitment"""
        if request.method == 'POST':
            try:
                data = request.form
                
                # RecruitmentRequest model not yet implemented
                flash('Recruitment posting feature is not yet available', 'warning')
                return redirect(url_for('hr_mgr.recruitment'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating job posting: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status', 'open')
        
        # RecruitmentRequest model not yet implemented
        recruitments = []
        
        return render_template('hr/manager/recruitment.html',
                             recruitments=recruitments)
    
    
    @app.route('/hr/manager/interviews', methods=['GET', 'POST'], endpoint='hr_mgr.interviews')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_interviews():
        """Schedule and manage interviews"""
        if request.method == 'POST':
            try:
                data = request.form
                
                interview = Interview(
                    recruitment_id=data.get('recruitment_id'),
                    candidate_name=data.get('candidate_name'),
                    candidate_email=data.get('candidate_email'),
                    candidate_phone=data.get('candidate_phone'),
                    interview_type=data.get('interview_type'),
                    interview_round=int(data.get('interview_round', 1)),
                    scheduled_date=datetime.strptime(data.get('scheduled_date'), '%Y-%m-%d').date(),
                    scheduled_time=datetime.strptime(data.get('scheduled_time'), '%H:%M').time(),
                    duration_minutes=int(data.get('duration_minutes', 60)),
                    location=data.get('location'),
                    interviewer_names=data.get('interviewer_names'),
                    created_by=current_user.id
                )
                
                db.session.add(interview)
                
                # Interview model not yet implemented
                flash('Interview scheduling feature is not yet available', 'warning')
                return redirect(url_for('hr_mgr.interviews'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error scheduling interview: {str(e)}', 'error')
        
        # GET request - Interview and RecruitmentRequest models not yet implemented
        interviews = []
        open_positions = []
        
        return render_template('hr/manager/interviews.html',
                             interviews=interviews,
                             open_positions=open_positions)
    
    
    @app.route('/hr/manager/attendance', methods=['GET', 'POST'], endpoint='hr_mgr.attendance')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_attendance():
        """Track and manage employee attendance"""
        if request.method == 'POST':
            try:
                data = request.form
                
                attendance = AttendanceLog(
                    employee_id=data.get('employee_id'),
                    date=datetime.strptime(data.get('date'), '%Y-%m-%d').date(),
                    check_in_time=datetime.strptime(data.get('check_in_time'), '%Y-%m-%d %H:%M') if data.get('check_in_time') else None,
                    check_out_time=datetime.strptime(data.get('check_out_time'), '%Y-%m-%d %H:%M') if data.get('check_out_time') else None,
                    status=data.get('status', 'present'),
                    work_location=data.get('work_location'),
                    verification_method=data.get('verification_method', 'manual'),
                    verified_by=current_user.id,
                    notes=data.get('notes')
                )
                
                attendance.calculate_hours()
                
                db.session.add(attendance)
                db.session.commit()
                
                flash('Attendance recorded successfully', 'success')
                return redirect(url_for('hr_mgr.attendance'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error recording attendance: {str(e)}', 'error')
        
        # GET request
        date_filter = request.args.get('date', datetime.now(timezone.utc).strftime('%Y-%m-%d'))
        employee_id = request.args.get('employee_id', type=int)
        
        query = Attendance.query
        
        if date_filter:
            query = query.filter_by(date=datetime.strptime(date_filter, '%Y-%m-%d').date())
        if employee_id:
            query = query.filter_by(employee_id=employee_id)
        
        attendances = query.order_by(Attendance.date.desc()).all()
        
        # Attendance summary
        total_records = len(attendances)
        present_count = len([a for a in attendances if a.status == 'Present'])
        late_count = len([a for a in attendances if a.status == 'Late'])
        absent_count = len([a for a in attendances if a.status == 'Absent'])
        
        employees = Employee.query.filter_by(status='Active').all()
        
        return render_template('hr/manager/attendance.html',
                             attendances=attendances,
                             employees=employees,
                             summary={
                                 'total': total_records,
                                 'present': present_count,
                                 'late': late_count,
                                 'absent': absent_count
                             })
    
    
    @app.route('/hr/manager/leave', methods=['GET', 'POST'], endpoint='hr_mgr.leave')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_leave():
        """Manage leave requests and approvals"""
        if request.method == 'POST':
            action = request.form.get('action')
            
            if action == 'approve' or action == 'reject':
                leave_id = request.form.get('leave_id')
                comments = request.form.get('comments')
                
                leave_request = Leave.query.get_or_404(leave_id)
                
                if action == 'approve':
                    leave_request.status = 'approved'
                    leave_request.approved_by = current_user.id
                    leave_request.approved_at = datetime.now(timezone.utc)
                    leave_request.approval_comments = comments
                    flash('Leave request approved', 'success')
                else:
                    leave_request.status = 'rejected'
                    leave_request.reviewed_by = current_user.id
                    leave_request.reviewed_at = datetime.now(timezone.utc)
                    leave_request.review_comments = comments
                    flash('Leave request rejected', 'info')
                
                db.session.commit()
                return redirect(url_for('hr_mgr.leave'))
        
        # GET request
        status_filter = request.args.get('status', 'pending')
        
        query = Leave.query
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        leave_requests = query.order_by(Leave.created_at.desc()).all()
        
        # Enrich with employee data
        enriched_requests = []
        for lr in leave_requests:
            employee = Employee.query.get(lr.employee_id)
            enriched_requests.append({
                'leave': lr,
                'employee': employee
            })
        
        return render_template('hr/manager/leave.html',
                             leave_requests=enriched_requests)
    
    
    @app.route('/hr/manager/performance', methods=['GET', 'POST'], endpoint='hr_mgr.performance')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_performance():
        """Manage performance appraisals"""
        if request.method == 'POST':
            try:
                # PerformanceAppraisal model doesn't exist yet
                flash('Performance appraisal feature is under development', 'info')
                return redirect(url_for('hr_mgr.performance'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating appraisal: {str(e)}', 'error')
        
        # GET request
        period_filter = request.args.get('period')
        year_filter = request.args.get('year', type=int)
        
        # Since PerformanceAppraisal model doesn't exist, return empty list
        appraisals = []
        
        employees = Employee.query.filter_by(status='Active').all()
        
        return render_template('hr/manager/performance.html',
                             appraisals=appraisals,
                             employees=employees)
    
    
    @app.route('/hr/manager/training', methods=['GET', 'POST'], endpoint='hr_mgr.training')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manage_training():
        """Manage training programs and certifications"""
        if request.method == 'POST':
            try:
                # TrainingRecord model doesn't exist yet
                flash('Training management feature is under development', 'info')
                return redirect(url_for('hr_mgr.training'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating training record: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status')
        category_filter = request.args.get('category')
        
        # TrainingRecord model doesn't exist, return empty list
        trainings = []
        
        employees = Employee.query.filter_by(status='Active').all()
        
        return render_template('hr/manager/training.html',
                             trainings=trainings,
                             employees=employees)
    
    
    @app.route('/hr/manager/manpower', endpoint='hr_mgr.manpower')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def manpower_reports():
        """Manpower allocation and utilization reports"""
        from sqlalchemy import func
        
        # Active allocations
        active_allocations = ManpowerAllocation.query.filter_by(status='active').all()
        
        # Project-wise manpower
        project_manpower = db.session.query(
            Project.name,
            func.count(ManpowerAllocation.id).label('staff_count'),
            func.avg(ManpowerAllocation.allocation_percentage).label('avg_allocation')
        ).join(
            ManpowerAllocation, Project.id == ManpowerAllocation.project_id
        ).filter(
            ManpowerAllocation.status == 'active'
        ).group_by(
            Project.name
        ).all()
        
        # Department utilization
        dept_utilization = db.session.query(
            Employee.department,
            func.count(ManpowerAllocation.id).label('allocated_count'),
            func.count(Employee.id).label('total_count')
        ).outerjoin(
            ManpowerAllocation, 
            (Employee.id == ManpowerAllocation.employee_id) & 
            (ManpowerAllocation.status == 'active')
        ).filter(
            Employee.status == 'Active'
        ).group_by(
            Employee.department
        ).all()
        
        return render_template('hr/manager/manpower.html',
                             active_allocations=active_allocations,
                             project_manpower=project_manpower,
                             dept_utilization=dept_utilization)
    
    
    @app.route('/hr/manager/reports', endpoint='hr_mgr.reports')
    @role_required([Roles.HQ_HR, Roles.SUPER_HQ])
    def hr_reports():
        """Comprehensive HR reports and analytics"""
        from sqlalchemy import func
        
        # Employee demographics
        total_employees = Employee.query.filter_by(status='Active').count()
        
        # Headcount by department
        dept_headcount = db.session.query(
            Employee.department,
            func.count(Employee.id).label('count')
        ).filter(
            Employee.status == 'Active'
        ).group_by(
            Employee.department
        ).all()
        
        # Turnover analysis (last 12 months)
        one_year_ago = datetime.now(timezone.utc) - timedelta(days=365)
        new_hires = Employee.query.filter(
            Employee.date_of_employment >= one_year_ago.date()
        ).count()
        
        # Leave statistics
        leave_stats = db.session.query(
            Leave.type,
            func.count(Leave.id).label('count'),
            func.sum(func.julianday(Leave.end) - func.julianday(Leave.start) + 1).label('total_days')
        ).filter(
            Leave.status == 'Approved'
        ).group_by(
            Leave.type
        ).all() if hasattr(Leave, 'type') else []
        
        # Training completion - placeholder since TrainingRecord model doesn't exist
        training_stats = []
        
        # Attendance trends (last 30 days) - using Attendance model instead
        thirty_days_ago = datetime.now(timezone.utc) - timedelta(days=30)
        attendance_trend = []
        try:
            if hasattr(Attendance, 'date'):
                attendance_trend = db.session.query(
                    Attendance.date,
                    func.count(Attendance.id).label('total'),
                    func.sum(db.case((Attendance.status == 'Present', 1), else_=0)).label('present'),
                    func.sum(db.case((Attendance.status == 'Late', 1), else_=0)).label('late')
                ).filter(
                    Attendance.date >= thirty_days_ago.date()
                ).group_by(
                    Attendance.date
                ).order_by(
                    Attendance.date
                ).all()
        except Exception as e:
            current_app.logger.warning(f"Error loading attendance trends: {e}")
            attendance_trend = []
        
        return render_template('hr/manager/reports.html',
                             total_employees=total_employees,
                             dept_headcount=dept_headcount,
                             new_hires=new_hires,
                             leave_stats=leave_stats,
                             training_stats=training_stats,
                             attendance_trend=attendance_trend)


    # ===================================================================
    # FINANCE MANAGER - COMPREHENSIVE ENDPOINTS
    # ===================================================================
    
    @app.route('/finance/manager/dashboard', endpoint='finance_mgr.dashboard')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def finance_manager_dashboard():
        """Finance Manager dashboard with financial KPIs and metrics"""
        from sqlalchemy import func
        from datetime import datetime, timedelta
        
        # Current period
        today = datetime.now(timezone.utc).date()
        current_month_start = today.replace(day=1)
        current_year = today.year
        
        # Revenue metrics
        total_invoices = Invoice.query.filter_by(status='sent').count()
        total_revenue = db.session.query(func.sum(Invoice.total_amount)).filter(
            Invoice.status.in_(['sent', 'partially_paid', 'paid'])
        ).scalar() or 0
        
        collected_revenue = db.session.query(func.sum(Invoice.paid_amount)).filter(
            Invoice.status.in_(['partially_paid', 'paid'])
        ).scalar() or 0
        
        outstanding_receivables = db.session.query(func.sum(AccountsReceivable.balance)).filter(
            AccountsReceivable.status.in_(['outstanding', 'partially_paid'])
        ).scalar() or 0
        
        # Expense metrics
        total_payables = db.session.query(func.sum(AccountsPayable.balance)).filter(
            AccountsPayable.status.in_(['unpaid', 'partially_paid'])
        ).scalar() or 0
        
        overdue_payables = db.session.query(func.sum(AccountsPayable.balance)).filter(
            AccountsPayable.status == 'overdue'
        ).scalar() or 0
        
        # Budget metrics
        active_budgets = Budget.query.filter_by(status='active', fiscal_year=current_year).count()
        total_budget = db.session.query(func.sum(Budget.allocated_amount)).filter_by(
            status='active', fiscal_year=current_year
        ).scalar() or 0
        
        spent_budget = db.session.query(func.sum(Budget.spent_amount)).filter_by(
            status='active', fiscal_year=current_year
        ).scalar() or 0
        
        budget_utilization = (spent_budget / total_budget * 100) if total_budget > 0 else 0
        
        # Cash flow
        latest_forecast = CashFlowForecast.query.order_by(
            CashFlowForecast.forecast_date.desc()
        ).first()
        
        current_cash_balance = latest_forecast.closing_balance if latest_forecast else 0
        
        # Pending items
        pending_invoice_approvals = Invoice.query.filter_by(status='draft').count()
        pending_payment_approvals = Payment.query.filter_by(status='pending').count()
        overdue_invoices = Invoice.query.filter(
            Invoice.due_date < today,
            Invoice.payment_status != 'paid'
        ).count()
        
        # Recent transactions
        recent_payments = Payment.query.order_by(Payment.created_at.desc()).limit(5).all()
        recent_invoices = Invoice.query.order_by(Invoice.created_at.desc()).limit(5).all()
        
        # Monthly revenue trend (last 6 months)
        six_months_ago = today - timedelta(days=180)
        monthly_revenue = db.session.query(
            func.strftime('%Y-%m', Invoice.invoice_date).label('month'),
            func.sum(Invoice.total_amount).label('revenue')
        ).filter(
            Invoice.invoice_date >= six_months_ago,
            Invoice.status != 'cancelled'
        ).group_by('month').order_by('month').all()
        
        # Top customers by revenue
        top_customers = db.session.query(
            Invoice.customer_name,
            func.sum(Invoice.total_amount).label('total')
        ).filter(
            Invoice.status != 'cancelled'
        ).group_by(Invoice.customer_name).order_by(func.sum(Invoice.total_amount).desc()).limit(5).all()
        
        dashboard_data = {
            'kpis': {
                'total_revenue': float(total_revenue),
                'collected_revenue': float(collected_revenue),
                'outstanding_receivables': float(outstanding_receivables),
                'total_payables': float(total_payables),
                'overdue_payables': float(overdue_payables),
                'current_cash_balance': float(current_cash_balance),
                'active_budgets': active_budgets,
                'budget_utilization': budget_utilization,
                'pending_invoice_approvals': pending_invoice_approvals,
                'pending_payment_approvals': pending_payment_approvals,
                'overdue_invoices': overdue_invoices,
                'collection_rate': (collected_revenue / total_revenue * 100) if total_revenue > 0 else 0
            },
            'recent_payments': recent_payments,
            'recent_invoices': recent_invoices,
            'monthly_revenue': monthly_revenue,
            'top_customers': top_customers
        }
        
        return render_template('finance/manager/dashboard.html', **dashboard_data)
    
    
    @app.route('/finance/manager/budgets', methods=['GET', 'POST'], endpoint='finance_mgr.budgets')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def manage_budgets():
        """Budget management and tracking"""
        if request.method == 'POST':
            try:
                data = request.form
                print(f"DEBUG: Received form data: {dict(data)}")  # Debug log
                
                # Validate project_id is provided (required field)
                project_id = data.get('project_id')
                if not project_id:
                    flash('Project is required for budget creation', 'error')
                    return redirect(url_for('finance_mgr.budgets'))
                
                budget = Budget(
                    project_id=int(project_id),
                    category=data.get('budget_type'),  # Map budget_type to category
                    allocated_amount=float(data.get('total_budget', 0)),
                    fiscal_year=int(data.get('fiscal_year')),
                    status='active'
                )
                
                db.session.add(budget)
                db.session.commit()
                
                print(f"DEBUG: Budget created successfully with ID: {budget.id}")  # Debug log
                flash('Budget created successfully', 'success')
                return redirect(url_for('finance_mgr.budgets'))
                
            except Exception as e:
                db.session.rollback()
                print(f"DEBUG: Error creating budget: {str(e)}")  # Debug log
                import traceback
                traceback.print_exc()
                flash(f'Error creating budget: {str(e)}', 'error')
                return redirect(url_for('finance_mgr.budgets'))
        
        # GET request
        fiscal_year = request.args.get('fiscal_year', datetime.now(timezone.utc).year, type=int)
        status_filter = request.args.get('status')
        
        query = Budget.query.filter_by(fiscal_year=fiscal_year)
        if status_filter:
            query = query.filter_by(status=status_filter)
        
        budgets = query.order_by(Budget.created_at.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('finance/manager/budgets.html',
                             budgets=budgets,
                             projects=projects,
                             fiscal_year=fiscal_year)
    
    # Budget CRUD Operations
    @app.route('/finance/manager/budgets/<int:budget_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_budget')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_budget(budget_id):
        try:
            budget = Budget.query.get_or_404(budget_id)
            db.session.delete(budget)
            db.session.commit()
            flash('Budget deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting budget: {str(e)}', 'error')
        return redirect(url_for('finance_mgr.budgets'))
    
    @app.route('/finance/manager/invoices', methods=['GET', 'POST'], endpoint='finance_mgr.invoices')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def manage_invoices():
        """Invoice management and generation"""
        if request.method == 'POST':
            try:
                data = request.form
                
                # Calculate totals
                subtotal = float(data.get('subtotal', 0))
                tax_amount = float(data.get('tax_amount', 0))
                discount_amount = float(data.get('discount_amount', 0))
                total_amount = subtotal + tax_amount - discount_amount
                
                invoice = Invoice(
                    invoice_number=data.get('invoice_number'),
                    customer_name=data.get('customer_name'),
                    customer_email=data.get('customer_email'),
                    customer_address=data.get('customer_address'),
                    project_id=data.get('project_id') or None,
                    invoice_date=datetime.strptime(data.get('invoice_date'), '%Y-%m-%d').date(),
                    due_date=datetime.strptime(data.get('due_date'), '%Y-%m-%d').date(),
                    subtotal=subtotal,
                    tax_amount=tax_amount,
                    discount_amount=discount_amount,
                    total_amount=total_amount,
                    notes=data.get('notes'),
                    terms=data.get('terms'),
                    status='draft',
                    created_by=current_user.id
                )
                
                db.session.add(invoice)
                db.session.commit()
                
                flash('Invoice created successfully', 'success')
                return redirect(url_for('finance_mgr.invoices'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating invoice: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status', 'all')
        
        # Update overdue invoices before displaying
        from datetime import datetime, timezone
        overdue_invoices = Invoice.query.filter(
            Invoice.due_date < datetime.now(timezone.utc).date(),
            Invoice.status.in_(['sent', 'partially_paid'])
        ).all()
        for inv in overdue_invoices:
            inv.status = 'overdue'
        if overdue_invoices:
            db.session.commit()
        
        query = Invoice.query
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        invoices = query.order_by(Invoice.invoice_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('finance/manager/invoices.html',
                             invoices=invoices,
                             projects=projects)
    
    
    @app.route('/finance/manager/invoice/<int:invoice_id>', methods=['GET'], endpoint='finance_mgr.view_invoice')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def view_invoice(invoice_id):
        """View invoice details"""
        invoice = Invoice.query.get_or_404(invoice_id)
        return render_template('finance/manager/invoice_details.html', invoice=invoice)
    
    
    @app.route('/finance/manager/invoice/<int:invoice_id>/send', methods=['GET'], endpoint='finance_mgr.send_invoice')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def send_invoice(invoice_id):
        """Send invoice via email"""
        try:
            invoice = Invoice.query.get_or_404(invoice_id)
            
            if not invoice.customer_email:
                flash('Customer email is required to send invoice', 'error')
                return redirect(url_for('finance_mgr.invoices'))
            
            # Prepare email content
            subject = f'Invoice {invoice.invoice_number} from FitAccess'
            body = f"""
Dear {invoice.customer_name},

Please find below your invoice details:

Invoice Number: {invoice.invoice_number}
Invoice Date: {invoice.invoice_date.strftime('%B %d, %Y')}
Due Date: {invoice.due_date.strftime('%B %d, %Y')}

Subtotal: {invoice.subtotal:,.2f}
Tax: {invoice.tax_amount:,.2f}
Discount: {invoice.discount_amount:,.2f}
Total Amount: {invoice.total_amount:,.2f}

{f"Notes: {invoice.notes}" if invoice.notes else ""}
{f"Payment Terms: {invoice.terms}" if invoice.terms else ""}

Thank you for your business.

Best regards,
FitAccess Finance Team
            """
            
            # Send email
            send_email(invoice.customer_email, subject, body)
            
            # Update invoice status
            if invoice.status == 'draft':
                invoice.status = 'sent'
                db.session.commit()
            
            flash(f'Invoice sent successfully to {invoice.customer_email}', 'success')
        except Exception as e:
            flash(f'Error sending invoice: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.invoices'))
    
    
    @app.route('/finance/manager/invoice/<int:invoice_id>/download', methods=['GET'], endpoint='finance_mgr.download_invoice')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def download_invoice(invoice_id):
        """Download invoice as HTML (PDF generation can be added later)"""
        invoice = Invoice.query.get_or_404(invoice_id)
        
        # Render invoice template
        html_content = render_template('finance/manager/invoice_download.html', invoice=invoice)
        
        # For now, return HTML. TODO: Add PDF generation with reportlab or weasyprint
        from flask import make_response
        response = make_response(html_content)
        response.headers['Content-Type'] = 'text/html'
        response.headers['Content-Disposition'] = f'attachment; filename=invoice_{invoice.invoice_number}.html'
        
        return response
    
    
    @app.route('/finance/manager/invoice/<int:invoice_id>/payment', methods=['POST'], endpoint='finance_mgr.record_invoice_payment')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def record_invoice_payment(invoice_id):
        """Record a payment for an invoice"""
        try:
            invoice = Invoice.query.get_or_404(invoice_id)
            amount = float(request.form.get('payment_amount', 0))
            
            if amount <= 0:
                flash('Payment amount must be greater than zero', 'error')
                return redirect(url_for('finance_mgr.view_invoice', invoice_id=invoice_id))
            
            if amount > invoice.balance_due:
                flash(f'Payment amount cannot exceed balance due of {invoice.balance_due:,.2f}', 'error')
                return redirect(url_for('finance_mgr.view_invoice', invoice_id=invoice_id))
            
            # Record the payment
            invoice.record_payment(amount)
            db.session.commit()
            
            flash(f'Payment of {amount:,.2f} recorded successfully. Invoice status: {invoice.status}', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error recording payment: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.view_invoice', invoice_id=invoice_id))
    
    
    @app.route('/finance/manager/invoice/<int:invoice_id>/status', methods=['POST'], endpoint='finance_mgr.update_invoice_status')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def update_invoice_status_route(invoice_id):
        """Manually update invoice status"""
        try:
            invoice = Invoice.query.get_or_404(invoice_id)
            new_status = request.form.get('status')
            
            if new_status not in ['draft', 'sent', 'partially_paid', 'paid', 'cancelled', 'overdue']:
                flash('Invalid status', 'error')
                return redirect(url_for('finance_mgr.view_invoice', invoice_id=invoice_id))
            
            invoice.status = new_status
            db.session.commit()
            
            flash(f'Invoice status updated to {new_status}', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating status: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.view_invoice', invoice_id=invoice_id))
    
    
    @app.route('/finance/manager/invoices/<int:invoice_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_invoice')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_invoice(invoice_id):
        """Delete an invoice"""
        try:
            invoice = Invoice.query.get_or_404(invoice_id)
            db.session.delete(invoice)
            db.session.commit()
            flash('Invoice deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting invoice: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.invoices'))
    
    
    @app.route('/finance/manager/payments', methods=['GET', 'POST'], endpoint='finance_mgr.payments')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def manage_payments():
        """Payment recording and tracking"""
        if request.method == 'POST':
            try:
                data = request.form
                
                payment = Payment(
                    payment_number=data.get('payment_number'),
                    payment_type=data.get('payment_type'),
                    payment_method=data.get('payment_method'),
                    invoice_id=data.get('invoice_id') or None,
                    project_id=data.get('project_id') or None,
                    payment_date=datetime.strptime(data.get('payment_date'), '%Y-%m-%d').date(),
                    amount=float(data.get('amount')),
                    reference_number=data.get('reference_number'),
                    description=data.get('description'),
                    notes=data.get('notes'),
                    status='completed',
                    created_by=current_user.id
                )
                
                db.session.add(payment)
                
                # Update invoice if linked
                if payment.invoice_id:
                    invoice = Invoice.query.get(payment.invoice_id)
                    if invoice and payment.payment_type == 'receipt':
                        invoice.record_payment(payment.amount)
                
                db.session.commit()
                
                flash('Payment recorded successfully', 'success')
                return redirect(url_for('finance_mgr.payments'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error recording payment: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status')
        payment_type = request.args.get('type')
        
        query = Payment.query
        if status_filter:
            query = query.filter_by(status=status_filter)
        if payment_type:
            query = query.filter_by(payment_type=payment_type)
        
        payments = query.order_by(Payment.payment_date.desc()).all()
        unpaid_invoices = Invoice.query.filter(
            Invoice.status.in_(['sent', 'partially_paid', 'overdue'])
        ).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('finance/manager/payments.html',
                             payments=payments,
                             unpaid_invoices=unpaid_invoices,
                             projects=projects)
    
    
    @app.route('/finance/manager/payments/<int:payment_id>', methods=['GET'], endpoint='finance_mgr.view_payment')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def view_payment(payment_id):
        """View payment details"""
        payment = Payment.query.get_or_404(payment_id)
        return render_template('finance/manager/payment_details.html', payment=payment)
    
    
    @app.route('/finance/manager/payments/<int:payment_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_payment')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_payment(payment_id):
        """Delete a payment"""
        try:
            payment = Payment.query.get_or_404(payment_id)
            
            # Update invoice if linked (reverse the payment)
            if payment.invoice_id and payment.payment_type == 'receipt':
                invoice = Invoice.query.get(payment.invoice_id)
                if invoice:
                    invoice.paid_amount = max(0, (invoice.paid_amount or 0) - payment.amount)
                    invoice.update_status()
            
            db.session.delete(payment)
            db.session.commit()
            flash('Payment deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting payment: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.payments'))
    
    
    @app.route('/finance/manager/receivables', methods=['GET', 'POST'], endpoint='finance_mgr.receivables')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def accounts_receivable():
        """Accounts receivable tracking and aging - automatically synced from invoices"""
        from sqlalchemy import func
        from datetime import datetime, timezone
        
        # Sync receivables from unpaid invoices
        unpaid_invoices = Invoice.query.filter(
            Invoice.status.in_(['sent', 'partially_paid', 'overdue'])
        ).all()
        
        for invoice in unpaid_invoices:
            # Check if receivable already exists for this invoice
            existing = AccountsReceivable.query.filter_by(invoice_id=invoice.id).first()
            
            if existing:
                # Update existing receivable
                existing.customer_name = invoice.customer_name
                existing.invoice_number = invoice.invoice_number
                existing.balance = invoice.balance_due
                existing.due_date = invoice.due_date
                existing.calculate_aging()
                
                # Update status
                if existing.balance <= 0:
                    existing.status = 'paid'
                elif invoice.paid_amount > 0:
                    existing.status = 'partially_paid'
                else:
                    existing.status = 'outstanding'
            else:
                # Create new receivable
                receivable = AccountsReceivable(
                    invoice_id=invoice.id,
                    project_id=invoice.project_id,
                    customer_name=invoice.customer_name,
                    invoice_number=invoice.invoice_number,
                    balance=invoice.balance_due,
                    due_date=invoice.due_date,
                    status='outstanding' if invoice.paid_amount == 0 else 'partially_paid'
                )
                receivable.calculate_aging()
                db.session.add(receivable)
        
        # Remove receivables for paid invoices
        paid_invoices = Invoice.query.filter_by(status='paid').all()
        for invoice in paid_invoices:
            receivable = AccountsReceivable.query.filter_by(invoice_id=invoice.id).first()
            if receivable:
                receivable.status = 'paid'
        
        db.session.commit()
        
        # Aging buckets summary
        aging_summary = db.session.query(
            AccountsReceivable.aging_bucket,
            func.count(AccountsReceivable.id).label('count'),
            func.sum(AccountsReceivable.balance).label('total')
        ).filter(
            AccountsReceivable.status.in_(['outstanding', 'partially_paid'])
        ).group_by(AccountsReceivable.aging_bucket).all()
        
        # Format aging summary with proper order
        aging_order = ['current', '1-30', '31-60', '61-90', '90+']
        aging_dict = {item.aging_bucket: item for item in aging_summary}
        formatted_aging = []
        for bucket in aging_order:
            if bucket in aging_dict:
                formatted_aging.append(aging_dict[bucket])
            else:
                # Create empty bucket
                from collections import namedtuple
                EmptyBucket = namedtuple('AgingBucket', ['aging_bucket', 'count', 'total'])
                formatted_aging.append(EmptyBucket(bucket, 0, 0))
        
        # Outstanding receivables
        receivables = AccountsReceivable.query.filter(
            AccountsReceivable.status.in_(['outstanding', 'partially_paid'])
        ).order_by(AccountsReceivable.days_outstanding.desc()).all()
        
        # Top customers by outstanding
        top_debtors = db.session.query(
            AccountsReceivable.customer_name,
            func.sum(AccountsReceivable.balance).label('total_outstanding')
        ).filter(
            AccountsReceivable.status.in_(['outstanding', 'partially_paid'])
        ).group_by(AccountsReceivable.customer_name).order_by(
            func.sum(AccountsReceivable.balance).desc()
        ).limit(10).all()
        
        return render_template('finance/manager/receivables.html',
                             receivables=receivables,
                             aging_summary=formatted_aging,
                             top_debtors=top_debtors)
    
    
    @app.route('/finance/manager/receivables/<int:receivable_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_receivable')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_receivable(receivable_id):
        """Delete an accounts receivable record (not recommended - should sync from invoice)"""
        try:
            receivable = AccountsReceivable.query.get_or_404(receivable_id)
            db.session.delete(receivable)
            db.session.commit()
            flash('Receivable deleted successfully. It will be recreated on next sync if invoice is still unpaid.', 'warning')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting receivable: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.receivables'))
    
    
    @app.route('/finance/manager/payables', methods=['GET', 'POST'], endpoint='finance_mgr.payables')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def accounts_payable():
        """Accounts payable tracking and scheduling"""
        if request.method == 'POST':
            try:
                data = request.form
                
                payable = AccountsPayable(
                    vendor_name=data.get('vendor_name'),
                    vendor_email=data.get('vendor_email'),
                    bill_number=data.get('bill_number'),
                    bill_date=datetime.strptime(data.get('bill_date'), '%Y-%m-%d').date(),
                    due_date=datetime.strptime(data.get('due_date'), '%Y-%m-%d').date(),
                    amount_due=float(data.get('amount_due')),
                    balance=float(data.get('amount_due')),
                    payment_terms=data.get('payment_terms'),
                    description=data.get('description'),
                    category=data.get('category'),
                    project_id=data.get('project_id') or None,
                    created_by=current_user.id
                )
                
                db.session.add(payable)
                db.session.commit()
                
                flash('Payable added successfully', 'success')
                return redirect(url_for('finance_mgr.payables'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding payable: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status', 'unpaid')
        
        query = AccountsPayable.query
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        payables = query.order_by(AccountsPayable.due_date).all()
        
        # Update overdue status
        today = datetime.now(timezone.utc).date()
        for ap in payables:
            if ap.due_date < today and ap.status != 'paid':
                ap.status = 'overdue'
        db.session.commit()
        
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('finance/manager/payables.html',
                             payables=payables,
                             projects=projects)
    
    
    @app.route('/finance/manager/payables/<int:payable_id>', methods=['GET'], endpoint='finance_mgr.view_payable')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def view_payable(payable_id):
        """View payable details"""
        payable = AccountsPayable.query.get_or_404(payable_id)
        return render_template('finance/manager/payable_details.html', payable=payable)
    
    
    @app.route('/finance/manager/payables/<int:payable_id>/payment', methods=['POST'], endpoint='finance_mgr.record_payable_payment')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def record_payable_payment(payable_id):
        """Record a payment for a payable"""
        try:
            payable = AccountsPayable.query.get_or_404(payable_id)
            amount = float(request.form.get('payment_amount', 0))
            
            if amount <= 0:
                flash('Payment amount must be greater than zero', 'error')
                return redirect(url_for('finance_mgr.payables'))
            
            if amount > payable.balance:
                flash(f'Payment amount cannot exceed balance of {payable.balance:,.2f}', 'error')
                return redirect(url_for('finance_mgr.payables'))
            
            # Update payable
            payable.paid_amount = (payable.paid_amount or 0) + amount
            payable.balance = payable.amount_due - payable.paid_amount
            
            # Update status
            if payable.balance <= 0:
                payable.status = 'paid'
            elif payable.paid_amount > 0:
                payable.status = 'partially_paid'
            
            db.session.commit()
            
            flash(f'Payment of {amount:,.2f} recorded successfully. Payable status: {payable.status}', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error recording payment: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.payables'))
    
    
    @app.route('/finance/manager/payables/<int:payable_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_payable')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_payable(payable_id):
        """Delete an accounts payable record"""
        try:
            payable = AccountsPayable.query.get_or_404(payable_id)
            db.session.delete(payable)
            db.session.commit()
            flash('Payable deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting payable: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.payables'))
    
    
    @app.route('/finance/manager/cashflow', methods=['GET', 'POST'], endpoint='finance_mgr.cashflow')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def cash_flow_forecast():
        """Cash flow forecasting and projection"""
        if request.method == 'POST':
            try:
                data = request.form
                
                # Parse dates
                forecast_date = datetime.strptime(data.get('forecast_date'), '%Y-%m-%d').date()
                period_type = data.get('period_type', 'monthly')
                
                # Calculate period_start and period_end based on forecast_date and period_type
                from dateutil.relativedelta import relativedelta
                period_start = forecast_date
                if period_type == 'weekly':
                    period_end = period_start + relativedelta(weeks=1)
                    forecast_period = f"Week of {period_start.strftime('%b %d, %Y')}"
                elif period_type == 'quarterly':
                    period_end = period_start + relativedelta(months=3)
                    forecast_period = f"Q{(period_start.month-1)//3 + 1} {period_start.year}"
                elif period_type == 'annual':
                    period_end = period_start + relativedelta(years=1)
                    forecast_period = f"FY {period_start.year}"
                else:  # monthly
                    period_end = period_start + relativedelta(months=1)
                    forecast_period = f"{period_start.strftime('%B %Y')}"
                
                forecast = CashFlowForecast(
                    project_id=int(data.get('project_id')) if data.get('project_id') else None,
                    forecast_period=forecast_period,
                    period_start=period_start,
                    period_end=period_end,
                    forecast_date=forecast_date,
                    opening_balance=float(data.get('opening_balance', 0)),
                    expected_inflow=float(data.get('expected_collections', 0)) + float(data.get('expected_sales', 0)) + float(data.get('other_income', 0)),
                    expected_outflow=float(data.get('expected_payments', 0)) + float(data.get('payroll_amount', 0)) + float(data.get('operational_expenses', 0)),
                    labor_cost=float(data.get('payroll_amount', 0)),
                    material_cost=float(data.get('operational_expenses', 0)),
                    equipment_cost=float(data.get('capital_expenditure', 0)),
                    overhead_cost=float(data.get('other_expenses', 0)),
                    notes=data.get('notes'),
                    status='draft',
                    created_by=current_user.id
                )
                
                db.session.add(forecast)
                db.session.commit()
                
                flash('Cash flow forecast created successfully', 'success')
                return redirect(url_for('finance_mgr.cashflow'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating forecast: {str(e)}', 'error')
        
        # GET request
        forecasts = CashFlowForecast.query.order_by(CashFlowForecast.forecast_date.desc()).limit(12).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('finance/manager/cashflow.html',
                             forecasts=forecasts,
                             projects=projects)
    
    
    @app.route('/finance/manager/cashflow/<int:forecast_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_cashflow')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_cashflow(forecast_id):
        """Delete a cash flow forecast"""
        try:
            forecast = CashFlowForecast.query.get_or_404(forecast_id)
            db.session.delete(forecast)
            db.session.commit()
            flash('Cash flow forecast deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting forecast: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.cashflow'))
    
    
    @app.route('/finance/manager/reports', endpoint='finance_mgr.reports')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def financial_reports():
        """Comprehensive financial reports and statements"""
        from sqlalchemy import func
        from datetime import datetime, timedelta
        
        today = datetime.now(timezone.utc).date()
        current_year = today.year
        year_start = datetime(current_year, 1, 1).date()
        
        # Income Statement (P&L)
        total_revenue = db.session.query(func.sum(Invoice.total_amount)).filter(
            Invoice.invoice_date >= year_start,
            Invoice.status != 'cancelled'
        ).scalar() or 0
        
        total_expenses = db.session.query(func.sum(Expense.amount)).filter(
            Expense.date >= year_start
        ).scalar() or 0
        
        gross_profit = total_revenue - total_expenses
        net_profit_margin = (gross_profit / total_revenue * 100) if total_revenue > 0 else 0
        
        # Balance Sheet items
        total_assets = db.session.query(func.sum(Asset.purchase_cost)).scalar() or 0
        total_receivables = db.session.query(func.sum(AccountsReceivable.balance)).filter(
            AccountsReceivable.status != 'paid'
        ).scalar() or 0
        total_payables = db.session.query(func.sum(AccountsPayable.balance)).filter(
            AccountsPayable.status != 'paid'
        ).scalar() or 0
        
        # Cash flow summary
        cash_inflows = db.session.query(func.sum(Payment.amount)).filter(
            Payment.payment_type == 'receipt',
            Payment.payment_date >= year_start
        ).scalar() or 0
        
        cash_outflows = db.session.query(func.sum(Payment.amount)).filter(
            Payment.payment_type == 'disbursement',
            Payment.payment_date >= year_start
        ).scalar() or 0
        
        net_cash_flow = cash_inflows - cash_outflows
        
        # Revenue by month
        monthly_revenue = db.session.query(
            func.strftime('%m', Invoice.invoice_date).label('month'),
            func.sum(Invoice.total_amount).label('revenue')
        ).filter(
            Invoice.invoice_date >= year_start,
            Invoice.status != 'cancelled'
        ).group_by('month').order_by('month').all()
        
        # Expenses by category
        expenses_by_category = db.session.query(
            Expense.category,
            func.sum(Expense.amount).label('total')
        ).filter(
            Expense.date >= year_start
        ).group_by(Expense.category).all()
        
        # Financial ratios
        current_ratio = (total_receivables / total_payables) if total_payables > 0 else 0
        
        report_data = {
            'income_statement': {
                'total_revenue': float(total_revenue),
                'total_expenses': float(total_expenses),
                'gross_profit': float(gross_profit),
                'net_profit_margin': net_profit_margin
            },
            'balance_sheet': {
                'total_assets': float(total_assets),
                'total_receivables': float(total_receivables),
                'total_payables': float(total_payables),
                'net_working_capital': float(total_receivables - total_payables)
            },
            'cash_flow': {
                'cash_inflows': float(cash_inflows),
                'cash_outflows': float(cash_outflows),
                'net_cash_flow': float(net_cash_flow)
            },
            'ratios': {
                'current_ratio': current_ratio,
                'profit_margin': net_profit_margin
            },
            'monthly_revenue': monthly_revenue,
            'expenses_by_category': expenses_by_category,
            'fiscal_year': current_year
        }
        
        return render_template('finance/manager/reports.html', **report_data)
    
    
    @app.route('/finance/manager/transactions', methods=['GET', 'POST'], endpoint='finance_mgr.transactions')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def financial_transactions():
        """General ledger and transaction management"""
        if request.method == 'POST':
            try:
                data = request.form
                
                transaction = FinancialTransaction(
                    transaction_number=data.get('transaction_number'),
                    transaction_type=data.get('transaction_type'),
                    transaction_date=datetime.strptime(data.get('transaction_date'), '%Y-%m-%d').date(),
                    account_code=data.get('account_code'),
                    account_name=data.get('account_name'),
                    debit_amount=float(data.get('debit_amount', 0)),
                    credit_amount=float(data.get('credit_amount', 0)),
                    category=data.get('category'),
                    description=data.get('description'),
                    created_by=current_user.id
                )
                
                db.session.add(transaction)
                db.session.commit()
                
                flash('Transaction recorded successfully', 'success')
                return redirect(url_for('finance_mgr.transactions'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error recording transaction: {str(e)}', 'error')
        
        # GET request
        transaction_type = request.args.get('type')
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        
        query = FinancialTransaction.query
        if transaction_type:
            query = query.filter_by(transaction_type=transaction_type)
        if start_date:
            query = query.filter(FinancialTransaction.transaction_date >= datetime.strptime(start_date, '%Y-%m-%d').date())
        if end_date:
            query = query.filter(FinancialTransaction.transaction_date <= datetime.strptime(end_date, '%Y-%m-%d').date())
        
        transactions = query.order_by(FinancialTransaction.transaction_date.desc()).all()
        
        return render_template('finance/manager/transactions.html',
                             transactions=transactions)


    @app.route('/finance/manager/transactions/<int:transaction_id>', methods=['GET'], endpoint='finance_mgr.view_transaction')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def view_transaction(transaction_id):
        """View transaction details"""
        transaction = FinancialTransaction.query.get_or_404(transaction_id)
        return render_template('finance/manager/transaction_details.html', transaction=transaction)
    
    
    @app.route('/finance/manager/transactions/<int:transaction_id>/delete', methods=['POST'], endpoint='finance_mgr.delete_transaction')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def delete_transaction(transaction_id):
        """Delete a financial transaction"""
        try:
            transaction = FinancialTransaction.query.get_or_404(transaction_id)
            db.session.delete(transaction)
            db.session.commit()
            flash('Transaction deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting transaction: {str(e)}', 'error')
        
        return redirect(url_for('finance_mgr.transactions'))


    # ===================================================================
    # SITE PROJECT MANAGER - COMPREHENSIVE ENDPOINTS
    # ===================================================================
    
    @app.route('/site/manager/dashboard', endpoint='site_mgr.dashboard')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def site_manager_dashboard():
        """Site Project Manager dashboard with key metrics"""
        from sqlalchemy import func
        from datetime import datetime, timedelta
        
        # Get user's assigned projects
        user_projects = Project.query.filter(
            (Project.project_manager == current_user.name) | 
            (Project.status == 'Active')
        ).all()
        
        project_ids = [p.id for p in user_projects]
        
        today = datetime.now(timezone.utc).date()
        week_ago = today - timedelta(days=7)
        
        # Daily Progress Reports metrics
        total_dprs = DailyProgressReport.query.filter(
            DailyProgressReport.project_id.in_(project_ids) if project_ids else False
        ).count()
        
        pending_dprs = DailyProgressReport.query.filter(
            DailyProgressReport.project_id.in_(project_ids) if project_ids else False,
            DailyProgressReport.status == 'draft'
        ).count()
        
        recent_dprs = DailyProgressReport.query.filter(
            DailyProgressReport.project_id.in_(project_ids) if project_ids else False
        ).order_by(DailyProgressReport.report_date.desc()).limit(5).all()
        
        # Safety metrics
        total_incidents = SafetyIncident.query.filter(
            SafetyIncident.project_id.in_(project_ids) if project_ids else False
        ).count()
        
        open_incidents = SafetyIncident.query.filter(
            SafetyIncident.project_id.in_(project_ids) if project_ids else False,
            SafetyIncident.status.in_(['open', 'under_investigation'])
        ).count()
        
        recent_incidents = SafetyIncident.query.filter(
            SafetyIncident.project_id.in_(project_ids) if project_ids else False
        ).order_by(SafetyIncident.incident_date.desc()).limit(5).all()
        
        # Material requests
        pending_material_requests = MaterialRequest.query.filter(
            MaterialRequest.project_id.in_(project_ids) if project_ids else False,
            MaterialRequest.status == 'pending'
        ).count()
        
        # Inspections
        pending_inspections = SiteInspection.query.filter(
            SiteInspection.project_id.in_(project_ids) if project_ids else False,
            SiteInspection.status.in_(['scheduled', 'follow_up'])
        ).count()
        
        # Work orders
        active_work_orders = WorkOrder.query.filter(
            WorkOrder.project_id.in_(project_ids) if project_ids else False,
            WorkOrder.status.in_(['assigned', 'in_progress'])
        ).count()
        
        # Quality control tests
        pending_qc_tests = QualityControl.query.filter(
            QualityControl.project_id.in_(project_ids) if project_ids else False,
            QualityControl.status == 'pending'
        ).count()
        
        # Change orders
        pending_change_orders = ChangeOrder.query.filter(
            ChangeOrder.project_id.in_(project_ids) if project_ids else False,
            ChangeOrder.status.in_(['pending', 'under_review'])
        ).count()
        
        # Project progress (from latest DPRs)
        project_progress = []
        for project in user_projects[:5]:  # Top 5 projects
            latest_dpr = DailyProgressReport.query.filter_by(
                project_id=project.id
            ).order_by(DailyProgressReport.report_date.desc()).first()
            
            project_progress.append({
                'project_name': project.project_name,
                'progress': float(latest_dpr.overall_progress) if latest_dpr else 0,
                'last_updated': latest_dpr.report_date if latest_dpr else None
            })
        
        dashboard_data = {
            'projects': user_projects,
            'kpis': {
                'total_dprs': total_dprs,
                'pending_dprs': pending_dprs,
                'total_incidents': total_incidents,
                'open_incidents': open_incidents,
                'pending_material_requests': pending_material_requests,
                'pending_inspections': pending_inspections,
                'active_work_orders': active_work_orders,
                'pending_qc_tests': pending_qc_tests,
                'pending_change_orders': pending_change_orders
            },
            'recent_dprs': recent_dprs,
            'recent_incidents': recent_incidents,
            'project_progress': project_progress
        }
        
        return render_template('site/manager/dashboard.html', **dashboard_data)
    
    
    @app.route('/site/manager/progress-reports', methods=['GET', 'POST'], endpoint='site_mgr.progress_reports')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def daily_progress_reports():
        """Daily Progress Report management"""
        if request.method == 'POST':
            try:
                data = request.form
                
                dpr = DailyProgressReport(
                    project_id=int(data.get('project_id')),
                    report_date=datetime.strptime(data.get('report_date'), '%Y-%m-%d').date(),
                    shift=data.get('shift', 'day'),
                    weather_condition=data.get('weather_condition'),
                    temperature=data.get('temperature'),
                    weather_impact=data.get('weather_impact'),
                    total_workers=int(data.get('total_workers', 0)),
                    skilled_workers=int(data.get('skilled_workers', 0)),
                    unskilled_workers=int(data.get('unskilled_workers', 0)),
                    supervisors=int(data.get('supervisors', 0)),
                    contractors=int(data.get('contractors', 0)),
                    work_completed=data.get('work_completed'),
                    work_in_progress=data.get('work_in_progress'),
                    planned_for_tomorrow=data.get('planned_for_tomorrow'),
                    overall_progress=float(data.get('overall_progress', 0)),
                    today_progress=float(data.get('today_progress', 0)),
                    safety_incidents=data.get('safety_incidents'),
                    delays_encountered=data.get('delays_encountered'),
                    quality_issues=data.get('quality_issues'),
                    challenges=data.get('challenges'),
                    site_visitors=data.get('site_visitors'),
                    meetings_held=data.get('meetings_held'),
                    created_by=current_user.id
                )
                
                db.session.add(dpr)
                db.session.commit()
                
                flash('Daily Progress Report created successfully', 'success')
                return redirect(url_for('site_mgr.progress_reports'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating DPR: {str(e)}', 'error')
        
        # GET request
        project_filter = request.args.get('project_id', type=int)
        status_filter = request.args.get('status')
        
        query = DailyProgressReport.query
        if project_filter:
            query = query.filter_by(project_id=project_filter)
        if status_filter:
            query = query.filter_by(status=status_filter)
        
        dprs = query.order_by(DailyProgressReport.report_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('site/manager/progress_reports.html',
                             dprs=dprs,
                             projects=projects)
    
    
    @app.route('/site/manager/inspections', methods=['GET', 'POST'], endpoint='site_mgr.inspections')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def site_inspections():
        """Site inspection management"""
        if request.method == 'POST':
            try:
                data = request.form
                
                inspection = SiteInspection(
                    project_id=int(data.get('project_id')),
                    inspection_number=data.get('inspection_number'),
                    inspection_type=data.get('inspection_type'),
                    inspection_date=datetime.strptime(data.get('inspection_date'), '%Y-%m-%d').date(),
                    area_inspected=data.get('area_inspected'),
                    work_stage=data.get('work_stage'),
                    specification_reference=data.get('specification_reference'),
                    inspector_name=data.get('inspector_name'),
                    inspector_organization=data.get('inspector_organization'),
                    inspector_designation=data.get('inspector_designation'),
                    observations=data.get('observations'),
                    non_conformances=data.get('non_conformances'),
                    recommendations=data.get('recommendations'),
                    corrective_actions=data.get('corrective_actions'),
                    overall_rating=data.get('overall_rating'),
                    defects_found=int(data.get('defects_found', 0)),
                    follow_up_required=data.get('follow_up_required') == 'on',
                    created_by=current_user.id
                )
                
                db.session.add(inspection)
                db.session.commit()
                
                flash('Site inspection created successfully', 'success')
                return redirect(url_for('site_mgr.inspections'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating inspection: {str(e)}', 'error')
        
        # GET request
        project_filter = request.args.get('project_id', type=int)
        type_filter = request.args.get('type')
        
        query = SiteInspection.query
        if project_filter:
            query = query.filter_by(project_id=project_filter)
        if type_filter:
            query = query.filter_by(inspection_type=type_filter)
        
        inspections = query.order_by(SiteInspection.inspection_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('site/manager/inspections.html',
                             inspections=inspections,
                             projects=projects)
    
    
    @app.route('/site/manager/material-requests', methods=['GET', 'POST'], endpoint='site_mgr.material_requests')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def material_requests():
        """Material requisition management"""
        if request.method == 'POST':
            try:
                data = request.form
                import json
                
                material_request = MaterialRequest(
                    request_number=data.get('request_number'),
                    project_id=int(data.get('project_id')),
                    request_type=data.get('request_type', 'site'),
                    request_date=datetime.strptime(data.get('request_date'), '%Y-%m-%d').date(),
                    required_date=datetime.strptime(data.get('required_date'), '%Y-%m-%d').date(),
                    priority=data.get('priority', 'normal'),
                    purpose=data.get('purpose'),
                    work_location=data.get('work_location'),
                    items=json.loads(data.get('items_json', '[]')),
                    justification=data.get('justification'),
                    estimated_cost=float(data.get('estimated_cost', 0)) if data.get('estimated_cost') else None,
                    budget_code=data.get('budget_code'),
                    requested_by=current_user.id
                )
                
                db.session.add(material_request)
                db.session.commit()
                
                flash('Material request created successfully', 'success')
                return redirect(url_for('site_mgr.material_requests'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating material request: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status', 'pending')
        
        query = MaterialRequest.query
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        requests = query.order_by(MaterialRequest.request_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('site/manager/material_requests.html',
                             requests=requests,
                             projects=projects)
    
    
    @app.route('/site/manager/equipment', methods=['GET', 'POST'], endpoint='site_mgr.equipment')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def equipment_logs():
        """Equipment usage and maintenance logging"""
        if request.method == 'POST':
            try:
                data = request.form
                
                equipment_log = EquipmentLog(
                    equipment_id=int(data.get('equipment_id')),
                    project_id=int(data.get('project_id')),
                    log_date=datetime.strptime(data.get('log_date'), '%Y-%m-%d').date(),
                    operator_name=data.get('operator_name'),
                    operator_id=int(data.get('operator_id')) if data.get('operator_id') else None,
                    location=data.get('location'),
                    task_description=data.get('task_description'),
                    hours_used=float(data.get('hours_used', 0)),
                    start_reading=float(data.get('start_reading', 0)) if data.get('start_reading') else None,
                    end_reading=float(data.get('end_reading', 0)) if data.get('end_reading') else None,
                    fuel_consumed=float(data.get('fuel_consumed', 0)) if data.get('fuel_consumed') else None,
                    condition_before=data.get('condition_before'),
                    condition_after=data.get('condition_after'),
                    issues_reported=data.get('issues_reported'),
                    damages=data.get('damages'),
                    maintenance_required=data.get('maintenance_required') == 'on',
                    maintenance_type=data.get('maintenance_type'),
                    maintenance_description=data.get('maintenance_description'),
                    safety_check_completed=data.get('safety_check_completed') == 'on',
                    safety_issues=data.get('safety_issues'),
                    logged_by=current_user.id
                )
                
                db.session.add(equipment_log)
                db.session.commit()
                
                flash('Equipment log created successfully', 'success')
                return redirect(url_for('site_mgr.equipment'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating equipment log: {str(e)}', 'error')
        
        # GET request
        logs = EquipmentLog.query.order_by(EquipmentLog.log_date.desc()).all()
        equipment = Asset.query.filter_by(asset_category='Equipment').all()
        projects = Project.query.filter_by(status='Active').all()
        employees = Employee.query.all()
        
        return render_template('site/manager/equipment.html',
                             logs=logs,
                             equipment=equipment,
                             projects=projects,
                             employees=employees)
    
    
    @app.route('/site/manager/safety', methods=['GET', 'POST'], endpoint='site_mgr.safety')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def safety_incidents():
        """Safety incident reporting and tracking"""
        if request.method == 'POST':
            try:
                data = request.form
                
                incident = SafetyIncident(
                    incident_number=data.get('incident_number'),
                    project_id=int(data.get('project_id')),
                    incident_date=datetime.strptime(data.get('incident_date'), '%Y-%m-%d').date(),
                    incident_time=datetime.strptime(data.get('incident_time'), '%H:%M').time() if data.get('incident_time') else None,
                    location=data.get('location'),
                    incident_type=data.get('incident_type'),
                    severity=data.get('severity'),
                    category=data.get('category'),
                    injured_person_name=data.get('injured_person_name'),
                    injured_person_type=data.get('injured_person_type'),
                    injured_person_id=int(data.get('injured_person_id')) if data.get('injured_person_id') else None,
                    number_of_injured=int(data.get('number_of_injured', 1)),
                    description=data.get('description'),
                    immediate_cause=data.get('immediate_cause'),
                    root_cause=data.get('root_cause'),
                    contributing_factors=data.get('contributing_factors'),
                    injury_type=data.get('injury_type'),
                    body_part=data.get('body_part'),
                    first_aid_given=data.get('first_aid_given') == 'on',
                    medical_treatment=data.get('medical_treatment'),
                    hospital_name=data.get('hospital_name'),
                    days_lost=int(data.get('days_lost', 0)),
                    immediate_actions_taken=data.get('immediate_actions_taken'),
                    site_evacuated=data.get('site_evacuated') == 'on',
                    work_stopped=data.get('work_stopped') == 'on',
                    emergency_services_called=data.get('emergency_services_called') == 'on',
                    witnesses=data.get('witnesses'),
                    corrective_actions=data.get('corrective_actions'),
                    preventive_measures=data.get('preventive_measures'),
                    reportable_to_authority=data.get('reportable_to_authority') == 'on',
                    reported_by=current_user.id
                )
                
                db.session.add(incident)
                db.session.commit()
                
                flash('Safety incident reported successfully', 'success')
                return redirect(url_for('site_mgr.safety'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error reporting incident: {str(e)}', 'error')
        
        # GET request
        severity_filter = request.args.get('severity')
        status_filter = request.args.get('status', 'open')
        
        query = SafetyIncident.query
        if severity_filter:
            query = query.filter_by(severity=severity_filter)
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        incidents = query.order_by(SafetyIncident.incident_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        employees = Employee.query.all()
        
        return render_template('site/manager/safety.html',
                             incidents=incidents,
                             projects=projects,
                             employees=employees)
    
    
    @app.route('/site/manager/quality-control', methods=['GET', 'POST'], endpoint='site_mgr.quality_control')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def quality_control():
        """Quality control testing and inspections"""
        if request.method == 'POST':
            try:
                data = request.form
                import json
                
                qc = QualityControl(
                    test_number=data.get('test_number'),
                    project_id=int(data.get('project_id')),
                    test_type=data.get('test_type'),
                    test_name=data.get('test_name'),
                    test_standard=data.get('test_standard'),
                    test_date=datetime.strptime(data.get('test_date'), '%Y-%m-%d').date(),
                    sample_id=data.get('sample_id'),
                    sample_location=data.get('sample_location'),
                    sample_date=datetime.strptime(data.get('sample_date'), '%Y-%m-%d').date() if data.get('sample_date') else None,
                    sample_description=data.get('sample_description'),
                    sample_size=data.get('sample_size'),
                    parameters_tested=json.loads(data.get('parameters_json', '[]')) if data.get('parameters_json') else None,
                    tested_by=data.get('tested_by'),
                    lab_name=data.get('lab_name'),
                    lab_certificate_number=data.get('lab_certificate_number'),
                    pass_fail_status=data.get('pass_fail_status'),
                    remarks=data.get('remarks'),
                    required_value=data.get('required_value'),
                    actual_value=data.get('actual_value'),
                    tolerance=data.get('tolerance'),
                    compliance_status=data.get('compliance_status'),
                    non_conformance=data.get('non_conformance'),
                    corrective_action=data.get('corrective_action'),
                    retest_required=data.get('retest_required') == 'on',
                    created_by=current_user.id
                )
                
                db.session.add(qc)
                db.session.commit()
                
                flash('Quality control test created successfully', 'success')
                return redirect(url_for('site_mgr.quality_control'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating QC test: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status')
        
        query = QualityControl.query
        if status_filter:
            query = query.filter_by(pass_fail_status=status_filter)
        
        tests = query.order_by(QualityControl.test_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('site/manager/quality_control.html',
                             tests=tests,
                             projects=projects)
    
    
    @app.route('/site/manager/attendance', methods=['GET', 'POST'], endpoint='site_mgr.attendance')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def site_attendance():
        """Site worker attendance tracking"""
        if request.method == 'POST':
            try:
                data = request.form
                
                attendance = SiteAttendance(
                    project_id=int(data.get('project_id')),
                    attendance_date=datetime.strptime(data.get('attendance_date'), '%Y-%m-%d').date(),
                    shift=data.get('shift', 'day'),
                    worker_name=data.get('worker_name'),
                    employee_id=int(data.get('employee_id')) if data.get('employee_id') else None,
                    worker_type=data.get('worker_type'),
                    trade=data.get('trade'),
                    check_in_time=datetime.strptime(data.get('check_in_time'), '%H:%M').time() if data.get('check_in_time') else None,
                    check_out_time=datetime.strptime(data.get('check_out_time'), '%H:%M').time() if data.get('check_out_time') else None,
                    hours_worked=float(data.get('hours_worked', 0)),
                    overtime_hours=float(data.get('overtime_hours', 0)),
                    status=data.get('status', 'present'),
                    absence_reason=data.get('absence_reason'),
                    work_area=data.get('work_area'),
                    task_assigned=data.get('task_assigned'),
                    productivity_rating=int(data.get('productivity_rating')) if data.get('productivity_rating') else None,
                    ppe_issued=data.get('ppe_issued') == 'on',
                    safety_briefing=data.get('safety_briefing') == 'on',
                    safety_violation=data.get('safety_violation'),
                    daily_rate=float(data.get('daily_rate', 0)) if data.get('daily_rate') else None,
                    allowances=float(data.get('allowances', 0)) if data.get('allowances') else None,
                    deductions=float(data.get('deductions', 0)) if data.get('deductions') else None,
                    remarks=data.get('remarks'),
                    recorded_by=current_user.id
                )
                
                attendance.calculate_payment()
                
                db.session.add(attendance)
                db.session.commit()
                
                flash('Attendance recorded successfully', 'success')
                return redirect(url_for('site_mgr.attendance'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error recording attendance: {str(e)}', 'error')
        
        # GET request
        project_filter = request.args.get('project_id', type=int)
        date_filter = request.args.get('date')
        
        query = SiteAttendance.query
        if project_filter:
            query = query.filter_by(project_id=project_filter)
        if date_filter:
            query = query.filter_by(attendance_date=datetime.strptime(date_filter, '%Y-%m-%d').date())
        
        attendance_records = query.order_by(SiteAttendance.attendance_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        employees = Employee.query.all()
        
        return render_template('site/manager/attendance.html',
                             attendance_records=attendance_records,
                             projects=projects,
                             employees=employees)
    
    
    @app.route('/site/manager/work-orders', methods=['GET', 'POST'], endpoint='site_mgr.work_orders')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def work_orders():
        """Work order management"""
        if request.method == 'POST':
            try:
                data = request.form
                import json
                
                work_order = WorkOrder(
                    work_order_number=data.get('work_order_number'),
                    project_id=int(data.get('project_id')),
                    title=data.get('title'),
                    description=data.get('description'),
                    work_type=data.get('work_type'),
                    category=data.get('category'),
                    location=data.get('location'),
                    building_block=data.get('building_block'),
                    floor_level=data.get('floor_level'),
                    start_date=datetime.strptime(data.get('start_date'), '%Y-%m-%d').date(),
                    end_date=datetime.strptime(data.get('end_date'), '%Y-%m-%d').date(),
                    estimated_duration=int(data.get('estimated_duration', 0)) if data.get('estimated_duration') else None,
                    priority=data.get('priority', 'normal'),
                    assigned_to=int(data.get('assigned_to')) if data.get('assigned_to') else None,
                    contractor_name=data.get('contractor_name'),
                    team_size=int(data.get('team_size', 0)) if data.get('team_size') else None,
                    materials_required=json.loads(data.get('materials_json', '[]')) if data.get('materials_json') else None,
                    equipment_required=json.loads(data.get('equipment_json', '[]')) if data.get('equipment_json') else None,
                    estimated_cost=float(data.get('estimated_cost', 0)) if data.get('estimated_cost') else None,
                    budget_code=data.get('budget_code'),
                    quality_standards=data.get('quality_standards'),
                    safety_requirements=data.get('safety_requirements'),
                    special_instructions=data.get('special_instructions'),
                    created_by=current_user.id
                )
                
                db.session.add(work_order)
                db.session.commit()
                
                flash('Work order created successfully', 'success')
                return redirect(url_for('site_mgr.work_orders'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating work order: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status')
        
        query = WorkOrder.query
        if status_filter:
            query = query.filter_by(status=status_filter)
        
        orders = query.order_by(WorkOrder.created_at.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        users = User.query.all()
        
        return render_template('site/manager/work_orders.html',
                             orders=orders,
                             projects=projects,
                             users=users)
    
    
    @app.route('/site/manager/meetings', methods=['GET', 'POST'], endpoint='site_mgr.meetings')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def site_meetings():
        """Site meeting management"""
        if request.method == 'POST':
            try:
                data = request.form
                import json
                
                meeting = SiteMeeting(
                    meeting_number=data.get('meeting_number'),
                    project_id=int(data.get('project_id')),
                    meeting_type=data.get('meeting_type'),
                    meeting_date=datetime.strptime(data.get('meeting_date'), '%Y-%m-%d').date(),
                    start_time=datetime.strptime(data.get('start_time'), '%H:%M').time() if data.get('start_time') else None,
                    end_time=datetime.strptime(data.get('end_time'), '%H:%M').time() if data.get('end_time') else None,
                    venue=data.get('venue'),
                    attendees=json.loads(data.get('attendees_json', '[]')) if data.get('attendees_json') else None,
                    chairperson=data.get('chairperson'),
                    secretary=data.get('secretary'),
                    agenda=data.get('agenda'),
                    minutes=data.get('minutes'),
                    decisions_made=data.get('decisions_made'),
                    action_items=json.loads(data.get('action_items_json', '[]')) if data.get('action_items_json') else None,
                    progress_review=data.get('progress_review'),
                    issues_raised=data.get('issues_raised'),
                    resolutions=data.get('resolutions'),
                    next_steps=data.get('next_steps'),
                    next_meeting_date=datetime.strptime(data.get('next_meeting_date'), '%Y-%m-%d').date() if data.get('next_meeting_date') else None,
                    next_meeting_agenda=data.get('next_meeting_agenda'),
                    organized_by=current_user.id
                )
                
                db.session.add(meeting)
                db.session.commit()
                
                flash('Site meeting created successfully', 'success')
                return redirect(url_for('site_mgr.meetings'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating meeting: {str(e)}', 'error')
        
        # GET request
        meetings = SiteMeeting.query.order_by(SiteMeeting.meeting_date.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('site/manager/meetings.html',
                             meetings=meetings,
                             projects=projects)
    
    
    @app.route('/site/manager/change-orders', methods=['GET', 'POST'], endpoint='site_mgr.change_orders')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def change_orders():
        """Change order management"""
        if request.method == 'POST':
            try:
                data = request.form
                
                change_order = ChangeOrder(
                    change_order_number=data.get('change_order_number'),
                    project_id=int(data.get('project_id')),
                    title=data.get('title'),
                    description=data.get('description'),
                    change_type=data.get('change_type'),
                    category=data.get('category'),
                    reason=data.get('reason'),
                    justification=data.get('justification'),
                    requested_by=data.get('requested_by'),
                    scope_impact=data.get('scope_impact'),
                    cost_impact=float(data.get('cost_impact', 0)) if data.get('cost_impact') else None,
                    time_impact=int(data.get('time_impact', 0)) if data.get('time_impact') else None,
                    quality_impact=data.get('quality_impact'),
                    original_specification=data.get('original_specification'),
                    revised_specification=data.get('revised_specification'),
                    original_cost=float(data.get('original_cost', 0)) if data.get('original_cost') else None,
                    revised_cost=float(data.get('revised_cost', 0)) if data.get('revised_cost') else None,
                    original_completion_date=datetime.strptime(data.get('original_completion_date'), '%Y-%m-%d').date() if data.get('original_completion_date') else None,
                    revised_completion_date=datetime.strptime(data.get('revised_completion_date'), '%Y-%m-%d').date() if data.get('revised_completion_date') else None,
                    submitted_by=current_user.id
                )
                
                change_order.calculate_cost_difference()
                change_order.calculate_time_extension()
                
                db.session.add(change_order)
                db.session.commit()
                
                flash('Change order created successfully', 'success')
                return redirect(url_for('site_mgr.change_orders'))
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating change order: {str(e)}', 'error')
        
        # GET request
        status_filter = request.args.get('status')
        
        query = ChangeOrder.query
        if status_filter:
            query = query.filter_by(status=status_filter)
        
        orders = query.order_by(ChangeOrder.submitted_at.desc()).all()
        projects = Project.query.filter_by(status='Active').all()
        
        return render_template('site/manager/change_orders.html',
                             orders=orders,
                             projects=projects)
    
    
    @app.route('/site/manager/reports', endpoint='site_mgr.reports')
    @role_required([Roles.PROJECT_MANAGER, Roles.SUPER_HQ])
    def site_reports():
        """Comprehensive site reports and analytics"""
        from sqlalchemy import func
        from datetime import datetime, timedelta
        
        today = datetime.now(timezone.utc).date()
        month_start = today.replace(day=1)
        year_start = datetime(today.year, 1, 1).date()
        
        # Get user's projects
        user_projects = Project.query.filter(
            (Project.project_manager == current_user.name) | 
            (Project.status == 'Active')
        ).all()
        
        project_ids = [p.id for p in user_projects]
        
        # DPR Statistics
        total_dprs_month = DailyProgressReport.query.filter(
            DailyProgressReport.project_id.in_(project_ids) if project_ids else False,
            DailyProgressReport.report_date >= month_start
        ).count()
        
        # Safety Statistics
        total_incidents_year = SafetyIncident.query.filter(
            SafetyIncident.project_id.in_(project_ids) if project_ids else False,
            SafetyIncident.incident_date >= year_start
        ).count()
        
        incidents_by_severity = db.session.query(
            SafetyIncident.severity,
            func.count(SafetyIncident.id).label('count')
        ).filter(
            SafetyIncident.project_id.in_(project_ids) if project_ids else False,
            SafetyIncident.incident_date >= year_start
        ).group_by(SafetyIncident.severity).all()
        
        # Equipment Utilization
        equipment_hours = db.session.query(
            func.sum(EquipmentLog.hours_used).label('total_hours')
        ).filter(
            EquipmentLog.project_id.in_(project_ids) if project_ids else False,
            EquipmentLog.log_date >= month_start
        ).scalar() or 0
        
        # Quality Control Statistics
        qc_pass_rate = db.session.query(
            func.count(QualityControl.id).label('total'),
            func.sum(db.case([(QualityControl.pass_fail_status == 'pass', 1)], else_=0)).label('passed')
        ).filter(
            QualityControl.project_id.in_(project_ids) if project_ids else False,
            QualityControl.test_date >= month_start
        ).first()
        
        pass_percentage = (qc_pass_rate.passed / qc_pass_rate.total * 100) if qc_pass_rate.total > 0 else 0
        
        # Material Request Statistics
        material_request_stats = db.session.query(
            MaterialRequest.status,
            func.count(MaterialRequest.id).label('count')
        ).filter(
            MaterialRequest.project_id.in_(project_ids) if project_ids else False
        ).group_by(MaterialRequest.status).all()
        
        # Work Order Completion
        work_order_completion = db.session.query(
            WorkOrder.status,
            func.count(WorkOrder.id).label('count')
        ).filter(
            WorkOrder.project_id.in_(project_ids) if project_ids else False
        ).group_by(WorkOrder.status).all()
        
        report_data = {
            'projects': user_projects,
            'summary': {
                'total_dprs_month': total_dprs_month,
                'total_incidents_year': total_incidents_year,
                'equipment_hours_month': float(equipment_hours),
                'qc_pass_percentage': pass_percentage
            },
            'incidents_by_severity': incidents_by_severity,
            'material_request_stats': material_request_stats,
            'work_order_completion': work_order_completion
        }
        
        return render_template('site/manager/reports.html', **report_data)


    # ============================================================================
    # ROUTES FROM HQ.PY
    # ============================================================================



    @app.route('/hq', endpoint='hq.hq_home')
    def hq_home():
        return "HQ Dashboard"



    # ============================================================================
    # ROUTES FROM PROCUREMENT.PY
    # ============================================================================


# --- Multi-level Approval Endpoint ---

    from io import BytesIO
    from sqlalchemy.exc import SQLAlchemyError


# Dashboard Route
# Search Endpoint
    @app.route('/procurement/search', methods=["GET", "POST"], endpoint='procurement.search')
    @role_required([Roles.HQ_PROCUREMENT])
    def search():
        try:
            query = request.args.get('q', '').strip() if request.method == 'GET' else request.form.get('q', '').strip()
            results = {'assets': [], 'purchases': [], 'suppliers': []}
            if query:
            # Search assets
                results['assets'] = InventoryItem.query.filter(
                    (InventoryItem.code.ilike(f"%{query}%")) |
                    (InventoryItem.description.ilike(f"%{query}%")) |
                    (InventoryItem.category.ilike(f"%{query}%"))
                ).all()
            # Search purchases
                results['purchases'] = ProcurementRequest.query.filter(
                    (ProcurementRequest.item_name.ilike(f"%{query}%")) |
                    (ProcurementRequest.status.ilike(f"%{query}%"))
                ).all()
            # Search suppliers
                results['suppliers'] = Vendor.query.filter(
                    (Vendor.name.ilike(f"%{query}%")) |
                    (Vendor.category.ilike(f"%{query}%"))
                ).all()
            return render_template('procurement/search/index.html', query=query, results=results)
        except Exception as e:
            current_app.logger.error(f"Search error: {str(e)}")
            flash("Error performing search", "error")
            return render_template('error.html'), 500
# Notifications Endpoint
    @app.route('/procurement/notifications', endpoint='procurement.notifications')
    @role_required([Roles.HQ_PROCUREMENT])
    def notifications():
        try:
            alerts = Alert.query.order_by(Alert.created_at.desc()).limit(50).all()
            alert_data = [
                {
                    'id': a.id,
                    'title': a.title,
                    'type': a.type,
                    'description': a.description,
                    'status': a.status,
                    'severity': a.severity,
                    'created_at': a.created_at.strftime('%Y-%m-%d %H:%M:%S') if a.created_at else ''
                }
                for a in alerts
            ]
            return render_template('procurement/notifications/index.html', alerts=alert_data)
        except Exception as e:
            current_app.logger.error(f"Notifications error: {str(e)}")
            flash("Error loading notifications", "error")
            return render_template('error.html'), 500
# Budget Endpoint
    @app.route('/procurement/budget', endpoint='procurement.budget')
    @role_required([Roles.HQ_PROCUREMENT])
    def budget():
        try:
        # Summarize by project and category
            budgets = Budget.query.all()
            budget_summary = {}
            for b in budgets:
                key = f"{b.project_id}:{b.category}"
                if key not in budget_summary:
                    budget_summary[key] = {
                        'project_id': b.project_id,
                        'category': b.category,
                        'allocated': 0.0,
                        'spent': 0.0,
                        'remaining': 0.0
                    }
                budget_summary[key]['allocated'] += b.allocated_amount
                budget_summary[key]['spent'] += b.spent_amount
                budget_summary[key]['remaining'] = budget_summary[key]['allocated'] - budget_summary[key]['spent']
            summary_list = list(budget_summary.values())
            return render_template('procurement/budget/index.html', summary=summary_list)
        except Exception as e:
            current_app.logger.error(f"Budget error: {str(e)}")
            flash("Error loading budget data", "error")
            return render_template('error.html'), 500
# Maintenance Endpoint
    @app.route('/procurement/maintenance', endpoint='procurement.maintenance')
    @role_required([Roles.HQ_PROCUREMENT])
    def maintenance():
        try:
            # Get all assets and technicians
            all_assets = InventoryItem.query.order_by(InventoryItem.created_at.desc()).all()
            technicians = Technician.query.filter_by(status='active').all()
            
            # Get scheduled maintenance
            scheduled_maintenance = MaintenanceSchedule.query.filter(
                MaintenanceSchedule.status.in_(['scheduled', 'in_progress'])
            ).order_by(MaintenanceSchedule.scheduled_date).all()
            
            # Create sample maintenance data based on asset age
            today = datetime.now(timezone.utc).date()
            
            # Assets that might need maintenance (older items or specific categories)
            due_soon = []
            overdue = []
            
            for asset in all_assets:
                if asset.category in ['Heavy Equipment', 'Machinery', 'Vehicles', 'Tools']:
                    # Calculate days since creation (proxy for maintenance needs)
                    if asset.created_at:
                        days_old = (today - asset.created_at.date()).days
                        
                        # Items older than 90 days considered overdue
                        if days_old > 90:
                            overdue.append({
                                'id': asset.id,
                                'code': asset.code,
                                'description': asset.description,
                                'category': asset.category,
                                'days_overdue': days_old - 90,
                                'last_maintenance': 'Never' if days_old > 180 else f'{days_old} days ago'
                            })
                        # Items 60-90 days old - due soon
                        elif days_old > 60:
                            due_soon.append({
                                'id': asset.id,
                                'code': asset.code,
                                'description': asset.description,
                                'category': asset.category,
                                'due_in': 90 - days_old,
                                'last_maintenance': f'{days_old} days ago'
                            })
            
            # Get completed maintenance history
            history = MaintenanceSchedule.query.filter_by(status='completed').order_by(
                MaintenanceSchedule.completed_date.desc()
            ).limit(20).all()
            
            maintenance_data = {
                'stats': {
                    'total_assets': len(all_assets),
                    'due_soon_count': len(due_soon),
                    'overdue_count': len(overdue),
                    'completed_this_month': len(history)
                },
                'due_soon': due_soon[:10],
                'overdue': overdue[:10],
                'history': history,
                'scheduled': scheduled_maintenance,
                'assets': all_assets,
                'technicians': technicians,
                'today': today.strftime('%Y-%m-%d')
            }
            return render_template('procurement/maintenance/index.html', data=maintenance_data)
        except Exception as e:
            current_app.logger.error(f"Maintenance error: {str(e)}")
            flash("Error loading maintenance data", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/technicians/add', methods=['POST'], endpoint='procurement.add_technician')
    @role_required([Roles.HQ_PROCUREMENT])
    def add_technician():
        """Add a new technician"""
        try:
            name = request.form.get('name', '').strip()
            email = request.form.get('email', '').strip()
            phone = request.form.get('phone', '').strip()
            specialization = request.form.get('specialization', '').strip()
            
            if not all([name, email, phone]):
                flash("Name, email, and phone are required", "error")
                return redirect(url_for('procurement.maintenance'))
            
            # Check if email already exists
            existing = Technician.query.filter_by(email=email).first()
            if existing:
                flash(f"Technician with email '{email}' already exists", "error")
                return redirect(url_for('procurement.maintenance'))
            
            new_technician = Technician(
                name=name,
                email=email,
                phone=phone,
                specialization=specialization,
                status='active'
            )
            
            db.session.add(new_technician)
            db.session.commit()
            
            current_app.logger.info(f"New technician added: {name}")
            flash(f"Technician '{name}' added successfully", "success")
            return redirect(url_for('procurement.maintenance'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Add technician error: {str(e)}")
            flash("Error adding technician", "error")
            return redirect(url_for('procurement.maintenance'))

    @app.route('/procurement/maintenance/schedule', methods=['POST'], endpoint='procurement.schedule_maintenance')
    @role_required([Roles.HQ_PROCUREMENT])
    def schedule_maintenance():
        """Schedule maintenance for an asset"""
        try:
            asset_id = request.form.get('asset_id')
            technician_id = request.form.get('technician_id')
            maintenance_type = request.form.get('maintenance_type', '').strip()
            scheduled_date = request.form.get('scheduled_date')
            notes = request.form.get('notes', '').strip()
            
            if not all([asset_id, maintenance_type, scheduled_date]):
                flash("Asset, maintenance type, and scheduled date are required", "error")
                return redirect(url_for('procurement.maintenance'))
            
            # Verify asset exists
            asset = InventoryItem.query.get_or_404(int(asset_id))
            
            # Parse date
            scheduled_date_obj = datetime.strptime(scheduled_date, '%Y-%m-%d').date()
            
            new_schedule = MaintenanceSchedule(
                asset_id=int(asset_id),
                technician_id=int(technician_id) if technician_id else None,
                maintenance_type=maintenance_type,
                scheduled_date=scheduled_date_obj,
                status='scheduled',
                notes=notes
            )
            
            db.session.add(new_schedule)
            db.session.commit()
            
            current_app.logger.info(f"Maintenance scheduled for asset {asset.code}")
            flash(f"Maintenance scheduled successfully for {asset.code}", "success")
            return redirect(url_for('procurement.maintenance'))
            
        except ValueError as e:
            flash("Invalid date format", "error")
            return redirect(url_for('procurement.maintenance'))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Schedule maintenance error: {str(e)}")
            flash("Error scheduling maintenance", "error")
            return redirect(url_for('procurement.maintenance'))

    @app.route('/procurement/maintenance/update/<int:schedule_id>', methods=['POST'], endpoint='procurement.update_maintenance')
    @role_required([Roles.HQ_PROCUREMENT])
    def update_maintenance(schedule_id):
        """Update maintenance status"""
        try:
            schedule = MaintenanceSchedule.query.get_or_404(schedule_id)
            status = request.form.get('status')
            cost = request.form.get('cost', 0)
            notes = request.form.get('notes', '')
            
            if status:
                schedule.status = status
                if status == 'completed':
                    schedule.completed_date = datetime.now(timezone.utc).date()
            
            if cost:
                schedule.cost = float(cost)
            
            if notes:
                schedule.notes = notes
            
            db.session.commit()
            
            flash("Maintenance updated successfully", "success")
            return redirect(url_for('procurement.maintenance'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Update maintenance error: {str(e)}")
            flash("Error updating maintenance", "error")
            return redirect(url_for('procurement.maintenance'))

# Analytics Endpoint
    @app.route('/procurement/analytics', endpoint='procurement.analytics')
    @role_required([Roles.HQ_PROCUREMENT])
    def analytics():
        try:
        # Top categories by spend
            category_spend = db.session.query(
                ProcurementRequest.item_name,
                db.func.sum(ProcurementRequest.price * ProcurementRequest.qty).label('total_spend')
            ).group_by(ProcurementRequest.item_name).order_by(db.desc('total_spend')).limit(5).all()

        # Spend by month (last 6 months)
            spend_by_month = db.session.query(
                db.func.strftime('%Y-%m', ProcurementRequest.created_at),
                db.func.sum(ProcurementRequest.price * ProcurementRequest.qty)
            ).group_by(db.func.strftime('%Y-%m', ProcurementRequest.created_at)).order_by(db.desc(db.func.strftime('%Y-%m', ProcurementRequest.created_at))).limit(6).all()

        # Supplier performance (number of completed requests per supplier)
            supplier_performance = db.session.query(
                Vendor.name,
                db.func.count(ProcurementRequest.id)
            ).join(ProcurementRequest, ProcurementRequest.vendor_id == Vendor.id).filter(ProcurementRequest.status == 'completed').group_by(Vendor.name).order_by(db.desc(db.func.count(ProcurementRequest.id))).limit(5).all()

            analytics_data = {
                'category_spend': [{'item_name': c[0], 'total_spend': c[1]} for c in category_spend],
                'spend_by_month': [{'month': m[0], 'total_spend': m[1]} for m in spend_by_month],
                'supplier_performance': [{'supplier': s[0], 'completed_orders': s[1]} for s in supplier_performance]
            }
            return render_template('procurement/analytics/index.html', data=analytics_data)
        except Exception as e:
            current_app.logger.error(f"Analytics error: {str(e)}")
            flash("Error loading analytics", "error")
            return render_template('error.html'), 500
    @app.route('/procurement/my-approvals', endpoint='procurement.my_approvals')
    @role_required([Roles.HQ_PROCUREMENT])
    def my_approvals():
        """View all purchase orders submitted by current user with approval status"""
        try:
            # Get all POs submitted by current user
            purchase_orders = PurchaseOrder.query.filter_by(
                requested_by=current_user.id
            ).order_by(PurchaseOrder.created_at.desc()).all()
            
            return render_template('procurement/my_approvals.html', 
                                 purchase_orders=purchase_orders)
        except Exception as e:
            current_app.logger.error(f"My approvals error: {str(e)}", exc_info=True)
            flash("Error loading approval status", "error")
            return redirect(url_for('procurement.procurement_home'))

    @app.route('/procurement/purchases', endpoint='procurement.purchases')
    @role_required([Roles.HQ_PROCUREMENT])
    def purchases():
        try:
            # Get purchase orders from database
            purchase_orders = PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).all()
            
            # Format purchase orders for display
            po_list = []
            for po in purchase_orders:
                po_list.append({
                    'id': po.id,
                    'po_number': po.order_number,
                    'supplier': po.supplier_name,
                    'total_amount': po.total_amount,
                    'status': po.status,
                    'order_date': po.created_at.strftime('%Y-%m-%d') if po.created_at else '',
                    'expected_delivery': po.expected_delivery.strftime('%Y-%m-%d') if po.expected_delivery else '',
                    'items': [{'item': item.item_name, 'quantity': item.quantity, 'unitPrice': item.unit_price, 'subtotal': item.line_total} for item in po.line_items]
                })
            
            # Stats based on PurchaseOrder model
            total_orders = PurchaseOrder.query.count()
            pending = PurchaseOrder.query.filter(PurchaseOrder.status.in_(['Draft', 'Pending'])).count()
            in_transit = PurchaseOrder.query.filter_by(status='Ordered').count()
            completed = PurchaseOrder.query.filter_by(status='Delivered').count()
            
            # Budget info
            total_budget = db.session.query(db.func.sum(Budget.allocated_amount)).scalar() or 0
            utilized = db.session.query(db.func.sum(PurchaseOrder.total_amount)).filter(PurchaseOrder.status.in_(['Delivered', 'Ordered'])).scalar() or 0
            remaining = total_budget - utilized
            
            # Get suppliers from database (only validated ones)
            suppliers = Vendor.query.filter_by(validated=True).order_by(Vendor.name).all()
            suppliers_list = [{'id': s.id, 'name': s.name, 'category': s.category} for s in suppliers]
            
            purchase_data = {
                'stats': {
                    'total_orders': total_orders,
                    'pending': pending,
                    'in_transit': in_transit,
                    'completed': completed
                },
                'budget': {
                    'total': total_budget,
                    'utilized': utilized,
                    'remaining': remaining
                },
                'suppliers': suppliers_list,
                'purchase_orders': po_list
            }
            return render_template('procurement/purchases/index.html', data=purchase_data)
        except Exception as e:
            current_app.logger.error(f"Purchase management error: {str(e)}")
            flash("Error loading purchases", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/purchases/create', methods=['POST'], endpoint='procurement.create_purchase_order')
    @role_required([Roles.HQ_PROCUREMENT])
    def create_purchase_order():
        try:
            data = request.get_json()
            
            # Generate PO number
            po_number = f"PO-{datetime.now().strftime('%Y%m%d%H%M%S')}"
            
            # Get vendor info
            vendor = Vendor.query.get(data['supplier_id'])
            
            # Create purchase order using existing model
            po = PurchaseOrder(
                order_number=po_number,
                supplier_name=vendor.name if vendor else 'Unknown',
                supplier_contact=vendor.name if vendor else '',
                expected_delivery=datetime.strptime(data['delivery_date'], '%Y-%m-%d').date(),
                total_amount=data['total_amount'],
                status='Draft',
                requested_by=current_user.id  # Link PO to current user
            )
            db.session.add(po)
            db.session.flush()  # Get the PO id
            
            # Add items
            for item in data['items']:
                po_item = PurchaseOrderLineItem(
                    purchase_order_id=po.id,
                    item_name=item['item'],
                    quantity=item['quantity'],
                    unit_price=item['unitPrice'],
                    line_total=item['subtotal']
                )
                db.session.add(po_item)
            
            # Create approval workflow and send to Cost Control
            workflow = create_approval_workflow(
                workflow_type='purchase_order',
                reference_id=po.id,
                reference_number=po.order_number,
                initiated_by=current_user.id,
                total_amount=po.total_amount,
                description=f"Purchase Order from {po.supplier_name}",
                priority='normal'
            )
            
            # Link workflow to PO
            po.workflow_id = workflow.id
            po.status = 'Pending_Cost_Control'
            
            # Send notification to Cost Control (step 1)
            send_approval_notification(
                workflow_id=workflow.id,
                step_order=1,
                action='request'
            )
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'po': {
                    'id': po.id,
                    'po_number': po.order_number,
                    'supplier': po.supplier_name,
                    'total_amount': po.total_amount,
                    'status': po.status,
                    'order_date': po.created_at.strftime('%Y-%m-%d'),
                    'expected_delivery': po.expected_delivery.strftime('%Y-%m-%d') if po.expected_delivery else '',
                    'items': data['items']
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating purchase order: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500

    @app.route('/procurement/purchases/<int:po_id>', methods=['GET'], endpoint='procurement.get_purchase_order')
    @role_required([Roles.HQ_PROCUREMENT, Roles.HQ_COST_CONTROL, Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def get_purchase_order(po_id):
        try:
            po = PurchaseOrder.query.get_or_404(po_id)
            
            # Find the matching vendor by name
            supplier_id = None
            if po.supplier_name:
                vendor = Vendor.query.filter_by(name=po.supplier_name).first()
                if vendor:
                    supplier_id = vendor.id
            
            return jsonify({
                'success': True,
                'po': {
                    'id': po.id,
                    'po_number': po.order_number,
                    'supplier_id': supplier_id,
                    'supplier': po.supplier_name,
                    'total_amount': po.total_amount,
                    'status': po.status,
                    'order_date': po.created_at.strftime('%Y-%m-%d') if po.created_at else '',
                    'expected_delivery': po.expected_delivery.strftime('%Y-%m-%d') if po.expected_delivery else '',
                    'items': [{'item': item.item_name, 'quantity': item.quantity, 'unitPrice': item.unit_price, 'subtotal': item.line_total} for item in po.line_items]
                }
            }), 200
        except Exception as e:
            current_app.logger.error(f"Error fetching purchase order: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500

    @app.route('/procurement/purchases/<int:po_id>/update', methods=['POST'], endpoint='procurement.update_purchase_order')
    @role_required([Roles.HQ_PROCUREMENT])
    def update_purchase_order(po_id):
        try:
            data = request.get_json()
            po = PurchaseOrder.query.get_or_404(po_id)
            
            # Get vendor info
            vendor = Vendor.query.get(data['supplier_id'])
            
            # Update PO
            po.supplier_name = vendor.name if vendor else 'Unknown'
            po.supplier_contact = vendor.name if vendor else ''
            po.expected_delivery = datetime.strptime(data['delivery_date'], '%Y-%m-%d').date()
            po.total_amount = data['total_amount']
            
            # Delete old items and add new ones
            PurchaseOrderLineItem.query.filter_by(purchase_order_id=po.id).delete()
            
            for item in data['items']:
                po_item = PurchaseOrderLineItem(
                    purchase_order_id=po.id,
                    item_name=item['item'],
                    quantity=item['quantity'],
                    unit_price=item['unitPrice'],
                    line_total=item['subtotal']
                )
                db.session.add(po_item)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'po': {
                    'id': po.id,
                    'po_number': po.order_number,
                    'supplier': po.supplier_name,
                    'total_amount': po.total_amount,
                    'status': po.status,
                    'order_date': po.created_at.strftime('%Y-%m-%d'),
                    'expected_delivery': po.expected_delivery.strftime('%Y-%m-%d') if po.expected_delivery else '',
                    'items': data['items']
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating purchase order: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500

    @app.route('/procurement/purchases/<int:po_id>/delete', methods=['POST'], endpoint='procurement.delete_purchase_order')
    @role_required([Roles.HQ_PROCUREMENT])
    def delete_purchase_order(po_id):
        try:
            po = PurchaseOrder.query.get_or_404(po_id)
            po_number = po.order_number
            
            db.session.delete(po)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'Purchase Order {po_number} deleted successfully'
            }), 200
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting purchase order: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500

    @app.route('/procurement/suppliers', endpoint='procurement.suppliers')
    @role_required([Roles.HQ_PROCUREMENT])
    def suppliers():
        try:
            # Get all suppliers
            all_suppliers = Vendor.query.order_by(Vendor.created_at.desc()).all()
            
            # Calculate stats
            total = len(all_suppliers)
            active = sum(1 for v in all_suppliers if v.validated)
            pending_review = sum(1 for v in all_suppliers if not v.validated)
            
            # Format suppliers data for display
            suppliers_list = []
            for vendor in all_suppliers:
                # Calculate rating based on validation status (placeholder logic)
                rating = 5.0 if vendor.validated else 3.0
                
                # Determine status
                if vendor.validated:
                    status = 'Active'
                    status_color = 'green'
                else:
                    status = 'Pending Review'
                    status_color = 'yellow'
                
                suppliers_list.append({
                    'id': vendor.id,
                    'name': vendor.name,
                    'category': vendor.category or 'General',
                    'payment_terms': vendor.payment_terms or 'N/A',
                    'validated': vendor.validated,
                    'status': status,
                    'status_color': status_color,
                    'rating': rating,
                    'created_at': vendor.created_at.strftime('%Y-%m-%d') if vendor.created_at else 'N/A'
                })
            
            supplier_data = {
                'stats': {
                    'total': total,
                    'active': active,
                    'blacklisted': 0,  # Not implemented yet
                    'pending_review': pending_review
                },
                'suppliers': suppliers_list
            }
            return render_template('procurement/suppliers/index.html', data=supplier_data)
        except Exception as e:
            current_app.logger.error(f"Supplier management error: {str(e)}")
            flash("Error loading suppliers", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/suppliers/add', methods=['POST'], endpoint='procurement.add_supplier')
    @role_required([Roles.HQ_PROCUREMENT])
    def add_supplier():
        """Add a new supplier"""
        try:
            name = request.form.get('name', '').strip()
            category = request.form.get('category', '').strip()
            payment_terms = request.form.get('payment_terms', '').strip()
            
            if not all([name, category]):
                flash("Name and category are required", "error")
                return redirect(url_for('procurement.suppliers'))
            
            # Check if supplier already exists
            existing = Vendor.query.filter_by(name=name).first()
            if existing:
                flash(f"Supplier '{name}' already exists", "error")
                return redirect(url_for('procurement.suppliers'))
            
            new_supplier = Vendor(
                name=name,
                category=category,
                payment_terms=payment_terms,
                validated=False  # New suppliers need review
            )
            
            db.session.add(new_supplier)
            db.session.commit()
            
            current_app.logger.info(f"New supplier added: {name}")
            flash(f"Supplier '{name}' added successfully", "success")
            return redirect(url_for('procurement.suppliers'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Add supplier error: {str(e)}")
            flash("Error adding supplier", "error")
            return redirect(url_for('procurement.suppliers'))

    @app.route('/procurement/suppliers/validate/<int:supplier_id>', methods=['POST'], endpoint='procurement.validate_supplier')
    @role_required([Roles.HQ_PROCUREMENT])
    def validate_supplier(supplier_id):
        """Validate/activate a supplier"""
        try:
            supplier = Vendor.query.get_or_404(supplier_id)
            supplier.validated = True
            db.session.commit()
            
            flash(f"Supplier '{supplier.name}' validated successfully", "success")
            return redirect(url_for('procurement.suppliers'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Validate supplier error: {str(e)}")
            flash("Error validating supplier", "error")
            return redirect(url_for('procurement.suppliers'))

    @app.route('/procurement/suppliers/delete/<int:supplier_id>', methods=['POST'], endpoint='procurement.delete_supplier')
    @role_required([Roles.HQ_PROCUREMENT])
    def delete_supplier(supplier_id):
        """Delete a supplier"""
        try:
            supplier = Vendor.query.get_or_404(supplier_id)
            supplier_name = supplier.name
            db.session.delete(supplier)
            db.session.commit()
            
            return jsonify({'status': 'success', 'message': f'Supplier "{supplier_name}" deleted successfully'})
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Delete supplier error: {str(e)}")
            return jsonify({'error': str(e)}), 500

# Asset Tracking Route
    @app.route('/procurement/tracking', endpoint='procurement.tracking')
    @role_required([Roles.HQ_PROCUREMENT])
    def tracking():
        try:
            total_tracked = InventoryItem.query.count()
            in_use = InventoryItem.query.filter(InventoryItem.status == 'Active').count()
            in_transit = InventoryItem.query.filter(InventoryItem.status == 'In Transit').count()
            in_maintenance = InventoryItem.query.filter(InventoryItem.status == 'In Maintenance').count()
            
            # Get all assets with location data for map
            assets = InventoryItem.query.all()
            assets_list = []
            for asset in assets:
                assets_list.append({
                    'id': asset.id,
                    'code': asset.code,
                    'description': asset.description,
                    'category': asset.category,
                    'location': asset.location,
                    'previous_location': asset.previous_location,
                    'latitude': asset.latitude,
                    'longitude': asset.longitude,
                    'status': asset.status,
                    'last_location_update': asset.last_location_update.strftime('%Y-%m-%d %H:%M') if asset.last_location_update else None
                })
            
            tracking_data = {
                'stats': {
                    'total_tracked': total_tracked,
                    'in_use': in_use,
                    'in_transit': in_transit,
                    'in_maintenance': in_maintenance
                },
                'assets': assets_list
            }
            return render_template('procurement/tracking/index.html', data=tracking_data)
        except Exception as e:
            current_app.logger.error(f"Asset tracking error: {str(e)}")
            flash("Error loading tracking data", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/tracking/update-location/<int:asset_id>', methods=['POST'], endpoint='procurement.update_asset_location')
    @role_required([Roles.HQ_PROCUREMENT])
    def update_asset_location(asset_id):
        try:
            asset = InventoryItem.query.get_or_404(asset_id)
            data = request.get_json()
            
            # Save previous location before updating
            if asset.location and asset.location != data.get('location'):
                asset.previous_location = asset.location
            
            # Update location details
            asset.location = data.get('location')
            asset.latitude = float(data.get('latitude')) if data.get('latitude') else None
            asset.longitude = float(data.get('longitude')) if data.get('longitude') else None
            asset.status = data.get('status', asset.status)
            asset.last_location_update = datetime.now(timezone.utc)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Asset location updated successfully',
                'asset': {
                    'id': asset.id,
                    'code': asset.code,
                    'description': asset.description,
                    'location': asset.location,
                    'latitude': asset.latitude,
                    'longitude': asset.longitude,
                    'status': asset.status,
                    'last_location_update': asset.last_location_update.strftime('%Y-%m-%d %H:%M')
                }
            }), 200
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating asset location: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500

# API: Get Asset Details
    @app.route('/procurement/api/assets/<int:asset_id>', endpoint='procurement.get_asset')
    @role_required([Roles.HQ_PROCUREMENT])
    def get_asset(asset_id):
        try:
            asset = InventoryItem.query.get_or_404(asset_id)
            asset_data = {
                'id': asset.id,
                'code': asset.code,
                'name': asset.description,
                'category': asset.category,
                'qty_available': asset.qty_available,
                'unit_cost': asset.unit_cost,
                'uom': asset.uom,
                'total_cost': asset.total_cost,
                'price_change': asset.price_change,
                'status': getattr(asset, 'status', 'Active'),
                'group': asset.group,
                'created_at': asset.created_at.strftime('%Y-%m-%d') if asset.created_at else None,
                'updated_at': asset.updated_at.strftime('%Y-%m-%d') if asset.updated_at else None
            }
            return jsonify(asset_data)
        except Exception as e:
            current_app.logger.error(f"Asset fetch error: {str(e)}")
            return jsonify({'error': str(e)}), 500

# API: Get Purchase Details
    @app.route('/procurement/api/purchases/<int:purchase_id>', endpoint='procurement.get_purchase')
    @role_required([Roles.HQ_PROCUREMENT])
    def get_purchase(purchase_id):
        try:
            purchase = ProcurementRequest.query.get_or_404(purchase_id)
            purchase_data = {
                'id': purchase.id,
                'project_id': purchase.project_id,
                'item_name': purchase.item_name,
                'price': purchase.price,
                'qty': purchase.qty,
                'unit': purchase.unit,
                'status': purchase.status,
                'current_approver': purchase.current_approver,
                'created_at': purchase.created_at.strftime('%Y-%m-%d') if purchase.created_at else None,
                'updated_at': purchase.updated_at.strftime('%Y-%m-%d') if purchase.updated_at else None
            }
            return jsonify(purchase_data)
        except Exception as e:
            current_app.logger.error(f"Purchase fetch error: {str(e)}")
            return jsonify({'error': str(e)}), 500

# Asset CRUD Endpoints
    @app.route('/procurement/assets/add', methods=['POST'], endpoint='procurement.add_asset')
    @role_required([Roles.HQ_PROCUREMENT])
    def add_asset():
        """Add a new inventory asset - handles both JSON and form data"""
        try:
            # Check if request is JSON or form data
            if request.is_json:
                data = request.get_json()
                code = data.get('code')
                description = data.get('description')
                category = data.get('category')
                group = data.get('group')
                qty_available = data.get('qty_available', 0.0)
                uom = data.get('uom')
                unit_cost = data.get('unit_cost')
                total_cost = data.get('total_cost', qty_available * unit_cost if unit_cost else 0.0)
                
                asset = InventoryItem(
                    code=code,
                    description=description,
                    group=group,
                    category=category,
                    qty_available=qty_available,
                    unit_cost=unit_cost,
                    uom=uom,
                    total_cost=total_cost,
                    price_change=data.get('price_change', 0.0)
                )
                db.session.add(asset)
                db.session.commit()
                return jsonify({'status': 'success', 'message': 'Asset added successfully', 'id': asset.id})
            else:
                # Handle form data
                code = request.form.get('code', '').strip()
                description = request.form.get('description', '').strip()
                category = request.form.get('category', '').strip()
                group = request.form.get('group', '').strip()
                qty_available = float(request.form.get('qty_available', 0))
                uom = request.form.get('uom', '').strip()
                unit_cost = float(request.form.get('unit_cost', 0))
                
                # Validation
                if not code or not description or not category or not uom:
                    flash("Code, description, category, and unit are required", "error")
                    return redirect(url_for('procurement.assets'))
                
                # Check if code already exists
                existing = InventoryItem.query.filter_by(code=code).first()
                if existing:
                    flash(f"Asset with code '{code}' already exists", "error")
                    return redirect(url_for('procurement.assets'))
                
                # Calculate total cost
                total_cost = qty_available * unit_cost
                
                # Create new inventory item
                new_asset = InventoryItem(
                    code=code,
                    description=description,
                    category=category,
                    group=group if group else None,
                    qty_available=qty_available,
                    uom=uom,
                    unit_cost=unit_cost,
                    total_cost=total_cost
                )
                
                db.session.add(new_asset)
                db.session.commit()
                
                current_app.logger.info(f"New asset added: {code} - {description}")
                flash(f"Asset '{description}' added successfully", "success")
                return redirect(url_for('procurement.assets'))
                
        except ValueError as e:
            if request.is_json:
                return jsonify({'error': 'Invalid number format'}), 400
            flash("Invalid number format for quantity or cost", "error")
            return redirect(url_for('procurement.assets'))
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Add asset error: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'error': str(e)}), 500
            flash("Error adding asset", "error")
            return redirect(url_for('procurement.assets'))

    @app.route('/procurement/assets/update/<int:asset_id>', methods=['POST'], endpoint='procurement.update_asset')
    @role_required([Roles.HQ_PROCUREMENT])
    def update_asset(asset_id):
        try:
            data = request.get_json()
            asset = InventoryItem.query.get_or_404(asset_id)
            asset.code = data.get('code', asset.code)
            asset.description = data.get('description', asset.description)
            asset.group = data.get('group', asset.group)
            asset.category = data.get('category', asset.category)
            asset.qty_available = data.get('qty_available', asset.qty_available)
            asset.unit_cost = data.get('unit_cost', asset.unit_cost)
            asset.uom = data.get('uom', asset.uom)
            asset.total_cost = data.get('total_cost', asset.total_cost)
            asset.price_change = data.get('price_change', asset.price_change)
            db.session.commit()
            return jsonify({'status': 'success', 'message': 'Asset updated successfully'})
        except Exception as e:
            current_app.logger.error(f"Update asset error: {str(e)}")
            return jsonify({'error': str(e)}), 500

    @app.route('/procurement/assets/<int:asset_id>', methods=['GET'], endpoint='procurement.view_asset')
    @role_required([Roles.HQ_PROCUREMENT])
    def view_asset(asset_id):
        """View single asset details"""
        try:
            asset = InventoryItem.query.get_or_404(asset_id)
            asset_data = {
                'id': asset.id,
                'code': asset.code,
                'description': asset.description,
                'category': asset.category,
                'group': asset.group,
                'qty_available': asset.qty_available,
                'uom': asset.uom,
                'unit_cost': asset.unit_cost,
                'total_cost': asset.total_cost,
                'status': 'Active' if asset.qty_available > 0 else 'Out of Stock',
                'created_at': asset.created_at.strftime('%Y-%m-%d %H:%M:%S') if asset.created_at else None,
                'updated_at': asset.updated_at.strftime('%Y-%m-%d %H:%M:%S') if asset.updated_at else None
            }
            return render_template('procurement/assets/view.html', asset=asset_data)
        except Exception as e:
            current_app.logger.error(f"View asset error: {str(e)}")
            flash("Error loading asset details", "error")
            return redirect(url_for('procurement.assets'))

    @app.route('/procurement/assets/edit/<int:asset_id>', methods=['GET'], endpoint='procurement.edit_asset')
    @role_required([Roles.HQ_PROCUREMENT])
    def edit_asset(asset_id):
        """Get asset data for editing"""
        try:
            asset = InventoryItem.query.get_or_404(asset_id)
            asset_data = {
                'id': asset.id,
                'code': asset.code,
                'description': asset.description,
                'category': asset.category,
                'group': asset.group,
                'qty_available': asset.qty_available,
                'uom': asset.uom,
                'unit_cost': asset.unit_cost,
                'total_cost': asset.total_cost
            }
            
            # If it's an AJAX request, return JSON
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify(asset_data)
            
            # Otherwise redirect to assets page (edit happens in modal)
            return redirect(url_for('procurement.assets'))
        except Exception as e:
            current_app.logger.error(f"Edit asset fetch error: {str(e)}")
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'error': str(e)}), 500
            flash("Error loading asset for editing", "error")
            return redirect(url_for('procurement.assets'))

    @app.route('/procurement/assets/delete/<int:asset_id>', methods=['POST'], endpoint='procurement.delete_asset')
    @role_required([Roles.HQ_PROCUREMENT])
    def delete_asset(asset_id):
        try:
            asset = InventoryItem.query.get_or_404(asset_id)
            db.session.delete(asset)
            db.session.commit()
            return jsonify({'status': 'success', 'message': 'Asset deleted successfully'})
        except Exception as e:
            current_app.logger.error(f"Delete asset error: {str(e)}")
            return jsonify({'error': str(e)}), 500
# Reports Endpoint
    @app.route('/procurement/reports', endpoint='procurement.reports')
    @role_required([Roles.HQ_PROCUREMENT])
    def reports():
        try:
            # Calculate statistics
            total_assets = InventoryItem.query.count()
            total_purchases = PurchaseOrder.query.count()
            active_suppliers = Vendor.query.filter_by(validated=True).count()
            
            # Calculate total spend from purchase orders
            total_spend = db.session.query(db.func.sum(PurchaseOrder.total_amount)).scalar() or 0
            
            stats = {
                'total_assets': total_assets,
                'total_purchases': total_purchases,
                'active_suppliers': active_suppliers,
                'total_spend': float(total_spend)
            }
            
            return render_template('procurement/reports/index.html', data={'stats': stats})
        except Exception as e:
            current_app.logger.error(f"Reports error: {str(e)}")
            flash("Error loading reports", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/reports/generate', methods=['POST'], endpoint='procurement.generate_report')
    @role_required([Roles.HQ_PROCUREMENT])
    def generate_report():
        try:
            data = request.get_json()
            report_type = data.get('report_type')
            start_date = data.get('start_date')
            end_date = data.get('end_date')
            
            report_data = []
            
            if report_type == 'assets':
                assets = InventoryItem.query.all()
                report_data = [{
                    'Code': asset.code,
                    'Description': asset.description,
                    'Category': asset.category or 'N/A',
                    'Quantity': asset.qty_available,
                    'Unit Cost': f"{asset.unit_cost:,.2f}",
                    'Total Cost': f"{asset.total_cost:,.2f}",
                    'Status': asset.status or 'Active',
                    'Location': asset.location or 'N/A'
                } for asset in assets]
                
            elif report_type == 'purchases':
                purchases = PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).all()
                report_data = [{
                    'PO Number': po.order_number,
                    'Supplier': po.supplier_name,
                    'Date': po.created_at.strftime('%Y-%m-%d') if po.created_at else 'N/A',
                    'Expected Delivery': po.expected_delivery.strftime('%Y-%m-%d') if po.expected_delivery else 'N/A',
                    'Total Amount': f"{po.total_amount:,.2f}" if po.total_amount else '0.00',
                    'Status': po.status,
                    'Items': len(po.line_items) if po.line_items else 0
                } for po in purchases]
                
            elif report_type == 'suppliers':
                suppliers = Vendor.query.all()
                report_data = [{
                    'Name': vendor.name,
                    'Category': vendor.category or 'N/A',
                    'Payment Terms': vendor.payment_terms or 'N/A',
                    'Status': 'Validated' if vendor.validated else 'Pending',
                    'Created Date': vendor.created_at.strftime('%Y-%m-%d') if vendor.created_at else 'N/A'
                } for vendor in suppliers]
                
            elif report_type == 'tracking':
                assets = InventoryItem.query.filter(InventoryItem.location.isnot(None)).all()
                report_data = [{
                    'Asset Code': asset.code,
                    'Description': asset.description,
                    'Current Location': asset.location or 'N/A',
                    'Previous Location': asset.previous_location or 'N/A',
                    'Status': asset.status or 'Active',
                    'Last Update': asset.last_location_update.strftime('%Y-%m-%d %H:%M') if asset.last_location_update else 'Never',
                    'GPS': f"{asset.latitude}, {asset.longitude}" if asset.latitude and asset.longitude else 'N/A'
                } for asset in assets]
                
            elif report_type == 'spending':
                purchases = PurchaseOrder.query.filter(PurchaseOrder.total_amount.isnot(None)).all()
                report_data = [{
                    'PO Number': po.order_number,
                    'Supplier': po.supplier_name,
                    'Date': po.created_at.strftime('%Y-%m-%d') if po.created_at else 'N/A',
                    'Amount': f"{po.total_amount:,.2f}",
                    'Status': po.status
                } for po in purchases]
            
            return jsonify({'success': True, 'data': report_data}), 200
            
        except Exception as e:
            current_app.logger.error(f"Error generating report: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500

    @app.route('/procurement/reports/quick/<report_type>', methods=['GET'], endpoint='procurement.quick_report')
    @role_required([Roles.HQ_PROCUREMENT])
    def quick_report(report_type):
        try:
            report_data = []
            
            if report_type == 'inventory':
                assets = InventoryItem.query.limit(100).all()
                report_data = [{
                    'Code': asset.code,
                    'Description': asset.description,
                    'Category': asset.category or 'N/A',
                    'Quantity': asset.qty_available,
                    'Unit Cost': f"{asset.unit_cost:,.2f}",
                    'Total Cost': f"{asset.total_cost:,.2f}"
                } for asset in assets]
                
            elif report_type == 'purchases':
                purchases = PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).limit(50).all()
                report_data = [{
                    'PO Number': po.order_number,
                    'Supplier': po.supplier_name,
                    'Date': po.created_at.strftime('%Y-%m-%d') if po.created_at else 'N/A',
                    'Amount': f"{po.total_amount:,.2f}" if po.total_amount else '0.00',
                    'Status': po.status
                } for po in purchases]
                
            elif report_type == 'suppliers':
                suppliers = Vendor.query.all()
                report_data = [{
                    'Name': vendor.name,
                    'Category': vendor.category or 'N/A',
                    'Payment Terms': vendor.payment_terms or 'N/A',
                    'Status': 'Validated' if vendor.validated else 'Pending'
                } for vendor in suppliers]
            
            return jsonify({'success': True, 'data': report_data}), 200
            
        except Exception as e:
            current_app.logger.error(f"Error generating quick report: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500
# Dashboard Route
    @app.route('/procurement', endpoint='procurement.procurement_home')
    @role_required([Roles.HQ_PROCUREMENT])
    def procurement_home():
        try:
            # Asset Statistics
            total_assets = InventoryItem.query.count()
            pending_requests = ProcurementRequest.query.filter(ProcurementRequest.status == 'pending').count()
            
            # Maintenance due: count assets with a 'maintenance_due' flag or similar, else 0
            maintenance_due = 0
            if hasattr(InventoryItem, 'maintenance_due'):
                maintenance_due = InventoryItem.query.filter_by(maintenance_due=True).count()
            
            # Total purchases: all procurement requests
            total_purchases = ProcurementRequest.query.count()
            
            # Budget utilized: sum of all disbursed requests / total budget
            disbursed_sum = db.session.query(db.func.sum(ProcurementRequest.price * ProcurementRequest.qty)).filter(ProcurementRequest.status == 'disbursed').scalar() or 0
            
            # Try to get total budget from Budget model
            total_budget = db.session.query(db.func.sum(Budget.allocated_amount)).scalar() or 0
            budget_utilized = (disbursed_sum / total_budget * 100) if total_budget else 0
            
            active_suppliers = Vendor.query.filter(Vendor.validated == True).count()
            
            # Recent Purchases (last 5 purchase orders or procurement requests)
            recent_purchases = PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).limit(5).all()
            
            # If no purchase orders, fall back to procurement requests
            if not recent_purchases:
                recent_procurements = ProcurementRequest.query.order_by(ProcurementRequest.created_at.desc()).limit(5).all()
                recent_purchases = [{
                    'id': pr.id,
                    'order_number': f'PR-{pr.id}',
                    'supplier_name': 'Pending Assignment',
                    'total_amount': pr.price * pr.qty,
                    'status': pr.status,
                    'created_at': pr.created_at,
                    'days_ago': (datetime.utcnow() - pr.created_at).days if pr.created_at else 0
                } for pr in recent_procurements]
            else:
                recent_purchases = [{
                    'id': po.id,
                    'order_number': po.order_number,
                    'supplier_name': po.supplier_name,
                    'total_amount': po.total_amount,
                    'status': po.status,
                    'created_at': po.created_at,
                    'days_ago': (datetime.utcnow() - po.created_at).days if po.created_at else 0
                } for po in recent_purchases]
            
            # Upcoming Maintenance (simulate with low stock items or recent inventory items)
            # Since we don't have a maintenance table, we'll show items that might need attention
            maintenance_items = InventoryItem.query.filter(InventoryItem.qty_available < 10).order_by(InventoryItem.qty_available).limit(5).all()
            
            upcoming_maintenance = [{
                'id': item.id,
                'asset_name': item.description,
                'code': item.code,
                'qty_available': item.qty_available,
                'priority': 'High' if item.qty_available < 5 else 'Medium',
                'days_until': (5 - item.qty_available) if item.qty_available < 5 else 10
            } for item in maintenance_items]
            
            summary = {
                'total_assets': total_assets,
                'pending_requests': pending_requests,
                'maintenance_due': maintenance_due,
                'total_purchases': total_purchases,
                'budget_utilized': round(budget_utilized, 2),
                'active_suppliers': active_suppliers
            }
            
            return render_template('procurement/index.html', 
                                 summary=summary,
                                 recent_purchases=recent_purchases,
                                 upcoming_maintenance=upcoming_maintenance)
        except Exception as e:
            current_app.logger.error(f"Procurement dashboard error: {str(e)}")
            flash("Error loading procurement dashboard", "error")
            return render_template('error.html'), 500

# Asset Management Routes
    @app.route('/procurement/assets', endpoint='procurement.assets')
    @role_required([Roles.HQ_PROCUREMENT])
    def assets():
        try:
            assets = InventoryItem.query.order_by(InventoryItem.created_at.desc()).all()
            categories = list(set([a.category for a in assets if a.category]))
            
            # Maintenance: count assets with a 'maintenance_due' flag or similar
            maintenance = 0
            retired = 0
            if hasattr(InventoryItem, 'maintenance_due'):
                maintenance = InventoryItem.query.filter_by(maintenance_due=True).count()
            if hasattr(InventoryItem, 'status'):
                retired = InventoryItem.query.filter(InventoryItem.status.ilike('%retired%')).count()
            
            stats = {
                'total': len(assets),
                'active': len([a for a in assets if (not hasattr(a, 'status') or (a.status and a.status.lower() == 'active')) and a.qty_available > 0]),
                'maintenance': maintenance,
                'retired': retired
            }
            
            # Count items per category
            categories_data = []
            for cat in categories:
                count = InventoryItem.query.filter_by(category=cat).count()
                categories_data.append({'id': len(categories_data)+1, 'name': cat, 'count': count})
            
            # Prepare assets list for display
            assets_list = [{
                'id': asset.id,
                'code': asset.code,
                'description': asset.description,
                'category': asset.category,
                'group': asset.group,
                'qty_available': asset.qty_available,
                'uom': asset.uom,
                'unit_cost': asset.unit_cost,
                'total_cost': asset.total_cost,
                'status': 'Active' if asset.qty_available > 0 else 'Out of Stock',
                'created_at': asset.created_at
            } for asset in assets]
            
            assets_data = {
                'stats': stats, 
                'categories': categories_data,
                'assets': assets_list
            }
            return render_template('procurement/assets/index.html', data=assets_data)
        except Exception as e:
            current_app.logger.error(f"Asset management error: {str(e)}")
            flash("Error loading assets", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/categories/add', methods=['POST'], endpoint='procurement.add_category')
    @role_required([Roles.HQ_PROCUREMENT])
    def add_category():
        """Add a new category (creates a placeholder item with the category)"""
        try:
            category_name = request.form.get('category_name', '').strip()
            
            if not category_name:
                flash("Category name is required", "error")
                return redirect(url_for('procurement.assets'))
            
            # Check if category already exists
            existing = InventoryItem.query.filter_by(category=category_name).first()
            if existing:
                flash(f"Category '{category_name}' already exists", "info")
                return redirect(url_for('procurement.assets'))
            
            # Create a placeholder item to establish the category
            # This will be used until proper category table is implemented
            placeholder_code = f"CAT-{category_name.upper().replace(' ', '-')}"
            placeholder = InventoryItem(
                code=placeholder_code,
                description=f"Category placeholder for {category_name}",
                category=category_name,
                qty_available=0,
                uom='n/a',
                unit_cost=0,
                total_cost=0
            )
            
            db.session.add(placeholder)
            db.session.commit()
            
            current_app.logger.info(f"New category created: {category_name}")
            flash(f"Category '{category_name}' created successfully", "success")
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating category: {str(e)}", exc_info=True)
            flash("Error creating category", "error")
        
        return redirect(url_for('procurement.assets'))

    @app.route('/procurement/categories/delete/<category_name>', methods=['POST'], endpoint='procurement.delete_category')
    @role_required([Roles.HQ_PROCUREMENT])
    def delete_category(category_name):
        """Delete a category and all its items"""
        try:
            # Get all items in this category
            items = InventoryItem.query.filter_by(category=category_name).all()
            
            if not items:
                return jsonify({'error': 'Category not found'}), 404
            
            # Delete all items in the category
            for item in items:
                db.session.delete(item)
            
            db.session.commit()
            current_app.logger.info(f"Category deleted: {category_name} ({len(items)} items)")
            return jsonify({'status': 'success', 'message': f'Category "{category_name}" and {len(items)} item(s) deleted successfully'})
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Delete category error: {str(e)}")
            return jsonify({'error': str(e)}), 500

# Settings Route

    @app.route('/procurement/settings', endpoint='procurement.settings')
    @role_required([Roles.HQ_PROCUREMENT])
    def settings():
        try:
            settings_obj = Settings.query.first()
            if not settings_obj:
            # Create default settings if not present
                settings_obj = Settings()
                db.session.add(settings_obj)
                db.session.commit()
            settings_data = {
                'user_settings': {
                    'notifications': {
                        'email_alerts': settings_obj.email_alerts,
                        'browser_notifications': settings_obj.browser_notifications,
                        'sms_alerts': settings_obj.sms_alerts
                    },
                    'display': {
                        'theme': settings_obj.theme,
                        'language': settings_obj.language,
                        'timezone': settings_obj.timezone
                    }
                },
                'system_settings': {
                    'approval_thresholds': {
                        'purchase_limit': settings_obj.purchase_limit,
                        'asset_value_limit': settings_obj.asset_value_limit
                    },
                    'reorder_points': {
                        'minimum_stock': settings_obj.minimum_stock,
                        'warning_threshold': settings_obj.warning_threshold
                    },
                    'workflow': {
                        'require_approval': settings_obj.require_approval,
                        'auto_reorder': settings_obj.auto_reorder
                    }
                }
            }
            return render_template('procurement/settings/index.html', data=settings_data)
        except Exception as e:
            current_app.logger.error(f"Settings error: {str(e)}")
            flash("Error loading settings", "error")
            return render_template('error.html'), 500

    @app.route('/procurement/settings/update', methods=['POST'], endpoint='procurement.update_settings')
    @role_required([Roles.HQ_PROCUREMENT])
    def update_settings():
        try:
            data = request.get_json()
            settings_obj = Settings.query.first()
            if not settings_obj:
                settings_obj = Settings()
                db.session.add(settings_obj)
        # User settings
            user_settings = data.get('user_settings', {})
            notifications = user_settings.get('notifications', {})
            display = user_settings.get('display', {})
            settings_obj.email_alerts = notifications.get('email_alerts', settings_obj.email_alerts)
            settings_obj.browser_notifications = notifications.get('browser_notifications', settings_obj.browser_notifications)
            settings_obj.sms_alerts = notifications.get('sms_alerts', settings_obj.sms_alerts)
            settings_obj.theme = display.get('theme', settings_obj.theme)
            settings_obj.language = display.get('language', settings_obj.language)
            settings_obj.timezone = display.get('timezone', settings_obj.timezone)
        # System settings
            system_settings = data.get('system_settings', {})
            approval_thresholds = system_settings.get('approval_thresholds', {})
            reorder_points = system_settings.get('reorder_points', {})
            workflow = system_settings.get('workflow', {})
            settings_obj.purchase_limit = approval_thresholds.get('purchase_limit', settings_obj.purchase_limit)
            settings_obj.asset_value_limit = approval_thresholds.get('asset_value_limit', settings_obj.asset_value_limit)
            settings_obj.minimum_stock = reorder_points.get('minimum_stock', settings_obj.minimum_stock)
            settings_obj.warning_threshold = reorder_points.get('warning_threshold', settings_obj.warning_threshold)
            settings_obj.require_approval = workflow.get('require_approval', settings_obj.require_approval)
            settings_obj.auto_reorder = workflow.get('auto_reorder', settings_obj.auto_reorder)
            db.session.commit()
            return jsonify({'status': 'success', 'message': 'Settings updated successfully'})
        except SQLAlchemyError as e:
            db.session.rollback()
            current_app.logger.error(f"Update settings error: {str(e)}")
            return jsonify({'error': str(e)}), 500
        except Exception as e:
            current_app.logger.error(f"Update settings error: {str(e)}")
            return jsonify({'error': str(e)}), 500
    
    
    @app.route('/procurement/logout', endpoint='procurement.logout')
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT])
    def procurement_logout():
        logout_user()
        session.clear()
        flash('You have been logged out successfully.', 'success')
        return redirect(url_for('login'))
    
    # Profile Route
    @app.route('/procurement/profile', endpoint='procurement.profile')
    @role_required([Roles.HQ_PROCUREMENT])
    def procurement_profile():
        try:
            user_id = session.get('user_id')
            user = User.query.get(user_id) if user_id else None
            if not user:
                flash("User not found", "error")
                return render_template('error.html'), 404
            
            # Calculate actual statistics from database
            # Purchase Orders created
            purchases_initiated = PurchaseOrder.query.count()
            
            # Total inventory items
            assets_managed = InventoryItem.query.count()
            
            # Total validated suppliers
            suppliers_handled = Vendor.query.filter_by(validated=True).count()
            
            # Reports - count can be based on various report generations
            reports_generated = Report.query.count() if hasattr(db.Model, 'Report') else 0
            
            # Recent Activity - Get recent purchase orders
            recent_activity = []
            recent_pos = PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).limit(5).all()
            for po in recent_pos:
                recent_activity.append({
                    'action': f'Purchase Order: {po.order_number}',
                    'reference': f'{po.supplier_name}',
                    'timestamp': po.created_at.strftime('%b %d, %Y %H:%M') if po.created_at else 'N/A',
                    'status': po.status,
                    'icon': 'bx-cart'
                })
            
            # Add recent inventory updates
            recent_items = InventoryItem.query.order_by(InventoryItem.updated_at.desc()).limit(3).all()
            for item in recent_items:
                recent_activity.append({
                    'action': f'Inventory Update: {item.code}',
                    'reference': item.description[:50],
                    'timestamp': item.updated_at.strftime('%b %d, %Y %H:%M') if item.updated_at else 'N/A',
                    'status': 'Updated',
                    'icon': 'bx-package'
                })
            
            # Sort by timestamp and limit to 8 most recent
            recent_activity.sort(key=lambda x: x['timestamp'], reverse=True)
            recent_activity = recent_activity[:8]
            
            # Get role display name
            role_display = user.role.replace('_', ' ').title()
            
            profile_data = {
                'user': {
                    'name': user.name,
                    'email': user.email,
                    'role': role_display,
                    'department': 'Procurement Department',
                    'joined_date': user.created_at.strftime('%B %d, %Y') if user.created_at else 'N/A',
                    'status': 'Verified' if user.is_verified else 'Pending Verification'
                },
                'stats': {
                    'purchases_initiated': purchases_initiated,
                    'assets_managed': assets_managed,
                    'suppliers_handled': suppliers_handled,
                    'reports_generated': reports_generated
                },
                'recent_activity': recent_activity
            }
            return render_template('procurement/profile/index.html', data=profile_data)
        except Exception as e:
            current_app.logger.error(f"Profile error: {str(e)}")
            flash("Error loading profile data", "error")
            return render_template('error.html'), 500
    
# --- Inventory CRUD Endpoints ---
    @app.route('/procurement/inventory', methods=['GET'], endpoint='procurement.get_inventory')
    @role_required([Roles.HQ_PROCUREMENT, Roles.PROCUREMENT_OFFICER])
    def get_inventory():
        # Check if it's an AJAX/API request by checking Accept header
        if request.headers.get('Accept', '').startswith('application/json'):
            items = InventoryItem.query.all()
            result = [
                {
                    'id': i.id,
                    'code': i.code,
                    'description': i.description,
                    'group': i.group,
                    'category': i.category,
                    'qty_available': i.qty_available,
                    'unit_cost': i.unit_cost,
                    'uom': i.uom,
                    'total_cost': i.total_cost,
                    'price_change': i.price_change
                } for i in items
            ]
            return jsonify(result)
        else:
            # Render the HTML page for browser requests
            return render_template('procurement/inventory/index.html')

    @app.route('/procurement/inventory', methods=['POST'], endpoint='procurement.create_inventory_item')
    @role_required([Roles.HQ_PROCUREMENT, Roles.PROCUREMENT_OFFICER])
    def create_inventory_item():
        data = request.get_json()
        item = InventoryItem(
            code=data.get('code'),
            description=data.get('description'),
            group=data.get('group'),
            category=data.get('category'),
            qty_available=data.get('qty_available', 0.0),
            unit_cost=data.get('unit_cost'),
            uom=data.get('uom'),
            total_cost=data.get('total_cost', 0.0),
            price_change=data.get('price_change', 0.0)
        )
        db.session.add(item)
        db.session.commit()
        return jsonify({'message': 'Inventory item created', 'id': item.id}), 201

    @app.route('/procurement/inventory/<int:item_id>', methods=['PUT'], endpoint='procurement.update_inventory_item')
    @role_required([Roles.HQ_PROCUREMENT, Roles.PROCUREMENT_OFFICER])
    def update_inventory_item(item_id):
        item = InventoryItem.query.get_or_404(item_id)
        data = request.get_json()
        item.code = data.get('code', item.code)
        item.description = data.get('description', item.description)
        item.group = data.get('group', item.group)
        item.category = data.get('category', item.category)
        item.qty_available = data.get('qty_available', item.qty_available)
        item.unit_cost = data.get('unit_cost', item.unit_cost)
        item.uom = data.get('uom', item.uom)
        item.total_cost = data.get('total_cost', item.total_cost)
        item.price_change = data.get('price_change', item.price_change)
        db.session.commit()
        return jsonify({'message': 'Inventory item updated'})

    @app.route('/procurement/inventory/<int:item_id>', methods=['DELETE'], endpoint='procurement.delete_inventory_item')
    @role_required([Roles.HQ_PROCUREMENT, Roles.PROCUREMENT_OFFICER])
    def delete_inventory_item(item_id):
        item = InventoryItem.query.get_or_404(item_id)
        db.session.delete(item)
        db.session.commit()
        return jsonify({'message': 'Inventory item deleted'})
# --- Vendor Creation & Validation Endpoint ---
    @app.route('/procurement/vendor', methods=['POST'], endpoint='procurement.create_vendor')
    @role_required([Roles.HQ_PROCUREMENT, Roles.PROCUREMENT_OFFICER])
    def create_vendor():
        data = request.get_json()
        name = data.get('name')
        category = data.get('category')
        payment_terms = data.get('payment_terms')
        existing = Vendor.query.filter_by(name=name, category=category).first()
        if existing:
            return jsonify({'message': 'Vendor already exists', 'id': existing.id, 'validated': existing.validated}), 200
        vendor = Vendor(
            name=name,
            category=category,
            payment_terms=payment_terms,
            validated=True  # Assume validated on creation for now
        )
        db.session.add(vendor)
        db.session.commit()
        return jsonify({'message': 'Vendor created', 'id': vendor.id, 'validated': vendor.validated}), 201
# --- Procurement Requisition Endpoint ---
    @app.route('/procurement/requisition', methods=['POST'], endpoint='procurement.create_requisition')
    @role_required([Roles.HQ_PROCUREMENT, Roles.PROJECT_MANAGER])
    def create_requisition():
        data = request.get_json()
        req = ProcurementRequest(
            project_id=data.get('project_id'),
            item_name=data.get('item_name'),
            price=data.get('price'),
            qty=data.get('qty'),
            unit=data.get('unit'),
            status='pending',
            current_approver='Procurement Manager',
            created_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )
        db.session.add(req)
        db.session.commit()
        return jsonify({'message': 'Requisition request created', 'id': req.id}), 201


    # ============================================================================
    # ROUTES FROM QUARRY.PY
    # ============================================================================

    from io import BytesIO


# Dashboard Home
    @app.route('/quarry', endpoint='quarry.quarry_home')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def quarry_home():
        try:
            summary = {
                'active_equipment': 18,
                'inactive_equipment': 4,
                'total_workers': 95,
                'shifts_today': 3,
                'materials_extracted': "1,250 tons",
                'materials_dispatched': "940 tons",
                'pending_orders': 12,
                'safety_incidents': 0
            }
            return render_template('quarry/index.html', summary=summary)
        except Exception as e:
            current_app.logger.error(f"Quarry dashboard error: {str(e)}")
            flash("Error loading quarry dashboard", "error")
            return render_template('error.html'), 500


# Equipment Management
    @app.route('/quarry/equipment', endpoint='quarry.equipment')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def equipment():
        try:
            equipment_data = [
                {'id': 1, 'name': 'Excavator A1', 'status': 'Active', 'last_service': '2025-08-28'},
                {'id': 2, 'name': 'Crusher C2', 'status': 'Under Maintenance', 'last_service': '2025-08-15'},
            ]
            return render_template('quarry/equipment/index.html', equipment=equipment_data)
        except Exception as e:
            current_app.logger.error(f"Equipment error: {str(e)}")
            return render_template('error.html'), 500


    @app.route('/quarry/equipment/add', methods=['GET', 'POST'], endpoint='quarry.add_equipment')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def add_equipment():
        from flask_wtf import FlaskForm
        from wtforms import StringField, SelectField, DateField
        from wtforms.validators import DataRequired, Length

        class AddEquipmentForm(FlaskForm):
            name = StringField('Equipment Name', validators=[DataRequired(), Length(max=100)])
            status = SelectField('Status', choices=[('Active', 'Active'), ('Under Maintenance', 'Under Maintenance'), ('Inactive', 'Inactive')], validators=[DataRequired()])
            last_service = DateField('Last Service Date', format='%Y-%m-%d', validators=[DataRequired()])

        form = AddEquipmentForm()
        if form.validate_on_submit():
        # Replace with actual DB logic
            equipment = {
                'id': 3,  # Example, should be auto-increment from DB
                'name': form.name.data,
                'status': form.status.data,
                'last_service': form.last_service.data.strftime('%Y-%m-%d')
            }
        # Here you would add to DB, e.g. db.session.add(equipment_model) and db.session.commit()
            flash('Equipment added successfully!', 'success')
            return redirect(url_for('quarry.equipment'))

        return render_template('quarry/equipment/add.html', form=form)


# Worker & Shift Management
    @app.route('/quarry/workers', endpoint='quarry.workers')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def workers():
        try:
            workers = [
                {'id': 1, 'name': 'John Doe', 'role': 'Loader Operator', 'shift': 'Morning'},
                {'id': 2, 'name': 'Jane Smith', 'role': 'Supervisor', 'shift': 'Evening'},
            ]
            return render_template('quarry/workers/index.html', workers=workers)
        except Exception as e:
            return render_template('error.html'), 500


# Material Production & Orders
    @app.route('/quarry/materials', endpoint='quarry.materials')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def materials():
        try:
            materials = [
                {'type': 'Granite', 'stock': 550, 'unit': 'tons'},
                {'type': 'Sand', 'stock': 320, 'unit': 'tons'},
                {'type': 'Limestone', 'stock': 380, 'unit': 'tons'},
            ]
            return render_template('quarry/materials/index.html', materials=materials)
        except Exception as e:
            return render_template('error.html'), 500


# Safety & Compliance
    @app.route('/quarry/safety', endpoint='quarry.safety')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def safety():
        try:
            safety_data = {
                'stats': {
                    'days_without_incident': 45,
                    'pending_inspections': 3,
                    'safety_score': 98,
                    'active_alerts': 0
                },
                'logs': [
                    {
                        'id': 1,
                        'timestamp': datetime.now(),
                        'incident': 'Protective gear inspection',
                        'status': 'Completed',
                        'type': 'inspection'
                    },
                    {
                        'id': 2,
                        'timestamp': datetime.now() - timedelta(days=1),
                        'incident': 'Dust control monitoring',
                        'status': 'Ongoing',
                        'type': 'monitoring'
                    }
                ]
            }
            return render_template('quarry/safety/index.html', data=safety_data)
        except Exception as e:
            current_app.logger.error(f"Safety page error: {str(e)}")
            flash("Error loading safety information", "error")
            return render_template('error.html'), 500


# Reports & Analytics
    @app.route('/quarry/reports', endpoint='quarry.reports')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def reports():
        try:
            return render_template('quarry/reports/index.html')
        except Exception as e:
            return render_template('error.html'), 500


    @app.route('/quarry/reports/generate', methods=['POST'], endpoint='quarry.generate_report')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def generate_report():
        try:
            report_type = request.form.get('type')
            start_date = request.form.get('start_date')
            end_date = request.form.get('end_date')

        # Mock report data
            report_data = [
                {"Date": "2025-09-01", "Material": "Granite", "Quantity": 250, "Unit": "tons"},
                {"Date": "2025-09-01", "Material": "Sand", "Quantity": 120, "Unit": "tons"},
            ]

            df = pd.DataFrame(report_data)
            output = BytesIO()
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                df.to_excel(writer, sheet_name='Quarry Report', index=False)
            output.seek(0)

            report_id = f"quarry_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            report_path = os.path.join(current_app.config['UPLOAD_FOLDER'], f"{report_id}.xlsx")

            with open(report_path, 'wb') as f:
                f.write(output.getvalue())

            return jsonify({'status': 'success', 'report_url': url_for('quarry.download_report', report_id=report_id)})
        except Exception as e:
            return jsonify({'status': 'error', 'message': str(e)})


    @app.route('/quarry/reports/download/<report_id>', endpoint='quarry.download_report')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def download_report(report_id):
        try:
            return send_file('path_to_report', as_attachment=True)
        except Exception as e:
            return redirect(url_for('quarry.reports'))

# Settings
    @app.route('/quarry/settings', endpoint='quarry.settings')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def settings():
        try:
            user_settings = {
                'notifications_enabled': True,
                'default_unit': 'tons',
                'report_format': 'Excel',
                'theme': 'dark'
            }
            return render_template('quarry/settings.html', settings=user_settings)
        except Exception as e:
            current_app.logger.error(f"Settings error: {str(e)}")
            flash("Error loading settings", "error")
            return render_template('error.html'), 500


# Profile
    @app.route('/quarry/profile', endpoint='quarry.profile')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def profile():
        try:
            profile_data = {
                'name': 'Michael Johnson',
                'role': 'Quarry Manager',
                'email': 'michael.johnson@quarry.com',
                'phone': '+234 800 123 4567',
                'joined': '2024-02-10',
                'last_login': datetime.now().strftime('%Y-%m-%d %H:%M')
            }
            return render_template('quarry/profile.html', profile=profile_data)
        except Exception as e:
            current_app.logger.error(f"Profile error: {str(e)}")
            flash("Error loading profile", "error")
            return render_template('error.html'), 500


# Logout
    @app.route('/quarry/logout', endpoint='quarry.logout')
    @role_required([Roles.SUPER_HQ, Roles.QUARRY_MANAGER])
    def logout():
        try:
            session.clear()
            flash("Successfully logged out", "success")
            return redirect(url_for('login'))
        except Exception as e:
            current_app.logger.error(f"Logout error: {str(e)}")
            flash("Error during logout", "error")
            return redirect(url_for('quarry.quarry_home'))



    # ============================================================================
    # ROUTES FROM FINANCE.PY
    # ============================================================================



    from sqlalchemy import func, desc, or_, and_, case
    from werkzeug.utils import secure_filename
    from io import BytesIO


# Dashboard Routes
    @app.route('/finance', endpoint='finance.finance_home')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def finance_home():
        try:
        # Get current month and year for filtering
            current_month = datetime.now().month
            current_year = datetime.now().year
        
        # Calculate previous month for comparison
            prev_month_date = datetime.now() - timedelta(days=30)
            prev_month = prev_month_date.month
            prev_year = prev_month_date.year
        
        # Enhanced financial summary
            try:
                summary = {
                    'bank_balance': db.session.execute(db.text("SELECT COALESCE(SUM(current_balance), 0) FROM bank_accounts")).scalar() or 0,
                    'monthly_expenses': db.session.query(func.sum(Expense.amount)).filter(
                        func.extract('month', Expense.date) == current_month,
                        func.extract('year', Expense.date) == current_year
                    ).scalar() or 0,
                    'prev_month_expenses': db.session.query(func.sum(Expense.amount)).filter(
                        func.extract('month', Expense.date) == prev_month,
                        func.extract('year', Expense.date) == prev_year
                    ).scalar() or 0,
                    'pending_payroll': db.session.query(func.sum(Payroll.amount)).filter(Payroll.status == 'pending').scalar() or 0,
                    'outstanding_payments': db.session.query(func.sum(Expense.amount)).filter(Expense.status == 'outstanding').scalar() or 0,
                    'total_documents': db.session.query(Document).count(),
                    'recent_uploads': db.session.query(Document).filter(Document.uploaded_at >= datetime.now() - timedelta(days=7)).count(),
                    'storage_used': f"{round(db.session.query(func.sum(Document.size)).scalar() or 0 / (1024**3), 2)}GB",
                    'pending_review': db.session.query(Document).filter(Document.status == 'pending_review').count(),
                    'total_income': 0,  # Set to 0 for now due to database migration issues
                    'cash_flow': 0  # Set to 0 for now due to database migration issues
                }
            except Exception as summary_error:
                current_app.logger.warning(f"Error calculating financial summary: {str(summary_error)}")
            # Provide default summary if database queries fail
                summary = {
                    'bank_balance': 0,
                    'monthly_expenses': 0,
                    'prev_month_expenses': 0,
                    'pending_payroll': 0,
                    'outstanding_payments': 0,
                    'total_documents': 0,
                    'recent_uploads': 0,
                    'storage_used': "0GB",
                    'pending_review': 0,
                    'total_income': 0,
                    'cash_flow': 0
                }
        
        # Recent transactions for dashboard
            try:
                recent_transactions = Transaction.query.order_by(desc(Transaction.date)).limit(10).all()
            except Exception as trans_error:
                current_app.logger.warning(f"Error fetching recent transactions: {str(trans_error)}")
                recent_transactions = []
        
        # Expense breakdown by category
            expense_categories = db.session.query(
                Expense.category, 
                func.sum(Expense.amount).label('total')
            ).filter(
                func.extract('month', Expense.date) == current_month,
                func.extract('year', Expense.date) == current_year
            ).group_by(Expense.category).all()
        
            return render_template('finance/index.html', 
                                  summary=summary, 
                                  transactions=recent_transactions,
                                  expense_categories=expense_categories)
        except Exception as e:
            current_app.logger.error(f"Finance dashboard error: {str(e)}")
            flash("Error loading finance dashboard", "error")
            return render_template('error.html'), 500

# Payroll Management
    @app.route('/finance/payroll', endpoint='finance.payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def payroll():
        try:
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 20, type=int)
            status_filter = request.args.get('status', 'all')
        
            query = Payroll.query
        
            if status_filter != 'all':
                query = query.filter(Payroll.status == status_filter)
            
            payrolls = query.order_by(desc(Payroll.created_at)).paginate(
                page=page, per_page=per_page, error_out=False
            )
        
            return render_template('finance/payroll/index.html', 
                                 payrolls=payrolls, 
                                 status_filter=status_filter)
        except Exception as e:
            current_app.logger.error(f"Payroll loading error: {str(e)}")
            flash('Error loading payroll', 'error')
            return render_template('error.html'), 500

    @app.route('/finance/payroll/<int:payroll_id>', endpoint='finance.payroll_detail')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def payroll_detail(payroll_id):
        try:
            payroll = Payroll.query.get_or_404(payroll_id)
            return render_template('finance/payroll/detail.html', payroll=payroll)
        except Exception as e:
            current_app.logger.error(f"Payroll detail error: {str(e)}")
            flash('Error loading payroll details', 'error')
            return redirect(url_for('finance.payroll'))

    @app.route('/finance/payroll/process', methods=['POST'], endpoint='finance.process_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def process_payroll():
        try:
            payroll_id = request.form.get('payroll_id')
            payroll = Payroll.query.get(payroll_id)
            if not payroll:
                return jsonify({'status': 'error', 'message': 'Payroll not found'})
        
        # Create a transaction record for the payroll
            transaction = Transaction(
                description=f"Payroll: {payroll.employee_name}",
                amount=payroll.amount,
                type='expense',
                category='payroll',
                date=datetime.now(),
                status='completed',
                reference_id=f"PAY_{payroll_id}",
                created_by=current_user.id
            )
        
            payroll.status = 'processed'
            payroll.processed_at = datetime.now()
            payroll.processed_by = current_user.id
        
            db.session.add(transaction)
            db.session.commit()
        
        # Log audit event
            audit = Audit(
                event_type='payroll_processed',
                description=f'Processed payroll for {payroll.employee_name} - ${payroll.amount}',
                user_id=current_user.id,
                ip_address=request.remote_addr
            )
            db.session.add(audit)
            db.session.commit()
        
            return jsonify({'status': 'success', 'message': 'Payroll processed successfully'})
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Payroll processing error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/payroll/create', methods=['GET', 'POST'], endpoint='finance.create_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def create_payroll():
        if request.method == 'POST':
            try:
                data = request.form
                payroll = Payroll(
                    employee_name=data.get('employee_name'),
                    employee_id=data.get('employee_id'),
                    amount=float(data.get('amount')),
                    period_start=datetime.strptime(data.get('period_start'), '%Y-%m-%d'),
                    period_end=datetime.strptime(data.get('period_end'), '%Y-%m-%d'),
                    description=data.get('description', ''),
                    status='pending',
                    created_by=current_user.id
                )
                db.session.add(payroll)
                db.session.commit()
            
                flash('Payroll entry created successfully', 'success')
                return redirect(url_for('finance.payroll'))
            except Exception as e:
                db.session.rollback()
                current_app.logger.error(f"Payroll creation error: {str(e)}")
                flash('Error creating payroll entry', 'error')
    
        return render_template('finance/payroll/create.html')

# Document Management System
    @app.route('/finance/documents', endpoint='finance.documents')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def documents():
        try:
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 20, type=int)
            doc_type = request.args.get('type', 'all')
            status_filter = request.args.get('status', 'all')
        
            query = Document.query
        
            if doc_type != 'all':
                query = query.filter(Document.document_type == doc_type)
            
            if status_filter != 'all':
                query = query.filter(Document.status == status_filter)
            
            documents = query.order_by(desc(Document.uploaded_at)).paginate(
                page=page, per_page=per_page, error_out=False
            )
        
            return render_template('finance/documents/index.html', 
                                 documents=documents,
                                 doc_type=doc_type,
                                 status_filter=status_filter)
        except Exception as e:
            current_app.logger.error(f"Documents loading error: {str(e)}")
            flash('Error loading documents', 'error')
            return render_template('error.html'), 500

    @app.route('/finance/documents/upload', methods=['POST'], endpoint='finance.upload_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def upload_document():
        try:
            if 'file' not in request.files:
                return jsonify({'status': 'error', 'message': 'No file provided'})
            
            file = request.files['file']
            if file.filename == '':
                return jsonify({'status': 'error', 'message': 'No file selected'})
            
            if file:
                filename = secure_filename(file.filename)
            # Create directory if it doesn't exist
                upload_folder = current_app.config['UPLOAD_FOLDER']
                if not os.path.exists(upload_folder):
                    os.makedirs(upload_folder)
                
                save_path = os.path.join(upload_folder, filename)
                file.save(save_path)
            
                doc = Document(
                    filename=filename, 
                    path=save_path, 
                    uploaded_at=datetime.now(), 
                    size=os.path.getsize(save_path), 
                    status='pending_review',
                    document_type=request.form.get('document_type', 'other'),
                    description=request.form.get('description', ''),
                    uploaded_by=current_user.id
                )
            
                db.session.add(doc)
                db.session.commit()
            
            # Log audit event
                audit = Audit(
                    event_type='document_uploaded',
                    description=f'Uploaded document: {filename}',
                    user_id=current_user.id,
                    ip_address=request.remote_addr
                )
                db.session.add(audit)
                db.session.commit()
            
                return jsonify({'status': 'success', 'message': 'Document uploaded successfully', 'document_id': doc.id})
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Document upload error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/documents/<int:doc_id>', endpoint='finance.document_detail')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def document_detail(doc_id):
        try:
            document = Document.query.get_or_404(doc_id)
            return render_template('finance/documents/detail.html', document=document)
        except Exception as e:
            current_app.logger.error(f"Document detail error: {str(e)}")
            flash('Error loading document details', 'error')
            return redirect(url_for('finance.documents'))

    @app.route('/finance/documents/update-status/<int:doc_id>', methods=['POST'], endpoint='finance.update_document_status')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def update_document_status(doc_id):
        try:
            document = Document.query.get_or_404(doc_id)
            new_status = request.form.get('status')
        
            if new_status not in ['pending_review', 'approved', 'rejected', 'archived']:
                return jsonify({'status': 'error', 'message': 'Invalid status'})
            
            document.status = new_status
            document.reviewed_by = current_user.id
            document.reviewed_at = datetime.now()
        
            db.session.commit()
        
            return jsonify({'status': 'success', 'message': f'Document status updated to {new_status}'})
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Document status update error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/documents/search', methods=['GET'], endpoint='finance.search_documents')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def search_documents():
        try:
            query = request.args.get('q', '')
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 20, type=int)
        
            documents = Document.query.filter(
                or_(
                    Document.filename.ilike(f'%{query}%'),
                    Document.description.ilike(f'%{query}%')
                )
            ).order_by(desc(Document.uploaded_at)).paginate(
                page=page, per_page=per_page, error_out=False
            )
        
            return jsonify({
                'documents': [doc.to_dict() for doc in documents.items],
                'total': documents.total,
                'pages': documents.pages,
                'current_page': page
            })
        except Exception as e:
            current_app.logger.error(f"Document search error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/documents/download/<int:doc_id>', endpoint='finance.download_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def download_document(doc_id):
        try:
            doc = Document.query.get_or_404(doc_id)
            if not os.path.exists(doc.path):
                flash('File not found on server', 'error')
                return redirect(url_for('finance.documents'))
            
        # Log download activity
            audit = Audit(
                event_type='document_downloaded',
                description=f'Downloaded document: {doc.filename}',
                user_id=current_user.id,
                ip_address=request.remote_addr
            )
            db.session.add(audit)
            db.session.commit()
        
            return send_file(doc.path, as_attachment=True, download_name=doc.filename)
        except Exception as e:
            current_app.logger.error(f"Document download error: {str(e)}")
            flash('Error downloading document', 'error')
            return redirect(url_for('finance.documents'))

# Audit Management
    @app.route('/finance/audit', endpoint='finance.audit')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def audit():
        try:
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 50, type=int)
            status_filter = request.args.get('status', 'all')
            category_filter = request.args.get('category', 'all')
            date_from = request.args.get('date_from')
            date_to = request.args.get('date_to')
        
            query = Audit.query
        
            # Filter by status using actual Audit model field
            if status_filter != 'all':
                query = query.filter(Audit.status == status_filter)
            
            # Filter by category (based on audit name)
            if category_filter != 'all':
                query = query.filter(Audit.name.like(f'{category_filter}%'))
            
            if date_from:
                try:
                    date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
                    query = query.filter(Audit.date >= date_from_obj)
                except ValueError:
                    pass
                
            if date_to:
                try:
                    date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
                    query = query.filter(Audit.date <= date_to_obj + timedelta(days=1))
                except ValueError:
                    pass
        
            audits = query.order_by(desc(Audit.date)).paginate(
                page=page, per_page=per_page, error_out=False
            )
        
            # Calculate stats using actual Audit model fields
            total_audits = Audit.query.count()
            pending_audits = Audit.query.filter(Audit.status == 'Pending').count()
            completed_audits = Audit.query.filter(Audit.status == 'Completed').count()
            today = datetime.now().date()
            todays_audits = Audit.query.filter(func.date(Audit.date) == today).count()
            
            # Calculate category stats
            expense_audits = Audit.query.filter(Audit.name.like('Expense%')).count()
            invoice_audits = Audit.query.filter(Audit.name.like('Invoice%')).count()
            payment_audits = Audit.query.filter(Audit.name.like('Payment%')).count()
            payroll_audits = Audit.query.filter(Audit.name.like('Payroll%')).count()
            budget_audits = Audit.query.filter(Audit.name.like('Budget%')).count()
            
            stats = {
                'total_audits': total_audits,
                'critical_events': 0,  # Placeholder since we don't have severity field
                'todays_activities': todays_audits,
                'pending_reviews': pending_audits,
                'expense_audits': expense_audits,
                'invoice_audits': invoice_audits,
                'payment_audits': payment_audits,
                'payroll_audits': payroll_audits,
                'budget_audits': budget_audits
            }
        
            return render_template('finance/audit/index.html', 
                                 audits=audits, 
                                 stats=stats,
                                 filters=request.args)
        except Exception as e:
            current_app.logger.error(f"Audit loading error: {str(e)}")
            flash('Error loading audit logs', 'error')
            return redirect(url_for('finance.finance_home'))
            return render_template('error.html'), 500

    @app.route('/finance/audit/log', methods=['POST'], endpoint='finance.log_audit')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def log_audit():
        try:
            data = request.get_json()
            if not data:
                return jsonify({'status': 'error', 'message': 'No data provided'})
            
            # Create audit using actual Audit model fields
            audit = Audit(
                name=data.get('name', 'Audit Entry'),
                date=datetime.now().date(),
                status=data.get('status', 'Pending'),
                approved_by=data.get('approved_by')
            )
            db.session.add(audit)
            db.session.commit()
        
            return jsonify({'status': 'success', 'audit_id': audit.id})
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Audit logging error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/audit/export', methods=['POST'], endpoint='finance.export_audit_logs')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def export_audit_logs():
        try:
        # Get filters from request
            filters = request.get_json() or {}
            query = Audit.query
        
            # Filter by status using actual Audit model field
            if filters.get('status') and filters['status'] != 'all':
                query = query.filter(Audit.status == filters['status'])
            
            if filters.get('date_from'):
                try:
                    date_from = datetime.strptime(filters['date_from'], '%Y-%m-%d')
                    query = query.filter(Audit.date >= date_from)
                except ValueError:
                    pass
                
            if filters.get('date_to'):
                try:
                    date_to = datetime.strptime(filters['date_to'], '%Y-%m-%d')
                    query = query.filter(Audit.date <= date_to + timedelta(days=1))
                except ValueError:
                    pass
        
            audits = query.order_by(desc(Audit.date)).all()
        
        # Create CSV instead of Excel for better compatibility
            output = BytesIO()
            writer = csv.writer(output)
        
        # Write header using actual Audit model fields
            writer.writerow(['ID', 'Name', 'Date', 'Status', 'Approved By', 'Created At'])
        
        # Write data
            for audit in audits:
                writer.writerow([
                    audit.id,
                    audit.name,
                    audit.date.strftime('%Y-%m-%d') if audit.date else '',
                    audit.status,
                    audit.approved_by or '',
                    audit.created_at.strftime('%Y-%m-%d %H:%M:%S') if audit.created_at else ''
                ])
        
            output.seek(0)
            filename = f"audit_logs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
            return send_file(
                output,
                download_name=filename,
                as_attachment=True,
                mimetype='text/csv'
            )
        except Exception as e:
            current_app.logger.error(f"Audit export error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/audit/generate-report', methods=['POST'], endpoint='finance.generate_audit_report')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def generate_audit_report():
        try:
        # Get date range from request
            data = request.get_json() or {}
            date_from = data.get('date_from')
            date_to = data.get('date_to') or datetime.now().strftime('%Y-%m-%d')
        
            query = Audit.query
        
            if date_from:
                try:
                    date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
                    query = query.filter(Audit.date >= date_from_obj)
                except ValueError:
                    pass
                
            if date_to:
                try:
                    date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
                    query = query.filter(Audit.date <= date_to_obj + timedelta(days=1))
                except ValueError:
                    pass
        
        # Generate comprehensive stats using actual Audit model fields
            total_audits = query.count()
            pending_audits = query.filter(Audit.status == 'Pending').count()
            completed_audits = query.filter(Audit.status == 'Completed').count()
            approved_audits = query.filter(Audit.status == 'Approved').count()
        
        # Status breakdown
            status_breakdown = db.session.query(
                Audit.status,
                func.count(Audit.id).label('count')
            ).filter(Audit.id.in_([a.id for a in query.all()])).group_by(Audit.status).all()
        
        # Approved by breakdown
            approved_by_breakdown = db.session.query(
                Audit.approved_by,
                func.count(Audit.id).label('count')
            ).filter(
                Audit.id.in_([a.id for a in query.all()]),
                Audit.approved_by.isnot(None)
            ).group_by(Audit.approved_by).order_by(desc('count')).all()
        
            stats = {
                'total_audits': total_audits,
                'pending_audits': pending_audits,
                'completed_audits': completed_audits,
                'approved_audits': approved_audits,
                'status_breakdown': [{'status': sb[0], 'count': sb[1]} for sb in status_breakdown],
                'approved_by': [{'approver': ab[0], 'count': ab[1]} for ab in approved_by_breakdown],
                'date_range': {
                    'from': date_from or 'Beginning',
                    'to': date_to
                }
            }
        
            return jsonify({'status': 'success', 'report': stats})
        except Exception as e:
            current_app.logger.error(f"Audit report generation error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/audit/details/<int:audit_id>', endpoint='finance.get_audit_details')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def get_audit_details(audit_id):
        try:
            audit = Audit.query.get_or_404(audit_id)
        
            # Build response using actual Audit model fields
            response = {
                'id': audit.id,
                'name': audit.name,
                'date': audit.date.strftime('%Y-%m-%d') if audit.date else None,
                'status': audit.status,
                'approved_by': audit.approved_by,
                'created_at': audit.created_at.strftime('%Y-%m-%d %H:%M:%S') if audit.created_at else None
            }
        
            return jsonify(response)
        except Exception as e:
            current_app.logger.error(f"Audit details error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

# Purchases and Expenses
    @app.route('/finance/expenses', endpoint='finance.expenses')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def expenses():
        try:
        # Debug logging
            current_app.logger.info("Starting expenses route")
        
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 20, type=int)
            status_filter = request.args.get('status', 'all')
            category_filter = request.args.get('category', 'all')
            date_from = request.args.get('date_from')
            date_to = request.args.get('date_to')
        
            current_app.logger.info(f"Filters: status={status_filter}, category={category_filter}")
        
            query = Expense.query
        
            if status_filter != 'all':
                query = query.filter(Expense.status == status_filter)
            
            if category_filter != 'all':
                query = query.filter(Expense.category == category_filter)
            
            if date_from:
                try:
                    date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
                    query = query.filter(Expense.date >= date_from_obj)
                except ValueError:
                    pass
                
            if date_to:
                try:
                    date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
                    query = query.filter(Expense.date <= date_to_obj + timedelta(days=1))
                except ValueError:
                    pass
        
            current_app.logger.info("Executing pagination query")
            expenses = query.order_by(desc(Expense.date)).paginate(
                page=page, per_page=per_page, error_out=False
            )
            current_app.logger.info(f"Found {expenses.total} expenses")
        
        # Get distinct categories for filter dropdown
            current_app.logger.info("Getting categories")
            categories = db.session.query(Expense.category).distinct().all()
            categories = [c[0] for c in categories if c[0]]
            current_app.logger.info(f"Found {len(categories)} categories: {categories}")
        
        # Calculate expense summary statistics
            current_month = datetime.now().month
            current_year = datetime.now().year
            current_app.logger.info(f"Calculating stats for {current_month}/{current_year}")
        
        # Total expenses
            total_expenses = db.session.query(func.sum(Expense.amount)).scalar() or 0
            total_count = db.session.query(func.count(Expense.id)).scalar() or 0
        
        # Pending expenses
            pending_amount = db.session.query(func.sum(Expense.amount)).filter(Expense.status == 'pending').scalar() or 0
            pending_count = db.session.query(func.count(Expense.id)).filter(Expense.status == 'pending').scalar() or 0
        
        # Monthly expenses
            monthly_expenses = db.session.query(func.sum(Expense.amount)).filter(
                func.extract('month', Expense.date) == current_month,
                func.extract('year', Expense.date) == current_year
            ).scalar() or 0
            monthly_count = db.session.query(func.count(Expense.id)).filter(
                func.extract('month', Expense.date) == current_month,
                func.extract('year', Expense.date) == current_year
            ).scalar() or 0
        
        # Budget calculations
            total_budget = db.session.query(func.sum(Budget.allocated_amount)).scalar() or 0
            budget_remaining = total_budget - total_expenses
        
            current_app.logger.info(f"Stats calculated: total={total_expenses}, pending={pending_amount}, budget={total_budget}")
        
            expense_summary = {
                'total_expenses': total_expenses,
                'total_count': total_count,
                'pending_amount': pending_amount,
                'pending_count': pending_count,
                'monthly_expenses': monthly_expenses,
                'monthly_count': monthly_count,
                'total_budget': total_budget,
                'budget_remaining': budget_remaining
            }
        
            current_app.logger.info("Rendering template")
            return render_template('finance/financial/expenses.html', 
                                 expenses=expenses,
                                 status_filter=status_filter,
                                 category_filter=category_filter,
                                 categories=categories,
                                 filters=request.args,
                                 expense_summary=expense_summary)
        except Exception as e:
            error_details = traceback.format_exc()
            current_app.logger.error(f"Expenses loading error: {str(e)}\n{error_details}")
            flash(f'Error loading expenses: {str(e)}', 'error')
            # Return to main finance page with proper context
            return redirect(url_for('finance.finance_home'))

    @app.route('/finance/expenses/add', methods=['POST'], endpoint='finance.add_expense')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def add_expense():
        try:
        # Handle both form data and JSON
            data = request.get_json() if request.is_json else request.form
        
        # Validate required fields
            required_fields = ['description', 'amount', 'date', 'category']
            missing_fields = [field for field in required_fields if not data.get(field)]
            if missing_fields:
                return jsonify({
                    'status': 'error', 
                    'message': f'Missing required fields: {", ".join(missing_fields)}'
                }), 400
            
        # Create new expense
            expense = Expense(
                description=data.get('description'),
                amount=float(data.get('amount')),
                category=data.get('category'),
                date=datetime.strptime(data.get('date'), '%Y-%m-%d'),
                status='pending',  # All new expenses start as pending
                user_id=current_user.id
            )
        
            db.session.add(expense)
            db.session.commit()
        
        # Log audit event - using correct Audit model fields
            audit = Audit(
                name=f'Expense Added: {expense.description}',
                date=datetime.now(timezone.utc).date(),
                status='Completed',
                approved_by=current_user.name
            )
            db.session.add(audit)
            db.session.commit()
        
            return jsonify({
                'status': 'success', 
                'message': 'Expense added successfully and is pending approval', 
                'expense_id': expense.id
            })
        
        except ValueError as e:
            return jsonify({'status': 'error', 'message': 'Invalid amount or date format'}), 400
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Expense addition error: {str(e)}")
            return jsonify({'status': 'error', 'message': f'Failed to add expense: {str(e)}'}), 500

    @app.route('/finance/expenses/update-status/<int:expense_id>', methods=['POST'], endpoint='finance.update_expense_status')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def update_expense_status(expense_id):
        try:
            expense = Expense.query.get_or_404(expense_id)
        
        # Handle both JSON and form data
            data = request.get_json() if request.is_json else request.form
            new_status = data.get('status')
        
            if new_status not in ['pending', 'approved', 'paid', 'rejected']:
                return jsonify({'status': 'error', 'message': 'Invalid status'}), 400
            
            old_status = expense.status
            expense.status = new_status
        
            db.session.commit()
        
        # Log audit event - using correct Audit model fields
            audit = Audit(
                name=f'Expense Status Updated: {expense.description}',
                date=datetime.now(timezone.utc).date(),
                status='Completed',
                approved_by=current_user.name
            )
            db.session.add(audit)
            db.session.commit()
        
            return jsonify({
                'status': 'success', 
                'message': f'Expense {new_status} successfully',
                'new_status': new_status
            })
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Expense status update error: {str(e)}")
            return jsonify({'status': 'error', 'message': f'Failed to update status: {str(e)}'}), 500

    @app.route('/finance/expenses/categories', endpoint='finance.expense_categories')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def expense_categories():
        try:
            categories = db.session.query(Expense.category).distinct().all()
            return jsonify([c[0] for c in categories if c[0]])
        except Exception as e:
            current_app.logger.error(f"Expense categories error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/expenses/<int:expense_id>/delete', methods=['POST'], endpoint='finance.delete_expense')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def delete_expense(expense_id):
        """Delete an expense"""
        try:
            expense = Expense.query.get_or_404(expense_id)
            db.session.delete(expense)
            db.session.commit()
            flash('Expense deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting expense: {str(e)}', 'error')
        
        return redirect(url_for('finance.expenses'))

    @app.route('/finance/expenses/receipt/<int:expense_id>', methods=['GET', 'POST'], endpoint='finance.expense_receipt')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def expense_receipt(expense_id):
        try:
            expense = Expense.query.get_or_404(expense_id)
        
            if request.method == 'POST':
                if 'receipt' not in request.files:
                    return jsonify({'status': 'error', 'message': 'No file provided'})
                
                file = request.files['receipt']
                if file.filename == '':
                    return jsonify({'status': 'error', 'message': 'No file selected'})
                
                if file:
                    filename = secure_filename(file.filename)
                    upload_folder = current_app.config['UPLOAD_FOLDER']
                    if not os.path.exists(upload_folder):
                        os.makedirs(upload_folder)
                    
                    save_path = os.path.join(upload_folder, f"expense_{expense_id}_{filename}")
                    file.save(save_path)
                
                    expense.receipt_path = save_path
                    db.session.commit()
                
                # Log audit event - using correct Audit model fields
                    audit = Audit(
                        name=f'Receipt Uploaded: {expense.description}',
                        date=datetime.now(timezone.utc).date(),
                        status='Completed',
                        approved_by=current_user.name
                    )
                    db.session.add(audit)
                    db.session.commit()
                
                    return jsonify({'status': 'success', 'message': 'Receipt uploaded successfully'})
        
            return render_template('finance/financial/expense_receipt.html', expense=expense)
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Expense receipt error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/expenses/analysis', endpoint='finance.expense_analysis')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def expense_analysis():
        try:
        # Get date range from request or default to current year
            year = request.args.get('year', datetime.now().year, type=int)
        
        # Monthly expenses for the selected year
            monthly_expenses = db.session.query(
                func.extract('month', Expense.date).label('month'),
                func.sum(Expense.amount).label('total')
            ).filter(
                func.extract('year', Expense.date) == year,
                Expense.status == 'paid'
            ).group_by('month').order_by('month').all()
        
        # Expenses by category for the selected year
            category_expenses = db.session.query(
                Expense.category,
                func.sum(Expense.amount).label('total')
            ).filter(
                func.extract('year', Expense.date) == year,
                Expense.status == 'paid'
            ).group_by(Expense.category).order_by(desc('total')).all()
        
        # Year-over-year comparison
            prev_year = year - 1
            current_year_total = db.session.query(func.sum(Expense.amount)).filter(
                func.extract('year', Expense.date) == year,
                Expense.status == 'paid'
            ).scalar() or 0
        
            prev_year_total = db.session.query(func.sum(Expense.amount)).filter(
                func.extract('year', Expense.date) == prev_year,
                Expense.status == 'paid'
            ).scalar() or 0
        
            yoy_change = 0
            if prev_year_total > 0:
                yoy_change = ((current_year_total - prev_year_total) / prev_year_total) * 100
        
            analysis = {
                'monthly_expenses': [{'month': int(me[0]), 'total': float(me[1])} for me in monthly_expenses],
                'category_expenses': [{'category': ce[0] or 'Uncategorized', 'total': float(ce[1])} for ce in category_expenses],
                'yearly_totals': {
                    'current_year': current_year_total,
                    'prev_year': prev_year_total,
                    'yoy_change': yoy_change
                },
                'selected_year': year
            }
        
            return render_template('finance/financial/expense_analysis.html', analysis=analysis)
        except Exception as e:
            current_app.logger.error(f"Expense analysis error: {str(e)}")
            flash('Error loading expense analysis', 'error')
            return redirect(url_for('finance.expenses'))

# Reports and Analytics
    @app.route('/finance/reports', endpoint='finance.reports')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def reports():
        try:
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 10, type=int)
            report_type = request.args.get('type', 'all')
        
            query = Report.query
        
            if report_type != 'all':
                query = query.filter(Report.report_type == report_type)
            
            reports = query.order_by(desc(Report.date)).paginate(
                page=page, per_page=per_page, error_out=False
            )
        
            return render_template('finance/reports/index.html', 
                                 reports=reports,
                                 report_type=report_type)
        except Exception as e:
            current_app.logger.error(f"Reports loading error: {str(e)}")
            flash('Error loading reports', 'error')
            return render_template('error.html'), 500

    @app.route('/finance/api/financial-summary', endpoint='finance.financial_summary')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def financial_summary():
        try:
            month = request.args.get('month', datetime.now().month, type=int)
            year = request.args.get('year', datetime.now().year, type=int)
            start_date = datetime(year, month, 1)
            if month == 12:
                end_date = datetime(year + 1, 1, 1) - timedelta(days=1)
            else:
                end_date = datetime(year, month + 1, 1) - timedelta(days=1)

        # Completed income/expense
            total_income = db.session.query(func.sum(Transaction.amount)).filter(
                Transaction.type == 'income',
                Transaction.status == 'completed',
                Transaction.date >= start_date,
                Transaction.date <= end_date
            ).scalar() or 0
            total_expense = db.session.query(func.sum(Transaction.amount)).filter(
                Transaction.type == 'expense',
                Transaction.status == 'completed',
                Transaction.date >= start_date,
                Transaction.date <= end_date
            ).scalar() or 0

        # Outstanding income/expense
            outstanding_income = db.session.query(func.sum(Transaction.amount)).filter(
                Transaction.type == 'income',
                Transaction.status == 'pending',
                Transaction.date >= start_date,
                Transaction.date <= end_date
            ).scalar() or 0
            outstanding_expense = db.session.query(func.sum(Transaction.amount)).filter(
                Transaction.type == 'expense',
                Transaction.status == 'pending',
                Transaction.date >= start_date,
                Transaction.date <= end_date
            ).scalar() or 0

        # Cash flow
            cash_flow = total_income - total_expense

        # Expense breakdown by category (for Chart.js)
            category_breakdown = db.session.query(
                Transaction.category,
                func.sum(Transaction.amount).label('total')
            ).filter(
                Transaction.type == 'expense',
                Transaction.status == 'completed',
                Transaction.date >= start_date,
                Transaction.date <= end_date
            ).group_by(Transaction.category).all()
            expense_labels = [c[0] or 'Uncategorized' for c in category_breakdown]
            expense_data = [float(c[1]) for c in category_breakdown]

        # Income breakdown by category (for Chart.js)
            income_breakdown = db.session.query(
                Transaction.category,
                func.sum(Transaction.amount).label('total')
            ).filter(
                Transaction.type == 'income',
                Transaction.status == 'completed',
                Transaction.date >= start_date,
                Transaction.date <= end_date
            ).group_by(Transaction.category).all()
            income_labels = [c[0] or 'Uncategorized' for c in income_breakdown]
            income_data = [float(c[1]) for c in income_breakdown]

        # Monthly trend for Chart.js (income/expense per day)
            days_in_month = (end_date - start_date).days + 1
            daily_income = [0] * days_in_month
            daily_expense = [0] * days_in_month
            for day in range(days_in_month):
                day_date = start_date + timedelta(days=day)
                income = db.session.query(func.sum(Transaction.amount)).filter(
                    Transaction.type == 'income',
                    Transaction.status == 'completed',
                    func.date(Transaction.date) == day_date.date()
                ).scalar() or 0
                expense = db.session.query(func.sum(Transaction.amount)).filter(
                    Transaction.type == 'expense',
                    Transaction.status == 'completed',
                    func.date(Transaction.date) == day_date.date()
                ).scalar() or 0
                daily_income[day] = float(income)
                daily_expense[day] = float(expense)
            daily_labels = [(start_date + timedelta(days=day)).strftime('%Y-%m-%d') for day in range(days_in_month)]

            summary = {
                'month': month,
                'year': year,
                'total_income': total_income,
                'total_expense': total_expense,
                'outstanding_income': outstanding_income,
                'outstanding_expense': outstanding_expense,
                'cash_flow': cash_flow,
                'expense_chart': {
                    'labels': expense_labels,
                    'datasets': [{
                        'label': 'Expenses by Category',
                        'data': expense_data
                    }]
                },
                'income_chart': {
                    'labels': income_labels,
                    'datasets': [{
                        'label': 'Income by Category',
                        'data': income_data
                    }]
                },
                'trend_chart': {
                    'labels': daily_labels,
                    'datasets': [
                        {'label': 'Daily Income', 'data': daily_income},
                        {'label': 'Daily Expense', 'data': daily_expense}
                    ]
                }
            }
            return jsonify({'status': 'success', 'summary': summary})
        except Exception as e:
            current_app.logger.error(f"Financial summary error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/finance/bank-reconciliation', endpoint='finance.bank_reconciliation')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def bank_reconciliation():
        try:
        # Get all active bank accounts using actual database schema
            bank_accounts = BankAccount.query.filter_by(is_active=True).all()
        
        # Calculate total balances
            total_bank_balance = sum(acc.current_balance for acc in bank_accounts) if bank_accounts else 0
            total_book_balance = sum(acc.book_balance for acc in bank_accounts) if bank_accounts else 0
            total_difference = total_bank_balance - total_book_balance
        
        # Get recent reconciliations using actual schema (account_name, statement_date, balance, status)
            recent_reconciliations_raw = db.session.execute(
                db.text("SELECT * FROM bank_reconciliations ORDER BY created_at DESC LIMIT 10")
            ).fetchall()
        
        # Transform the raw data to match template expectations
            recent_reconciliations = []
            for row in recent_reconciliations_raw:
                try:
                # Handle date conversion properly
                    if isinstance(row[2], str):  # statement_date
                        reconciliation_date = datetime.strptime(row[2], '%Y-%m-%d')
                    else:
                        reconciliation_date = row[2]
                
                    recent_reconciliations.append({
                        'id': row[0],
                        'account_name': row[1],
                        'reconciliation_date': reconciliation_date,
                        'statement_balance': row[3],  # balance column
                        'book_balance': row[3],       # Using same for now
                        'difference': 0,
                        'status': row[4],
                        'bank_account': {'account_name': row[1]}
                    })
                except Exception as date_error:
                    current_app.logger.warning(f"Error processing reconciliation date: {date_error}")
                # Skip this row if date processing fails
                    continue
        
        # Create account summaries with actual data
            account_summaries = []
            for account in bank_accounts:
            # Count unreconciled transactions (assume we'll track this via status)
                unreconciled_count = 0  # For now, since the schema doesn't match
            
                summary = {
                    'account': account,
                    'difference': account.current_balance - account.book_balance,
                    'unreconciled_count': unreconciled_count
                }
                account_summaries.append(summary)
        
        # Get some actual expenses to show financial activity
            recent_expenses = Expense.query.order_by(Expense.date.desc()).limit(5).all()
            pending_transactions_count = len(recent_expenses)  # Use expenses as proxy for now
        
            reconciliation_data = {
                'total_bank_balance': total_bank_balance,
                'total_book_balance': total_book_balance,
                'total_difference': total_difference,
                'pending_transactions_count': pending_transactions_count,
                'account_summaries': account_summaries,
                'recent_reconciliations': recent_reconciliations,
                'bank_accounts': bank_accounts,
                'recent_expenses': recent_expenses  # Add this to show actual financial data
            }
        
        # Get actual expenses and financial metrics for more comprehensive data
            total_expenses_this_month = db.session.query(func.sum(Expense.amount)).filter(
                func.extract('month', Expense.date) == datetime.now().month,
                func.extract('year', Expense.date) == datetime.now().year
            ).scalar() or 0
        
            pending_expenses = Expense.query.filter(Expense.status == 'pending').count()
            reconciliation_data['total_expenses_this_month'] = total_expenses_this_month
            reconciliation_data['pending_expenses'] = pending_expenses
        
            flash(f"Bank Reconciliation loaded with REAL DATA: {len(bank_accounts)} accounts ({total_bank_balance:,.2f} total), {len(recent_reconciliations)} reconciliations, {len(recent_expenses)} recent expenses ({total_expenses_this_month:,.2f} this month)", "success")
            return render_template('finance/bank_reconciliation.html', datetime=datetime, **reconciliation_data)
        
        except Exception as e:
            current_app.logger.error(f"Bank reconciliation error: {str(e)}")
            flash("Error loading bank reconciliation page", "error")
            return redirect(url_for('finance.finance_home'))

# Bank Account Management Routes (simplified for existing schema)
    @app.route('/finance/bank-reconciliation/create-account', methods=['POST'], endpoint='finance.create_bank_account')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def create_bank_account():
        try:
            data = request.form
            account = BankAccount(
                account_name=data.get('account_name'),
                account_number=data.get('account_number'),
                bank_name=data.get('bank_name'),
                account_type=data.get('account_type', 'Current'),
                current_balance=float(data.get('opening_balance', 0)),
                book_balance=float(data.get('opening_balance', 0)),
                currency='NGN',
                is_active=True
            )
        
            db.session.add(account)
            db.session.commit()
        
            return jsonify({
                'status': 'success',
                'message': f'Bank account {account.account_name} created successfully'
            })
        except Exception as e:
            current_app.logger.error(f"Error creating bank account: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': 'Failed to create bank account'
            }), 500

    @app.route('/finance/bank-reconciliation/add-transaction', methods=['POST'], endpoint='finance.add_transaction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def add_transaction():
        try:
            data = request.get_json() if request.is_json else request.form
        
        # Extract transaction data
            account_id = data.get('account_id')
            transaction_type = data.get('transaction_type')  # 'credit' or 'debit'
            amount = float(data.get('amount', 0))
            description = data.get('description', '')
            reference_number = data.get('reference_number', '')
            transaction_date = data.get('transaction_date', datetime.now().date())
        
        # Validate inputs
            if not account_id or not transaction_type or amount <= 0:
                return jsonify({
                    'status': 'error',
                    'message': 'Missing required fields: account_id, transaction_type, amount'
                }), 400
            
            # Get the bank account
            account = BankAccount.query.filter_by(id=account_id).first()
            if not account:
                return jsonify({
                    'status': 'error',
                    'message': 'Bank account not found'
                }), 404
            
            # Check if debit transaction would overdraw account
            if transaction_type.lower() == 'debit' and account.current_balance < amount:
                return jsonify({
                    'status': 'error',
                    'message': f'Insufficient funds. Available balance: {account.current_balance:,.2f}'
                }), 400
        
        # Create new bank transaction
            new_transaction = BankTransaction(
                account_id=account_id,
                transaction_type=transaction_type.title(),
                amount=amount,
                description=description,
                reference_number=reference_number,
                transaction_date=transaction_date if isinstance(transaction_date, datetime) else datetime.strptime(str(transaction_date), '%Y-%m-%d').date(),
                created_by=current_user.id
            )
        
        # Update account balance
            if transaction_type.lower() == 'credit':
                account.current_balance += amount
                account.book_balance += amount
            else:  # debit
                account.current_balance -= amount
                account.book_balance -= amount
            
            account.updated_at = datetime.now(timezone.utc)
        
        # Save to database
            db.session.add(new_transaction)
            db.session.commit()
        
            return jsonify({
                'status': 'success',
                'message': f'Transaction recorded successfully. New balance: {account.current_balance:,.2f}',
                'transaction_id': new_transaction.id,
                'new_balance': account.current_balance
            })
        
        except ValueError as e:
            return jsonify({
                'status': 'error',
                'message': 'Invalid amount format'
            }), 400
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error adding transaction: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': f'Failed to add transaction: {str(e)}'
            }), 500

    @app.route('/finance/bank-reconciliation/start', methods=['POST'], endpoint='finance.start_reconciliation')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def start_reconciliation():
        try:
            data = request.form
            account_id = data.get('account_id')
        
        # Get account name from account_id
            account = BankAccount.query.get(account_id)
            if not account:
                return jsonify({
                    'status': 'error',
                    'message': 'Bank account not found'
                }), 404
        
        # Insert reconciliation using actual schema
            db.session.execute(
                db.text('''
                    INSERT INTO bank_reconciliations 
                    (account_name, statement_date, balance, status, created_at) 
                    VALUES (:account_name, :statement_date, :balance, :status, :created_at)
                '''),
                {
                    'account_name': account.account_name,
                    'statement_date': data.get('reconciliation_date'),
                    'balance': float(data.get('statement_balance')),
                    'status': 'Pending',
                    'created_at': datetime.now()
                }
            )
        
            db.session.commit()
        
            return jsonify({
                'status': 'success',
                'message': f'Reconciliation started for {account.account_name}'
            })
        except Exception as e:
            current_app.logger.error(f"Error starting reconciliation: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': 'Failed to start reconciliation'
            }), 500
        try:
            account_name = request.form.get('account_name')
            account_number = request.form.get('account_number')
            bank_name = request.form.get('bank_name')
            account_type = request.form.get('account_type', 'Checking')
            opening_balance = float(request.form.get('opening_balance', 0))
        
        # Create new bank account
            account = BankAccount(
                account_name=account_name,
                account_number=account_number,
                bank_name=bank_name,
                account_type=account_type,
                current_balance=opening_balance,
                book_balance=opening_balance
            )
        
            db.session.add(account)
            db.session.commit()
        
        # Create opening balance transaction if > 0
            if opening_balance > 0:
                opening_transaction = BankTransaction(
                    account_id=account.id,
                    transaction_type='Credit',
                    amount=opening_balance,
                    description='Opening Balance',
                    transaction_date=datetime.now().date(),
                    created_by=current_user.id,
                    is_reconciled=True
                )
                db.session.add(opening_transaction)
                db.session.commit()
        
            flash(f"Bank account '{account_name}' created successfully!", "success")
            return jsonify({'status': 'success', 'account_id': account.id})
        
        except Exception as e:
            current_app.logger.error(f"Create bank account error: {str(e)}")
            flash("Error creating bank account", "error")
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/bank-reconciliation/add-transaction', methods=['POST'], endpoint='finance.add_bank_transaction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def add_bank_transaction():
        try:
            account_id = int(request.form.get('account_id'))
            account = BankAccount.query.get_or_404(account_id)
        
            transaction_type = request.form.get('transaction_type')  # Credit or Debit
            amount = float(request.form.get('amount'))
            description = request.form.get('description')
            reference_number = request.form.get('reference_number')
            transaction_date = request.form.get('transaction_date')
        
        # Create transaction
            transaction = BankTransaction(
                account_id=account_id,
                transaction_type=transaction_type,
                amount=amount,
                description=description,
                reference_number=reference_number,
                transaction_date=datetime.strptime(transaction_date, '%Y-%m-%d').date(),
                created_by=current_user.id
            )
        
        # Update account book balance
            if transaction_type == 'Credit':
                account.update_balance(amount, 'add')
            else:  # Debit
                account.update_balance(amount, 'subtract')
        
            db.session.add(transaction)
            db.session.commit()
        
            flash(f"Transaction added successfully!", "success")
            return jsonify({'status': 'success', 'transaction_id': transaction.id})
        
        except Exception as e:
            current_app.logger.error(f"Add transaction error: {str(e)}")
            flash("Error adding transaction", "error")
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/bank-accounts/<int:account_id>/add-transaction', methods=['POST'], endpoint='finance.add_account_transaction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def add_account_transaction(account_id):
        try:
            account = BankAccount.query.get_or_404(account_id)
        
            transaction_type = request.form.get('transaction_type')  # Credit or Debit
            amount = float(request.form.get('amount'))
            description = request.form.get('description')
            reference_number = request.form.get('reference_number')
            transaction_date = request.form.get('transaction_date')
        
        # Create transaction
            transaction = BankTransaction(
                account_id=account_id,
                transaction_type=transaction_type,
                amount=amount,
                description=description,
                reference_number=reference_number,
                transaction_date=datetime.strptime(transaction_date, '%Y-%m-%d').date(),
                created_by=current_user.id
            )
        
        # Update account book balance
            if transaction_type == 'Credit':
                account.update_balance(amount, 'add')
            else:  # Debit
                account.update_balance(amount, 'subtract')
        
            db.session.add(transaction)
            db.session.commit()
        
            flash(f"Transaction added successfully!", "success")
            return jsonify({'status': 'success', 'transaction_id': transaction.id})
        
        except Exception as e:
            current_app.logger.error(f"Add transaction error: {str(e)}")
            flash("Error adding transaction", "error")
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/bank-accounts/<int:account_id>/delete', methods=['POST'], endpoint='finance.delete_bank_account')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def delete_bank_account(account_id):
        """Delete a bank account"""
        try:
            account = BankAccount.query.get_or_404(account_id)
            
            # Check if there are transactions
            transaction_count = BankTransaction.query.filter_by(account_id=account_id).count()
            if transaction_count > 0:
                flash(f'Cannot delete account with {transaction_count} transactions. Please delete transactions first.', 'error')
                return redirect(url_for('finance.bank_reconciliation'))
            
            db.session.delete(account)
            db.session.commit()
            flash('Bank account deleted successfully', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting bank account: {str(e)}', 'error')
        
        return redirect(url_for('finance.bank_reconciliation'))

    @app.route('/finance/bank-transactions/<int:transaction_id>/delete', methods=['POST'], endpoint='finance.delete_bank_transaction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def delete_bank_transaction(transaction_id):
        """Delete a bank transaction and update account balance"""
        try:
            transaction = BankTransaction.query.get_or_404(transaction_id)
            account = BankAccount.query.get(transaction.account_id)
            
            # Reverse the transaction effect on balance
            if account:
                if transaction.transaction_type == 'Credit':
                    account.current_balance -= transaction.amount
                    account.book_balance -= transaction.amount
                else:  # Debit
                    account.current_balance += transaction.amount
                    account.book_balance += transaction.amount
                account.updated_at = datetime.now(timezone.utc)
            
            db.session.delete(transaction)
            db.session.commit()
            flash('Transaction deleted successfully and account balance updated', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting transaction: {str(e)}', 'error')
        
        return redirect(url_for('finance.bank_reconciliation'))

    @app.route('/finance/bank-reconciliation/<int:reconciliation_id>/reconcile', methods=['POST'], endpoint='finance.reconcile_transactions')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def reconcile_transactions(reconciliation_id):
        try:
            reconciliation = BankReconciliation.query.get_or_404(reconciliation_id)
            reconciled_transaction_ids = request.json.get('transaction_ids', [])
        
        # Mark transactions as reconciled
            for transaction_id in reconciled_transaction_ids:
                transaction = BankTransaction.query.get(transaction_id)
                if transaction and transaction.account_id == reconciliation.account_id:
                    transaction.is_reconciled = True
                    transaction.reconciliation_id = reconciliation_id
        
        # Mark reconciliation as completed
            reconciliation.mark_as_reconciled()
        
            db.session.commit()
        
            flash("Transactions reconciled successfully!", "success")
            return jsonify({'status': 'success'})
        
        except Exception as e:
            current_app.logger.error(f"Reconcile transactions error: {str(e)}")
            flash("Error reconciling transactions", "error")
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/bank-reconciliation/<int:reconciliation_id>/complete', methods=['POST'], endpoint='finance.complete_bank_reconciliation')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def complete_bank_reconciliation(reconciliation_id):
        try:
            reconciliation = BankReconciliation.query.get_or_404(reconciliation_id)
        
        # Mark reconciliation as completed and update account balance
            reconciliation.mark_as_reconciled()
        
            db.session.commit()
        
            flash("Bank reconciliation completed successfully!", "success")
            return jsonify({'status': 'success'})
        
        except Exception as e:
            current_app.logger.error(f"Complete reconciliation error: {str(e)}")
            flash("Error completing bank reconciliation", "error")
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/settings', endpoint='finance.settings')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def settings():
        return render_template('finance/settings.html')


    @app.route('/finance/logout', endpoint='finance.logout')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def logout():
        try:
        # Clear all session data
            session.clear()
            flash("Successfully logged out", "success")
            return redirect(url_for('login'))
        except Exception as e:
            current_app.logger.error(f"Logout error: {str(e)}")
            flash("Error during logout", "error")
            return redirect(url_for('finance.finance_home'))

## --- Finance Report Generation Endpoints ---
    @app.route('/finance/reports', methods=['GET'], endpoint='finance.generate_finance_report')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def generate_finance_report():
        report_type = request.args.get('type')
        start_date = request.args.get('start_date')
        end_date = request.args.get('end_date')
        try:
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d')
            if end_date:
                end_date = datetime.strptime(end_date, '%Y-%m-%d')
        except Exception:
            return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD.'}), 400

        if report_type == 'P&L':
        # Income (credit transactions, revenue accounts)
            income_query = db.session.query(
                ChartOfAccount.name.label('account'),
                func.sum(Transaction.amount).label('total')
            ).join(Transaction, Transaction.checkbook_id == ChartOfAccount.id, isouter=True)
            income_query = income_query.filter(ChartOfAccount.type == 'Revenue')
            if start_date:
                income_query = income_query.filter(Transaction.date >= start_date)
            if end_date:
                income_query = income_query.filter(Transaction.date <= end_date)
            income_query = income_query.group_by(ChartOfAccount.name)
            income = [
                {'account': row.account, 'total': row.total or 0}
                for row in income_query.all()
            ]

        # Expenses (debit transactions, expense accounts)
            expense_query = db.session.query(
                ChartOfAccount.name.label('account'),
                func.sum(Transaction.amount).label('total')
            ).join(Transaction, Transaction.checkbook_id == ChartOfAccount.id, isouter=True)
            expense_query = expense_query.filter(ChartOfAccount.type == 'Expense')
            if start_date:
                expense_query = expense_query.filter(Transaction.date >= start_date)
            if end_date:
                expense_query = expense_query.filter(Transaction.date <= end_date)
            expense_query = expense_query.group_by(ChartOfAccount.name)
            expenses = [
                {'account': row.account, 'total': row.total or 0}
                for row in expense_query.all()
            ]

            total_income = sum(i['total'] for i in income)
            total_expenses = sum(e['total'] for e in expenses)
            net_profit = total_income - total_expenses
            return jsonify({
                'report': 'Profit & Loss',
                'period': {'start': str(start_date) if start_date else None, 'end': str(end_date) if end_date else None},
                'income': income,
                'expenses': expenses,
                'total_income': total_income,
                'total_expenses': total_expenses,
                'net_profit': net_profit
            }), 200

        elif report_type == 'BalanceSheet':
        # Assets
            assets_query = db.session.query(
                ChartOfAccount.name.label('account'),
                func.sum(Transaction.amount).label('total')
            ).join(Transaction, Transaction.checkbook_id == ChartOfAccount.id, isouter=True)
            assets_query = assets_query.filter(ChartOfAccount.type == 'Asset')
            assets_query = assets_query.group_by(ChartOfAccount.name)
            assets = [
                {'account': row.account, 'total': row.total or 0}
                for row in assets_query.all()
            ]

        # Liabilities
            liabilities_query = db.session.query(
                ChartOfAccount.name.label('account'),
                func.sum(Transaction.amount).label('total')
            ).join(Transaction, Transaction.checkbook_id == ChartOfAccount.id, isouter=True)
            liabilities_query = liabilities_query.filter(ChartOfAccount.type == 'Liability')
            liabilities_query = liabilities_query.group_by(ChartOfAccount.name)
            liabilities = [
                {'account': row.account, 'total': row.total or 0}
                for row in liabilities_query.all()
            ]

        # Equity
            equity_query = db.session.query(
                ChartOfAccount.name.label('account'),
                func.sum(Transaction.amount).label('total')
            ).join(Transaction, Transaction.checkbook_id == ChartOfAccount.id, isouter=True)
            equity_query = equity_query.filter(ChartOfAccount.type == 'Equity')
            equity_query = equity_query.group_by(ChartOfAccount.name)
            equity = [
                {'account': row.account, 'total': row.total or 0}
                for row in equity_query.all()
            ]

            total_assets = sum(a['total'] for a in assets)
            total_liabilities = sum(l['total'] for l in liabilities)
            total_equity = sum(e['total'] for e in equity)
            return jsonify({
                'report': 'Balance Sheet',
                'assets': assets,
                'liabilities': liabilities,
                'equity': equity,
                'total_assets': total_assets,
                'total_liabilities': total_liabilities,
                'total_equity': total_equity,
                'assets_equals_liabilities_plus_equity': total_assets == (total_liabilities + total_equity)
            }), 200

        elif report_type == 'Invoices':
        # List all expenses or transactions marked as invoices
            invoices = []
        # Try to get from Expense table if it has invoice info
            expense_invoices = Expense.query.filter(Expense.category.ilike('%invoice%')).all()
            for exp in expense_invoices:
                invoices.append({
                    'id': exp.id,
                    'amount': exp.amount,
                    'description': exp.description,
                    'date': exp.date,
                    'user_id': exp.user_id,
                    'status': exp.status
                })
        # Optionally, add from Transaction if needed
            transaction_invoices = Transaction.query.filter(Transaction.description.ilike('%invoice%')).all()
            for t in transaction_invoices:
                invoices.append({
                    'id': t.id,
                    'amount': t.amount,
                    'description': t.description,
                    'date': t.date,
                    'status': t.status
                })
            return jsonify({'report': 'Invoices', 'invoices': invoices}), 200
        else:
            return jsonify({'error': 'Invalid report type'}), 400
## --- Project Budget Allocation Endpoints ---
    @app.route('/finance/budgets', methods=['POST'], endpoint='finance.allocate_budget')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def allocate_budget():
        data = request.get_json()
        budget = Budget(
            project_id=data.get('project_id'),
            category=data.get('category'),
            allocated_amount=data.get('allocated_amount'),
            spent_amount=0.0
        )
        db.session.add(budget)
        db.session.commit()
        return jsonify({'message': 'Budget allocated', 'id': budget.id}), 201

    @app.route('/finance/budgets/<int:project_id>', methods=['GET'], endpoint='finance.get_project_budgets')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def get_project_budgets(project_id):
        budgets = Budget.query.filter_by(project_id=project_id).all()
        result = [
            {
                'id': b.id,
                'category': b.category,
                'allocated_amount': b.allocated_amount,
                'spent_amount': b.spent_amount
            } for b in budgets
        ]
        return jsonify(result)


## --- Payroll Disbursement Endpoint ---
    @app.route('/finance/payroll/<int:payroll_id>/disburse', methods=['POST'], endpoint='finance.disburse_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def disburse_payroll(payroll_id):
        payroll = Payroll.query.get_or_404(payroll_id)
        if payroll.status != 'approved':
            return jsonify({'error': 'Payroll not approved by management'}), 400
        payroll.status = 'disbursed'
        payroll.disbursed_by = current_user.id
        payroll.disbursed_at = datetime.now(timezone.utc)
        db.session.commit()
    # TODO: Send email to HR/employee
        return jsonify({'message': 'Payroll disbursed'})
## --- Payment Request Workflow Endpoints ---
    @app.route('/finance/payment-request', methods=['POST'], endpoint='finance.create_payment_request')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def create_payment_request():
        data = request.get_json()
        req = PaymentRequest(
            department_id=data.get('department_id'),
            amount=data.get('amount'),
            status='pending',
            requester_id=current_user.id
        )
        db.session.add(req)
        db.session.commit()
    # TODO: Send email to approver(s)
        return jsonify({'message': 'Payment request created', 'id': req.id}), 201

    @app.route('/finance/payment-request/<int:request_id>/approve', methods=['POST'], endpoint='finance.approve_payment_request')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def approve_payment_request(request_id):
        req = PaymentRequest.query.get_or_404(request_id)
        if req.status != 'pending':
            return jsonify({'error': 'Request not pending'}), 400
        req.status = 'approved'
        req.approved_by = current_user.id
        db.session.commit()
    # TODO: Send email to requester
        return jsonify({'message': 'Payment request approved'})

    @app.route('/finance/payment-request/<int:request_id>/disburse', methods=['POST'], endpoint='finance.disburse_payment_request')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def disburse_payment_request(request_id):
        req = PaymentRequest.query.get_or_404(request_id)
        if req.status != 'approved':
            return jsonify({'error': 'Request not approved'}), 400
        req.status = 'disbursed'
        req.disbursed_by = current_user.id
        db.session.commit()
    # TODO: Send email to requester
        return jsonify({'message': 'Payment request disbursed'})
    from flask_mail import Message
## --- Chart of Accounts Endpoints ---
    @app.route('/finance/chart-of-accounts', methods=['GET'], endpoint='finance.get_chart_of_accounts')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def get_chart_of_accounts():
        accounts = ChartOfAccount.query.all()
        result = [
            {
                'id': acc.id,
                'name': acc.name,
                'type': acc.type,
                'parent_id': acc.parent_id
            } for acc in accounts
        ]
        return jsonify(result)

    @app.route('/finance/chart-of-accounts', methods=['POST'], endpoint='finance.create_chart_of_account')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def create_chart_of_account():
        data = request.get_json()
        name = data.get('name')
        acc_type = data.get('type')
        parent_id = data.get('parent_id')
        account = ChartOfAccount(name=name, type=acc_type, parent_id=parent_id)
        db.session.add(account)
        db.session.commit()
        return jsonify({'message': 'Chart of account created', 'id': account.id}), 201

    @app.route('/finance/chart-of-accounts/<int:account_id>', methods=['PUT'], endpoint='finance.update_chart_of_account')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def update_chart_of_account(account_id):
        account = ChartOfAccount.query.get_or_404(account_id)
        data = request.get_json()
        account.name = data.get('name', account.name)
        account.type = data.get('type', account.type)
        account.parent_id = data.get('parent_id', account.parent_id)
        db.session.commit()
        return jsonify({'message': 'Chart of account updated'})

    @app.route('/finance/chart-of-accounts/<int:account_id>', methods=['DELETE'], endpoint='finance.delete_chart_of_account')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def delete_chart_of_account(account_id):
        account = ChartOfAccount.query.get_or_404(account_id)
        db.session.delete(account)
        db.session.commit()
        return jsonify({'message': 'Chart of account deleted'})

# --- Payroll Finance Approval Routes ---
    @app.route('/finance/payroll/pending', endpoint='finance.pending_payroll_approvals')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def pending_payroll_approvals():
        """View payrolls pending finance approval"""
        try:
        
        # Get payrolls pending finance approval
            pending_approvals = db.session.query(PayrollApproval, User).join(
                User, PayrollApproval.submitted_by == User.id
            ).filter(
                PayrollApproval.status == 'pending_finance'
            ).order_by(PayrollApproval.submitted_at.desc()).all()
        
            return render_template('finance/payroll/pending.html', 
                                 pending_approvals=pending_approvals)
        
        except Exception as e:
            current_app.logger.error(f"Error loading pending payroll approvals: {str(e)}")
            flash("Error loading pending payroll approvals", "error")
            return redirect(url_for('finance.finance_home'))

    @app.route('/finance/payroll/<int:approval_id>/approve', methods=['GET', 'POST'], endpoint='finance.approve_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def approve_payroll(approval_id):
        """Process and approve/reject payroll from finance perspective"""
        try:
        
            approval = db.session.get(PayrollApproval, approval_id)
            if not approval:
                flash("Payroll approval not found", "error")
                return redirect(url_for('finance.pending_payroll_approvals'))
        
            if approval.status != 'pending_finance':
                flash("This payroll is no longer pending finance approval", "warning")
                return redirect(url_for('finance.pending_payroll_approvals'))
        
            if request.method == 'POST':
                action = request.form.get('action')
                comments = request.form.get('comments', '')
            
                if action == 'approve':
                    approval.status = 'approved'
                    approval.finance_reviewer = session.get('user_id')
                    approval.finance_reviewed_at = datetime.now()
                    approval.finance_comments = comments
                
                # Update all related staff payrolls
                    year, month = map(int, approval.payroll_period.split('-'))
                    staff_payrolls = StaffPayroll.query.filter(
                        StaffPayroll.period_year == year,
                        StaffPayroll.period_month == month
                    ).all()
                
                    for payroll in staff_payrolls:
                        payroll.approval_status = 'approved'
                        payroll.approved_by_finance = session.get('user_id')
                        payroll.finance_approved_at = datetime.now()
                
                    flash(f"Payroll for {approval.payroll_period} approved for payment", "success")
                
                elif action == 'reject':
                    approval.status = 'rejected'
                    approval.finance_reviewer = session.get('user_id')
                    approval.finance_reviewed_at = datetime.now()
                    approval.finance_comments = comments
                
                # Update all related staff payrolls
                    year, month = map(int, approval.payroll_period.split('-'))
                    staff_payrolls = StaffPayroll.query.filter(
                        StaffPayroll.period_year == year,
                        StaffPayroll.period_month == month
                    ).all()
                
                    for payroll in staff_payrolls:
                        payroll.approval_status = 'rejected'
                
                    flash(f"Payroll for {approval.payroll_period} rejected", "warning")
            
                db.session.commit()
                return redirect(url_for('finance.pending_payroll_approvals'))
        
        # Get payroll details for review
            year, month = map(int, approval.payroll_period.split('-'))
            staff_payrolls = db.session.query(StaffPayroll, Employee).join(
                Employee, StaffPayroll.employee_id == Employee.id
            ).filter(
                StaffPayroll.period_year == year,
                StaffPayroll.period_month == month
            ).all()
        
            return render_template('finance/payroll/process.html',
                                 approval=approval,
                                 staff_payrolls=staff_payrolls)
        
        except Exception as e:
            current_app.logger.error(f"Error processing payroll: {str(e)}")
            flash("Error processing payroll", "error")
            return redirect(url_for('finance.pending_payroll_approvals'))

    @app.route('/finance/payroll/approvals', endpoint='finance.payroll_approvals')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def payroll_approvals():
        """View all payroll approvals with filtering"""
        try:
            page = request.args.get('page', 1, type=int)
            status_filter = request.args.get('status', 'all')
            
            # Build query with joins to get submitter info
            query = db.session.query(PayrollApproval, User).join(
                User, PayrollApproval.submitted_by == User.id
            )
            
            if status_filter != 'all':
                query = query.filter(PayrollApproval.status == status_filter)
            
            approvals = query.order_by(PayrollApproval.submitted_at.desc()).paginate(
                page=page, per_page=20, error_out=False
            )
            
            # Calculate statistics
            pending_count = PayrollApproval.query.filter_by(status='pending_finance').count()
            approved_count = PayrollApproval.query.filter_by(status='approved').count()
            paid_count = PayrollApproval.query.filter_by(status='paid').count()
            total_amount = db.session.query(db.func.sum(PayrollApproval.total_amount)).filter(
                PayrollApproval.status.in_(['approved', 'paid'])
            ).scalar() or 0
            
            return render_template('finance/payroll/approvals.html',
                                 approvals=approvals,
                                 pending_count=pending_count,
                                 approved_count=approved_count,
                                 paid_count=paid_count,
                                 total_amount=total_amount,
                                 status_filter=status_filter)
        
        except Exception as e:
            current_app.logger.error(f"Error loading payroll approvals: {str(e)}")
            flash("Error loading payroll approvals", "error")
            return redirect(url_for('finance.finance_home'))

    @app.route('/finance/payroll/<int:approval_id>/process', methods=['POST'], endpoint='finance.process_payroll_approval')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def process_payroll_approval(approval_id):
        """Process payroll approval with workflow (approve or reject, notify Admin and HR)"""
        from models import ApprovalWorkflow, WorkflowStep
        from utils.workflow import approve_workflow_step, reject_workflow_step
        
        try:
            approval = db.session.get(PayrollApproval, approval_id)
            if not approval:
                return jsonify({'status': 'error', 'message': 'Payroll approval not found'}), 404
            
            if approval.status != 'pending_finance':
                return jsonify({'status': 'error', 'message': 'This payroll is not pending approval'}), 400
            
            action = request.form.get('action')
            comments = request.form.get('comments', '')
            
            # Find the associated workflow
            workflow = ApprovalWorkflow.query.filter_by(
                workflow_type='payroll',
                reference_id=approval.id
            ).first()
            
            if not workflow:
                # Fallback to old approval method if no workflow found
                current_app.logger.warning(f"No workflow found for payroll approval {approval_id}")
                if action == 'approve':
                    approval.status = 'approved'
                    approval.finance_processed_by = current_user.id
                    approval.finance_processed_at = datetime.now(timezone.utc)
                    approval.finance_comments = comments
                    db.session.commit()
                    return jsonify({'status': 'success', 'message': 'Payroll approved'})
                elif action == 'reject':
                    approval.status = 'rejected'
                    approval.finance_processed_by = current_user.id
                    approval.finance_processed_at = datetime.now(timezone.utc)
                    approval.finance_comments = comments
                    db.session.commit()
                    return jsonify({'status': 'success', 'message': 'Payroll rejected'})
            
            # Get current step
            current_step = WorkflowStep.query.filter_by(
                workflow_id=workflow.id,
                required_role='hq_finance',
                status='pending'
            ).first()
            
            if not current_step:
                return jsonify({'status': 'error', 'message': 'No pending approval step found'}), 400
            
            if action == 'approve':
                # Approve workflow step
                success, message, next_step = approve_workflow_step(
                    workflow_id=workflow.id,
                    step_order=current_step.step_order,
                    approver_id=current_user.id,
                    comments=comments
                )
                
                if success:
                    # Update payroll approval status
                    approval.status = 'approved'
                    approval.finance_processed_by = current_user.id
                    approval.finance_processed_at = datetime.now(timezone.utc)
                    approval.finance_comments = comments
                    
                    # Update all related staff payrolls
                    staff_payrolls = StaffPayroll.query.filter_by(
                        period_year=approval.period_year,
                        period_month=approval.period_month
                    ).all()
                    
                    for payroll in staff_payrolls:
                        payroll.approval_status = 'approved'
                        payroll.approved_by_finance = current_user.id
                        payroll.finance_approved_at = datetime.now(timezone.utc)
                    
                    db.session.commit()
                    
                    # Note: Admin and HR are automatically notified via the workflow system
                    flash(f"Payroll for {approval.period_month}/{approval.period_year} approved. Admin and HR have been notified.", "success")
                    return jsonify({'status': 'success', 'message': 'Payroll approved and notifications sent'})
                else:
                    return jsonify({'status': 'error', 'message': message}), 400
                    
            elif action == 'reject':
                if not comments:
                    return jsonify({'status': 'error', 'message': 'Rejection reason is required'}), 400
                
                # Reject workflow
                success, message = reject_workflow_step(
                    workflow_id=workflow.id,
                    step_order=current_step.step_order,
                    rejector_id=current_user.id,
                    comments=comments
                )
                
                if success:
                    # Update payroll approval status
                    approval.status = 'rejected'
                    approval.rejected_by = current_user.id
                    approval.rejected_at = datetime.now(timezone.utc)
                    approval.rejection_reason = comments
                    
                    # Update all related staff payrolls
                    staff_payrolls = StaffPayroll.query.filter_by(
                        period_year=approval.period_year,
                        period_month=approval.period_month
                    ).all()
                    
                    for payroll in staff_payrolls:
                        payroll.approval_status = 'rejected'
                    
                    db.session.commit()
                    
                    flash(f"Payroll for {approval.period_month}/{approval.period_year} rejected. HR has been notified.", "warning")
                    return jsonify({'status': 'success', 'message': 'Payroll rejected'})
                else:
                    return jsonify({'status': 'error', 'message': message}), 400
            
            return jsonify({'status': 'error', 'message': 'Invalid action'}), 400
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error processing payroll: {str(e)}", exc_info=True)
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/payroll/<int:approval_id>/mark-paid', methods=['POST'], endpoint='finance.mark_payroll_paid')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def mark_payroll_paid(approval_id):
        """Mark payroll as paid"""
        try:
            approval = db.session.get(PayrollApproval, approval_id)
            if not approval:
                return jsonify({'status': 'error', 'message': 'Payroll approval not found'}), 404
            
            if approval.status != 'approved':
                return jsonify({'status': 'error', 'message': 'Only approved payrolls can be marked as paid'}), 400
            
            payment_date = request.form.get('payment_date')
            payment_reference = request.form.get('payment_reference', '')
            payment_notes = request.form.get('payment_notes', '')
            
            approval.status = 'paid'
            approval.paid_by = session.get('user_id')
            approval.paid_at = datetime.strptime(payment_date, '%Y-%m-%d') if payment_date else datetime.now()
            approval.payment_reference = payment_reference
            approval.payment_notes = payment_notes
            
            # Create audit log
            audit = Audit(
                name=f'Payroll Payment: {approval.period_month}/{approval.period_year}',
                date=datetime.now(),
                status='paid',
                approved_by=current_user.name
            )
            db.session.add(audit)
            
            db.session.commit()
            flash(f"Payroll for {approval.period_month}/{approval.period_year} marked as paid", "success")
            return jsonify({'status': 'success', 'message': 'Payroll marked as paid'})
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error marking payroll as paid: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)}), 500

    @app.route('/finance/payroll/<int:approval_id>/detail', endpoint='finance.payroll_approval_detail')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def payroll_approval_detail(approval_id):
        """View detailed payroll information"""
        try:
            approval = db.session.get(PayrollApproval, approval_id)
            if not approval:
                flash("Payroll approval not found", "error")
                return redirect(url_for('finance.payroll_approvals'))
            
            # Get staff payrolls for this period
            staff_payrolls = StaffPayroll.query.filter_by(
                period_year=approval.period_year,
                period_month=approval.period_month
            ).all()
            
            return render_template('finance/payroll/detail.html',
                                 approval=approval,
                                 staff_payrolls=staff_payrolls)
        
        except Exception as e:
            current_app.logger.error(f"Error loading payroll detail: {str(e)}")
            flash("Error loading payroll detail", "error")
            return redirect(url_for('finance.payroll_approvals'))


# ===== FINANCE PURCHASE ORDER APPROVAL ROUTES =====

    @app.route('/finance/purchase-order-approvals', methods=['GET'], endpoint='finance.purchase_order_approvals')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def finance_purchase_order_approvals():
        """View pending purchase orders for Finance approval"""
        from models import ApprovalWorkflow, WorkflowStep
        from utils.workflow import get_pending_approvals_for_user
        
        # Get workflows pending Finance approval
        pending_workflows = get_pending_approvals_for_user(current_user)
        
        # Filter for purchase orders only
        po_workflows = [w for w in pending_workflows if w.workflow_type == 'purchase_order']
        
        # Enrich with PO details
        enriched_workflows = []
        for workflow in po_workflows:
            po = PurchaseOrder.query.get(workflow.reference_id)
            if po:
                # Get current step
                current_step = WorkflowStep.query.filter_by(
                    workflow_id=workflow.id,
                    required_role=current_user.role,
                    status='pending'
                ).first()
                
                # Get cost control approval details
                cost_control_step = WorkflowStep.query.filter_by(
                    workflow_id=workflow.id,
                    step_order=1  # Cost Control is first step
                ).first()
                
                enriched_workflows.append({
                    'workflow': workflow,
                    'po': po,
                    'current_step': current_step,
                    'cost_control_step': cost_control_step,
                    'line_items': po.line_items
                })
        
        return render_template('finance/purchase_order_approvals.html',
                             workflows=enriched_workflows)
    
    
    @app.route('/finance/purchase-orders/<int:po_id>/approve', methods=['POST'], endpoint='finance.approve_purchase_order')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def finance_approve_purchase_order(po_id):
        """Approve or reject purchase order at Finance stage (final approval)"""
        from models import ApprovalWorkflow, WorkflowStep
        from utils.workflow import approve_workflow_step, reject_workflow_step
        
        try:
            po = PurchaseOrder.query.get_or_404(po_id)
            
            if not po.workflow_id:
                flash('Purchase order does not have an approval workflow', 'error')
                return redirect(url_for('finance.purchase_order_approvals'))
            
            action = request.form.get('action')
            comments = request.form.get('comments', '').strip()
            
            workflow = ApprovalWorkflow.query.get(po.workflow_id)
            if not workflow:
                flash('Workflow not found', 'error')
                return redirect(url_for('finance.purchase_order_approvals'))
            
            # Get current step
            current_step = WorkflowStep.query.filter_by(
                workflow_id=workflow.id,
                required_role=current_user.role,
                status='pending'
            ).first()
            
            if not current_step:
                flash('No pending approval step found', 'error')
                return redirect(url_for('finance.purchase_order_approvals'))
            
            if action == 'approve':
                # Approve workflow step (this should be final approval)
                success, message, next_step = approve_workflow_step(
                    workflow_id=workflow.id,
                    step_order=current_step.step_order,
                    approver_id=current_user.id,
                    comments=comments
                )
                
                if success:
                    # Update PO details
                    po.finance_approved_by = current_user.id
                    po.finance_approved_at = datetime.now(timezone.utc)
                    po.finance_comments = comments
                    po.status = 'Approved'
                    po.approval_date = datetime.now(timezone.utc)
                    
                    # Update budget spent if project linked
                    if po.project_id:
                        budgets = Budget.query.filter_by(
                            project_id=po.project_id,
                            category='procurement'
                        ).first()
                        
                        if budgets:
                            budgets.spent_amount += po.total_amount
                            budgets.remaining_amount = budgets.allocated_amount - budgets.spent_amount
                    
                    db.session.commit()
                    flash(f'Purchase Order {po.order_number} fully approved!', 'success')
                else:
                    flash(message, 'error')
                    
            elif action == 'reject':
                if not comments:
                    flash('Rejection reason is required', 'error')
                    return redirect(url_for('finance.purchase_order_approvals'))
                
                # Reject workflow
                success, message = reject_workflow_step(
                    workflow_id=workflow.id,
                    step_order=current_step.step_order,
                    rejector_id=current_user.id,
                    comments=comments
                )
                
                if success:
                    # Update PO status
                    po.status = 'Rejected'
                    po.notes = (po.notes or '') + f"\n[{datetime.now().strftime('%Y-%m-%d %H:%M')}] Finance Rejected: {comments}"
                    
                    db.session.commit()
                    flash(f'Purchase Order {po.order_number} rejected', 'info')
                else:
                    flash(message, 'error')
            
            return redirect(url_for('finance.purchase_order_approvals'))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error processing PO approval: {str(e)}", exc_info=True)
            flash(f'Error processing approval: {str(e)}', 'error')
            return redirect(url_for('finance.purchase_order_approvals'))


# ===== FINANCE COST APPROVALS ROUTES =====

    @app.route('/finance/cost-approvals', methods=['GET', 'POST'], endpoint='finance.cost_approvals')
    @role_required([Roles.HQ_FINANCE, Roles.SUPER_HQ])
    def finance_cost_approvals():
        """Cost approval queue for Finance (mainly budget adjustments)"""
        if request.method == 'POST':
            approval_id = request.form.get('approval_id')
            action = request.form.get('action')
            comments = request.form.get('comments')
            
            approval = CostApproval.query.get_or_404(approval_id)
            
            # Verify this approval is meant for Finance
            if approval.required_role != Roles.HQ_FINANCE:
                flash('This approval is not for Finance review', 'error')
                return redirect(url_for('finance.cost_approvals'))
            
            if action == 'approve':
                approval.status = 'approved'
                approval.approver_id = current_user.id
                approval.approved_at = datetime.now(timezone.utc)
                approval.comments = comments
                approval.action_taken = 'approved'
                
                # Update budget if it's a budget adjustment
                if approval.reference_type == 'budget_adjustment':
                    adjustment = BudgetAdjustment.query.get(approval.reference_id)
                    if adjustment:
                        adjustment.status = 'approved'
                        adjustment.approved_by = current_user.id
                        adjustment.approved_at = datetime.now(timezone.utc)
                        adjustment.approval_comments = comments
                        
                        # Update the actual budget
                        budget = Budget.query.get(adjustment.budget_id)
                        if budget:
                            budget.allocated_amount = adjustment.new_amount
                            budget.updated_at = datetime.now(timezone.utc)
                        
                        # Notify the requester
                        requester = User.query.get(adjustment.requested_by)
                        if requester:
                            notification = Notification(
                                user_id=requester.id,
                                title='Budget Adjustment Approved',
                                message=f'Budget adjustment approved: {adjustment.category} - New amount: {adjustment.new_amount:,.2f}',
                                notification_type='approval_update',
                                reference_type='budget_adjustment',
                                reference_id=adjustment.id
                            )
                            db.session.add(notification)
                
                flash('Approval processed successfully', 'success')
                
            elif action == 'reject':
                approval.status = 'rejected'
                approval.approver_id = current_user.id
                approval.approved_at = datetime.now(timezone.utc)
                approval.comments = comments
                approval.action_taken = 'rejected'
                
                # Update budget adjustment status
                if approval.reference_type == 'budget_adjustment':
                    adjustment = BudgetAdjustment.query.get(approval.reference_id)
                    if adjustment:
                        adjustment.status = 'rejected'
                        adjustment.approval_comments = comments
                        
                        # Notify the requester
                        requester = User.query.get(adjustment.requested_by)
                        if requester:
                            notification = Notification(
                                user_id=requester.id,
                                title='Budget Adjustment Rejected',
                                message=f'Budget adjustment rejected: {adjustment.category}. Reason: {comments}',
                                notification_type='approval_update',
                                reference_type='budget_adjustment',
                                reference_id=adjustment.id
                            )
                            db.session.add(notification)
                
                flash('Approval rejected', 'info')
            
            db.session.commit()
            return redirect(url_for('finance.cost_approvals'))
        
        # GET request - show pending approvals for Finance
        status_filter = request.args.get('status', 'pending')
        
        query = CostApproval.query.filter_by(required_role=Roles.HQ_FINANCE)
        
        if status_filter != 'all':
            query = query.filter_by(status=status_filter)
        
        approvals = query.order_by(CostApproval.created_at.desc()).all()
        
        # Enrich approval data with project and reference info
        enriched_approvals = []
        for approval in approvals:
            project = Project.query.get(approval.project_id)
            
            ref_details = {}
            if approval.reference_type == 'budget_adjustment':
                adjustment = BudgetAdjustment.query.get(approval.reference_id)
                if adjustment:
                    requester = User.query.get(adjustment.requested_by)
                    ref_details = {
                        'category': adjustment.category,
                        'old_amount': adjustment.old_amount,
                        'new_amount': adjustment.new_amount,
                        'adjustment_type': adjustment.adjustment_type,
                        'reason': adjustment.reason,
                        'impact_analysis': adjustment.impact_analysis,
                        'requester_name': requester.name if requester else 'Unknown'
                    }
            
            enriched_approvals.append({
                'approval': approval,
                'project': project,
                'reference_details': ref_details
            })
        
        return render_template('finance/cost_approvals.html',
                             approvals=enriched_approvals,
                             status_filter=status_filter)


# ===== DOCUMENT MANAGEMENT ROUTES =====

    @app.route('/finance/financial-documents', endpoint='finance.financial_documents')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def financial_documents():
        """List all financial documents with filtering"""
        try:
            page = request.args.get('page', 1, type=int)
            project_filter = request.args.get('project', 'all')
            category_filter = request.args.get('category', 'all')
            
            query = Document.query
            
            # Apply filters
            if project_filter != 'all':
                if project_filter == 'general':
                    query = query.filter(Document.project_id.is_(None))
                else:
                    query = query.filter(Document.project_id == int(project_filter))
            
            if category_filter != 'all':
                query = query.filter(Document.category == category_filter)
            
            documents = query.order_by(Document.uploaded_at.desc()).paginate(
                page=page, per_page=15, error_out=False
            )
            
            # Get all projects for filter dropdown
            projects = Project.query.order_by(Project.name).all()
            
            return render_template('finance/documents/index.html',
                                 documents=documents,
                                 projects=projects,
                                 filter_project=project_filter,
                                 filter_category=category_filter)
        
        except Exception as e:
            current_app.logger.error(f"Error loading documents: {str(e)}")
            flash("Error loading documents", "error")
            return redirect(url_for('finance.finance_home'))

    @app.route('/finance/documents/upload', methods=['POST'], endpoint='finance.upload_finance_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def upload_document():
        """Upload a new financial document"""
        try:
            if 'file' not in request.files:
                flash("No file selected", "error")
                return redirect(url_for('finance.financial_documents'))
            
            file = request.files['file']
            if file.filename == '':
                flash("No file selected", "error")
                return redirect(url_for('finance.financial_documents'))
            
            # Get form data
            name = request.form.get('name')
            category = request.form.get('category')
            description = request.form.get('description', '')
            project_id = request.form.get('project_id')
            
            if not name or not category:
                flash("Name and category are required", "error")
                return redirect(url_for('finance.financial_documents'))
            
            # Save file
            filename = secure_filename(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            unique_filename = f"{timestamp}_{filename}"
            
            upload_folder = os.path.join(current_app.root_path, 'uploads', 'finance_documents')
            os.makedirs(upload_folder, exist_ok=True)
            
            file_path = os.path.join(upload_folder, unique_filename)
            file.save(file_path)
            
            # Get file size and type
            file_size = os.path.getsize(file_path)
            file_ext = filename.rsplit('.', 1)[1].lower() if '.' in filename else 'unknown'
            
            # Create document record
            document = Document(
                filename=unique_filename,
                category=category,
                project_id=int(project_id) if project_id else None,
                uploaded_at=datetime.now(),
                uploader_id=session.get('user_id'),
                status='active',
                size=file_size
            )
            
            # Store additional metadata
            document.original_name = name
            document.description = description
            document.file_type = file_ext
            
            db.session.add(document)
            
            # Create audit log
            audit = Audit(
                name=f'Receipt Added: {name}' if category == 'receipt' else f'{category.title()} Added: {name}',
                date=datetime.now(),
                status='uploaded',
                approved_by=current_user.name
            )
            db.session.add(audit)
            
            db.session.commit()
            flash(f"Document '{name}' uploaded successfully", "success")
            return redirect(url_for('finance.financial_documents'))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error uploading document: {str(e)}")
            flash("Error uploading document", "error")
            return redirect(url_for('finance.financial_documents'))

    @app.route('/finance/documents/<int:doc_id>/download', endpoint='finance.download_finance_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def download_document(doc_id):
        """Download a document"""
        try:
            document = db.session.get(Document, doc_id)
            if not document:
                flash("Document not found", "error")
                return redirect(url_for('finance.financial_documents'))
            
            upload_folder = os.path.join(current_app.root_path, 'uploads', 'finance_documents')
            file_path = os.path.join(upload_folder, document.filename)
            
            if not os.path.exists(file_path):
                flash("File not found on server", "error")
                return redirect(url_for('finance.financial_documents'))
            
            return send_file(file_path, as_attachment=True, download_name=document.original_name or document.filename)
        
        except Exception as e:
            current_app.logger.error(f"Error downloading document: {str(e)}")
            flash("Error downloading document", "error")
            return redirect(url_for('finance.financial_documents'))

    @app.route('/finance/documents/<int:doc_id>/view', endpoint='finance.view_finance_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def view_document(doc_id):
        """View a document in browser"""
        try:
            document = db.session.get(Document, doc_id)
            if not document:
                return "Document not found", 404
            
            upload_folder = os.path.join(current_app.root_path, 'uploads', 'finance_documents')
            file_path = os.path.join(upload_folder, document.filename)
            
            if not os.path.exists(file_path):
                return "File not found on server", 404
            
            return send_file(file_path, as_attachment=False)
        
        except Exception as e:
            current_app.logger.error(f"Error viewing document: {str(e)}")
            return "Error viewing document", 500

    @app.route('/finance/documents/<int:doc_id>/delete', methods=['DELETE'], endpoint='finance.delete_finance_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def delete_document(doc_id):
        """Delete a document"""
        try:
            document = db.session.get(Document, doc_id)
            if not document:
                return jsonify({'status': 'error', 'message': 'Document not found'}), 404
            
            # Delete physical file
            upload_folder = os.path.join(current_app.root_path, 'uploads', 'finance_documents')
            file_path = os.path.join(upload_folder, document.filename)
            if os.path.exists(file_path):
                os.remove(file_path)
            
            # Create audit log
            audit = Audit(
                name=f'Receipt Deleted: {document.original_name}' if document.category == 'receipt' else f'{document.category.title()} Deleted: {document.original_name}',
                date=datetime.now(),
                status='deleted',
                approved_by=current_user.name
            )
            db.session.add(audit)
            
            db.session.delete(document)
            db.session.commit()
            
            return jsonify({'status': 'success', 'message': 'Document deleted successfully'})
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting document: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)}), 500

# ===== DATA EXPORT ROUTES =====

    @app.route('/finance/export/bank-transactions/<format>', endpoint='finance.export_bank_transactions')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def export_bank_transactions(format):
        """Export bank transactions to Excel or CSV"""
        try:
        # Get query parameters for filtering
            account_id = request.args.get('account_id')
            start_date = request.args.get('start_date')
            end_date = request.args.get('end_date')
        
        # Build query
            query = db.session.query(BankTransaction).join(BankAccount)
        
            if account_id:
                query = query.filter(BankTransaction.account_id == account_id)
            if start_date:
                query = query.filter(BankTransaction.transaction_date >= datetime.strptime(start_date, '%Y-%m-%d').date())
            if end_date:
                query = query.filter(BankTransaction.transaction_date <= datetime.strptime(end_date, '%Y-%m-%d').date())
            
            transactions = query.order_by(BankTransaction.transaction_date.desc()).all()
        
        # Prepare data for export
            data = []
            for txn in transactions:
                data.append({
                    'Date': txn.transaction_date.strftime('%Y-%m-%d'),
                    'Account': txn.bank_account.account_name,
                    'Bank': txn.bank_account.bank_name,
                    'Type': txn.transaction_type,
                    'Amount': txn.amount,
                    'Description': txn.description or '',
                    'Reference': txn.reference_number or '',
                    'Reconciled': 'Yes' if txn.is_reconciled else 'No',
                    'Created At': txn.created_at.strftime('%Y-%m-%d %H:%M:%S')
                })
        
            df = pd.DataFrame(data)
        
            if format.lower() == 'excel':
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, sheet_name='Bank Transactions', index=False)
                output.seek(0)
            
                filename = f"bank_transactions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                )
            
            elif format.lower() == 'csv':
                output = BytesIO()
                df.to_csv(output, index=False)
                output.seek(0)
            
                filename = f"bank_transactions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='text/csv'
                )
            else:
                return jsonify({'error': 'Invalid format. Use excel or csv'}), 400
            
        except Exception as e:
            current_app.logger.error(f"Error exporting transactions: {str(e)}")
            flash('Error exporting data', 'error')
            return redirect(url_for('finance.bank_reconciliation'))

    @app.route('/finance/export/bank-reconciliations/<format>', endpoint='finance.export_bank_reconciliations')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def export_bank_reconciliations(format):
        """Export bank reconciliations to Excel or CSV"""
        try:
        # Get reconciliations using actual schema
            reconciliations = db.session.execute(
                db.text('''
                    SELECT 
                        account_name,
                        statement_date,
                        balance,
                        status,
                        created_at
                    FROM bank_reconciliations 
                    ORDER BY created_at DESC
                ''')
            ).fetchall()
        
        # Prepare data for export
            data = []
            for rec in reconciliations:
                data.append({
                    'Account': rec[0],
                    'Statement Date': rec[1],
                    'Balance': rec[2],
                    'Status': rec[3],
                    'Created At': rec[4] if isinstance(rec[4], str) else rec[4].strftime('%Y-%m-%d %H:%M:%S')
                })
        
            df = pd.DataFrame(data)
        
            if format.lower() == 'excel':
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, sheet_name='Bank Reconciliations', index=False)
                output.seek(0)
            
                filename = f"bank_reconciliations_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                )
            
            elif format.lower() == 'csv':
                output = BytesIO()
                df.to_csv(output, index=False)
                output.seek(0)
            
                filename = f"bank_reconciliations_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='text/csv'
                )
            else:
                return jsonify({'error': 'Invalid format. Use excel or csv'}), 400
            
        except Exception as e:
            current_app.logger.error(f"Error exporting reconciliations: {str(e)}")
            flash('Error exporting data', 'error')
            return redirect(url_for('finance.bank_reconciliation'))

    @app.route('/finance/export/expenses/<format>', endpoint='finance.export_expenses')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def export_expenses(format):
        """Export expenses to Excel or CSV"""
        try:
        # Get query parameters for filtering
            status_filter = request.args.get('status', 'all')
            category_filter = request.args.get('category', 'all')
            start_date = request.args.get('start_date')
            end_date = request.args.get('end_date')
        
        # Build query
            query = Expense.query
        
            if status_filter != 'all':
                query = query.filter(Expense.status == status_filter)
            if category_filter != 'all':
                query = query.filter(Expense.category == category_filter)
            if start_date:
                query = query.filter(Expense.date >= datetime.strptime(start_date, '%Y-%m-%d').date())
            if end_date:
                query = query.filter(Expense.date <= datetime.strptime(end_date, '%Y-%m-%d').date())
            
            expenses = query.order_by(Expense.date.desc()).all()
        
        # Prepare data for export
            data = []
            for expense in expenses:
                data.append({
                    'Date': expense.date.strftime('%Y-%m-%d'),
                    'Category': expense.category,
                    'Description': expense.description,
                    'Amount': expense.amount,
                    'Status': expense.status,
                    'Created At': expense.date.strftime('%Y-%m-%d %H:%M:%S') if hasattr(expense, 'created_at') else expense.date.strftime('%Y-%m-%d')
                })
        
            df = pd.DataFrame(data)
        
            if format.lower() == 'excel':
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, sheet_name='Expenses', index=False)
                output.seek(0)
            
                filename = f"expenses_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                )
            
            elif format.lower() == 'csv':
                output = BytesIO()
                df.to_csv(output, index=False)
                output.seek(0)
            
                filename = f"expenses_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='text/csv'
                )
            else:
                return jsonify({'error': 'Invalid format. Use excel or csv'}), 400
            
        except Exception as e:
            current_app.logger.error(f"Error exporting expenses: {str(e)}")
            flash('Error exporting expenses data', 'error')
            return redirect(url_for('finance.expenses'))

    @app.route('/finance/expenses/<int:expense_id>', endpoint='finance.expense_details')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def expense_details(expense_id):
        """View expense details"""
        try:
            expense = Expense.query.get_or_404(expense_id)
            return render_template('finance/expense_details.html', expense=expense)
        except Exception as e:
            current_app.logger.error(f"Error loading expense details: {str(e)}")
            flash('Error loading expense details', 'error')
            return redirect(url_for('finance.expenses'))

    @app.route('/finance/export/account-summary/<format>', endpoint='finance.export_account_summary')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def export_account_summary(format):
        """Export account summary with balances and transaction counts"""
        try:
        # Get all bank accounts with transaction summaries
            accounts = BankAccount.query.all()
        
            data = []
            for account in accounts:
            # Get transaction counts
                total_transactions = BankTransaction.query.filter_by(account_id=account.id).count()
                credit_total = db.session.query(func.sum(BankTransaction.amount)).filter(
                    BankTransaction.account_id == account.id,
                    BankTransaction.transaction_type == 'Credit'
                ).scalar() or 0
                debit_total = db.session.query(func.sum(BankTransaction.amount)).filter(
                    BankTransaction.account_id == account.id,
                    BankTransaction.transaction_type == 'Debit'
                ).scalar() or 0
            
                data.append({
                    'Account Name': account.account_name,
                    'Account Number': account.account_number,
                    'Bank': account.bank_name,
                    'Account Type': account.account_type,
                    'Current Balance': account.current_balance,
                    'Book Balance': account.book_balance,
                    'Difference': account.current_balance - account.book_balance,
                    'Total Transactions': total_transactions,
                    'Total Credits': credit_total,
                    'Total Debits': debit_total,
                    'Status': 'Active' if account.is_active else 'Inactive',
                    'Created': account.created_at.strftime('%Y-%m-%d'),
                    'Last Updated': account.updated_at.strftime('%Y-%m-%d %H:%M:%S')
                })
        
            df = pd.DataFrame(data)
        
            if format.lower() == 'excel':
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, sheet_name='Account Summary', index=False)
                output.seek(0)
            
                filename = f"account_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                )
            
            elif format.lower() == 'csv':
                output = BytesIO()
                df.to_csv(output, index=False)
                output.seek(0)
            
                filename = f"account_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
                return send_file(
                    output,
                    as_attachment=True,
                    download_name=filename,
                    mimetype='text/csv'
                )
            else:
                return jsonify({'error': 'Invalid format. Use excel or csv'}), 400
            
        except Exception as e:
            current_app.logger.error(f"Error exporting account summary: {str(e)}")
            flash('Error exporting data', 'error')
            return redirect(url_for('finance.bank_reconciliation'))

    @app.route('/finance/account/<int:account_id>/transactions', endpoint='finance.view_account_transactions')
    @role_required([Roles.SUPER_HQ, Roles.HQ_FINANCE])
    def view_account_transactions(account_id):
        """View transactions for a specific account"""
        try:
            account = BankAccount.query.get_or_404(account_id)
            
            # Get page parameter for pagination
            page = request.args.get('page', 1, type=int)
            per_page = 20
            
            # Get transactions with pagination
            transactions = BankTransaction.query.filter_by(account_id=account_id)\
                .order_by(BankTransaction.transaction_date.desc())\
                .paginate(page=page, per_page=per_page, error_out=False)
            
            # Calculate summary statistics
            total_credits = db.session.query(func.sum(BankTransaction.amount)).filter(
                BankTransaction.account_id == account_id,
                BankTransaction.transaction_type == 'Credit'
            ).scalar() or 0
            
            total_debits = db.session.query(func.sum(BankTransaction.amount)).filter(
                BankTransaction.account_id == account_id,
                BankTransaction.transaction_type == 'Debit'
            ).scalar() or 0
            
            return render_template('finance/account_transactions.html',
                                 account=account,
                                 transactions=transactions,
                                 total_credits=total_credits,
                                 total_debits=total_debits)
                             
        except Exception as e:
            current_app.logger.error(f"Error viewing account transactions: {str(e)}")
            flash('Error loading account transactions', 'error')
            return redirect(url_for('finance.bank_reconciliation'))


    # ============================================================================
    # ROUTES FROM HR.PY
    # ============================================================================

    from sqlalchemy import func, extract



# --- Staff Role Assignment Endpoint ---
    @app.route('/hr/staff/<int:staff_id>/assign_role', methods=["POST"], endpoint='hr.assign_role')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def assign_role(staff_id):
        emp = db.session.get(Employee, staff_id)
        if not emp:
            flash("Staff not found", "error")
            return redirect(url_for('hr.staff_details', staff_id=staff_id))
        role_id = request.form.get('role_id')
        role = db.session.get(Role, role_id) if role_id else None
        if role:
            emp.role = role.name
            db.session.commit()
            flash(f"Role '{role.name}' assigned to {emp.name}", "success")
        else:
            flash("Invalid role selected", "error")
        return redirect(url_for('hr.staff_details', staff_id=staff_id))

# --- Add Staff (HTML form) ---
    @app.route('/hr/staff/add', methods=["POST"], endpoint='hr.add_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def add_staff():
        try:
            name = (request.form.get('name') or '').strip()
            staff_code = (request.form.get('staff_code') or '').strip()
            email = (request.form.get('email') or '').strip() or None
            phone = (request.form.get('phone') or '').strip() or None
            dob_raw = (request.form.get('dob') or '').strip()
            address = (request.form.get('address') or '').strip() or None
            emergency_contact_name = (request.form.get('emergency_contact_name') or '').strip() or None
            emergency_contact_phone = (request.form.get('emergency_contact_phone') or '').strip() or None
            employment_date_raw = (request.form.get('employment_date') or '').strip()
            designation = (request.form.get('designation') or '').strip()
            site_department = (request.form.get('site_department') or '').strip()
            employment_type = (request.form.get('employment_type') or '').strip() or None
            bank_name = (request.form.get('bank_name') or '').strip()
            account_number = (request.form.get('account_number') or '').strip()
            work_days = request.form.get('work_days')
            basic_salary = (request.form.get('basic_salary') or '').strip()
            status = (request.form.get('status') or 'Active').strip()

            if not name:
                flash('Name is required', 'error')
                return redirect(url_for('hr.staff_list'))

        # Parse date
            emp_date = None
            if employment_date_raw:
                for fmt in ('%Y-%m-%d', '%d/%m/%Y', '%d-%m-%Y', '%m/%d/%Y'):
                    try:
                        emp_date = datetime.strptime(employment_date_raw, fmt).date()
                        break
                    except Exception:
                        continue

        # Parse date of birth
            dob_date = None
            if dob_raw:
                for fmt in ('%Y-%m-%d', '%d/%m/%Y', '%d-%m-%Y', '%m/%d/%Y'):
                    try:
                        dob_date = datetime.strptime(dob_raw, fmt).date()
                        break
                    except Exception:
                        continue

        # Create employee
            emp = Employee(name=name)
            emp.staff_code = staff_code or None
        
        # Handle email uniqueness - if email already exists, make it unique
            if email:
                existing_email = Employee.query.filter_by(email=email).first()
                if existing_email:
                # Make email unique by appending a counter
                    counter = 1
                    base_email = email.split('@')[0]
                    domain = email.split('@')[1] if '@' in email else 'company.com'
                    unique_email = f"{base_email}+{counter}@{domain}"
                
                    while Employee.query.filter_by(email=unique_email).first():
                        counter += 1
                        unique_email = f"{base_email}+{counter}@{domain}"
                
                    emp.email = unique_email
                    flash(f'Email {email} already exists. Created staff with email: {unique_email}', 'info')
                else:
                    emp.email = email
            else:
                emp.email = None
            
            emp.phone = phone
            emp.dob = dob_date
            emp.current_address = address
            emp.next_of_kin = emergency_contact_name
            emp.next_of_kin_phone = emergency_contact_phone
            emp.department = site_department or None
            emp.site = site_department or None
            emp.position = designation or None
            emp.employment_type = employment_type
            emp.status = status or 'Active'
            emp.date_of_employment = emp_date
            db.session.add(emp)
            db.session.flush()  # Get emp.id without committing yet

        # Create initial payroll breakdown entry for current period with bank and work days
            def to_int(v, default=0):
                try:
                    return int(v)
                except Exception:
                    return default

            def to_float(v, default=None):
                try:
                    if v is None or v == '':
                        return default
                    return float(str(v).replace(',', ''))
                except Exception:
                    return default

            sp = StaffPayroll(
                employee_id=emp.id,
                period_year=datetime.now().year,
                period_month=datetime.now().month,
                site=site_department or None,
                employment_date=emp_date,
                bank_name=bank_name or None,
                account_number=account_number or None,
                designation=designation or None,
                work_days=to_int(work_days),
                gross=to_float(basic_salary)
            )
            db.session.add(sp)
            db.session.commit()
            flash('Staff added successfully', 'success')
        except Exception as e:
            current_app.logger.error(f"Add staff error: {e}")
            flash('Failed to add staff', 'error')
        return redirect(url_for('hr.staff_list'))

# --- Staff Import/Export Endpoints (HTML/Python only) ---

    @app.route('/hr/staff/import', methods=["GET", "POST"], endpoint='hr.import_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def import_staff():
        message = None
        if request.method == "POST":
            file = request.files.get('file')
            if not file:
                message = "No file uploaded."
            else:
                try:
                    df = pd.read_excel(file)
                    created, updated = 0, 0
                    for _, row in df.iterrows():
                        emp = Employee.query.filter_by(email=row.get('email')).first()
                        if not emp:
                            emp = Employee()
                            created += 1
                        else:
                            updated += 1
                        emp.name = row.get('name')
                        emp.role = row.get('designation')
                        emp.status = 'Active'
                        emp.department = row.get('site')
                        emp.position = row.get('designation')
                        emp.phone = row.get('phone')
                        emp.email = row.get('email')
                        emp.grade = row.get('grade')
                        emp.salary = float(row.get('gross', 0))
                        emp.date_of_employment = datetime.strptime(str(row.get('employment_date')), '%d/%m/%Y').date() if row.get('employment_date') else None
                        db.session.add(emp)
                    db.session.commit()
                    message = f"Imported: {created} new, {updated} updated."
                except Exception as e:
                    message = f"Import failed: {str(e)}"
        return render_template('hr/staff/import_modal.html', message=message)

    @app.route('/hr/staff/export', methods=["GET"], endpoint='hr.export_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def export_staff():
        staff = Employee.query.all()
        data = []
        for emp in staff:
            data.append({
                'name': emp.name,
                'email': emp.email,
                'department': emp.department,
                'position': emp.position,
                'status': emp.status,
                'phone': emp.phone,
                'grade': getattr(emp, 'grade', ''),
                'salary': getattr(emp, 'salary', ''),
                'employment_date': emp.date_of_employment.strftime('%d/%m/%Y') if emp.date_of_employment else ''
            })
        df = pd.DataFrame(data)
    # Try xlsxwriter, then openpyxl, then fallback to CSV
        try:
            output = io.BytesIO()
            with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
                df.to_excel(writer, index=False)
            output.seek(0)
            return send_file(output, download_name="staff_list.xlsx", as_attachment=True)
        except Exception as e1:
            current_app.logger.warning(f"xlsxwriter unavailable or failed ({e1}); trying openpyxl for export")
            try:
                output = io.BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, index=False)
                output.seek(0)
                return send_file(output, download_name="staff_list.xlsx", as_attachment=True)
            except Exception as e2:
                current_app.logger.error(f"Excel export failed with both engines (xlsxwriter/openpyxl). Falling back to CSV. Error: {e2}")
                csv_buf = io.StringIO()
                df.to_csv(csv_buf, index=False)
                csv_bytes = io.BytesIO(csv_buf.getvalue().encode('utf-8'))
                csv_bytes.seek(0)
                return send_file(csv_bytes, download_name="staff_list.csv", as_attachment=True, mimetype='text/csv')

# --- Role Management Endpoints ---
# --- Role Management Endpoints ---
    @app.route('/hr/roles', methods=["GET", "POST"], endpoint='hr.manage_roles')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def manage_roles():
        message = None
        if request.method == "POST":
            action = request.form.get("action")
            name = request.form.get("name")
            role_id = request.form.get("role_id")
            if action == "add" and name:
                if Role.query.filter_by(name=name).first():
                    message = "Role already exists."
                else:
                    role = Role(name=name)
                    db.session.add(role)
                    db.session.commit()
                    message = "Role added successfully."
            elif action == "edit" and role_id and name:
                role = db.session.get(Role, role_id)
                if role:
                    role.name = name
                    db.session.commit()
                    message = "Role updated successfully."
                else:
                    message = "Role not found."
            elif action == "delete" and role_id:
                role = db.session.get(Role, role_id)
                if role:
                    db.session.delete(role)
                    db.session.commit()
                    message = "Role deleted successfully."
                else:
                    message = "Role not found."
        roles = Role.query.order_by(Role.name.asc()).all()
        return render_template("hr/roles/index.html", roles=roles, message=message)



# --- Department Management (Server-side, Modal) ---
    @app.route('/hr/departments', methods=["GET", "POST"], endpoint='hr.manage_departments')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def manage_departments():
        departments = Department.query.order_by(Department.name.asc()).all()
        message = None
        if request.method == "POST":
            action = request.form.get('action')
            if action == 'add':
                name = request.form.get('name')
                description = request.form.get('description', '')
                if not name:
                    message = "Department name required."
                elif Department.query.filter_by(name=name).first():
                    message = "Department already exists."
                else:
                    dept = Department(name=name, description=description)
                    db.session.add(dept)
                    db.session.commit()
                    message = "Department added successfully."
            elif action == 'edit':
                dept_id = request.form.get('dept_id')
                name = request.form.get('name')
                description = request.form.get('description', '')
                dept = db.session.get(Department, dept_id)
                if dept:
                    dept.name = name
                    dept.description = description
                    db.session.commit()
                    message = "Department updated successfully."
                else:
                    message = "Department not found."
            elif action == 'delete':
                dept_id = request.form.get('dept_id')
                dept = db.session.get(Department, dept_id)
                if dept:
                    db.session.delete(dept)
                    db.session.commit()
                    message = "Department deleted successfully."
                else:
                    message = "Department not found."
            departments = Department.query.order_by(Department.name.asc()).all()
# Dashboard Route
        return render_template('hr/staff/departments_modal.html', departments=departments, message=message)

# Dashboard Route
    @app.route('/hr', endpoint='hr.hr_home')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def hr_home():
        try:
            total_staff = Employee.query.count()
            pending_queries = Query.query.filter_by(status='Pending').count() if hasattr(Query, 'status') else 0
            today = datetime.now().date()
            attendance_today = Attendance.query.filter_by(date=today, status='Present').count() if hasattr(Attendance, 'date') else 0
            pending_tasks = Task.query.filter_by(status='Pending').count() if hasattr(Task, 'status') else 0
            pending_payroll = Payroll.query.filter_by(status='Pending Approval').with_entities(db.func.sum(Payroll.amount)).scalar() or 0
            summary = {
                'total_staff': total_staff,
                'pending_queries': pending_queries,
                'attendance_today': attendance_today,
                'pending_tasks': pending_tasks,
                'pending_payroll': pending_payroll
            }
            return render_template('hr/index.html', summary=summary)
        except Exception as e:
            current_app.logger.error(f"HR dashboard error: {str(e)}")
            flash("Error loading HR dashboard", "error")
            return render_template('error.html'), 500

# Leave Management Routes
    @app.route('/hr/leave', endpoint='hr.leave_management')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def leave_management():
        try:
            leaves = {
                'pending': Leave.query.filter_by(status='Pending').count() if hasattr(Leave, 'status') else 0,
                'approved': Leave.query.filter_by(status='Approved').count() if hasattr(Leave, 'status') else 0,
                'rejected': Leave.query.filter_by(status='Rejected').count() if hasattr(Leave, 'status') else 0,
                'upcoming': Leave.query.filter(Leave.start > datetime.now().date()).count() if hasattr(Leave, 'start') else 0
            }
            leave_events = []
            for l in Leave.query.order_by(Leave.start.desc()).limit(20).all() if hasattr(Leave, 'start') else []:
                staff = db.session.get(Employee, l.employee_id) if hasattr(l, 'employee_id') else None
                leave_events.append({
                    'title': f"{staff.name if staff else 'Staff'} - {l.type if hasattr(l, 'type') else ''}",
                    'start': l.start.strftime('%Y-%m-%d') if hasattr(l, 'start') else '',
                    'end': l.end.strftime('%Y-%m-%d') if hasattr(l, 'end') else '',
                    'extendedProps': {
                        'status': l.status if hasattr(l, 'status') else '',
                        'type': l.type if hasattr(l, 'type') else '',
                        'staff': staff.name if staff else '',
                        'department': staff.department if staff and hasattr(staff, 'department') else ''
                    }
                })
            # Get active employees for dropdown
            employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
            return render_template('hr/leave/index.html', leaves=leaves, leave_events=leave_events, employees=employees)
        except Exception as e:
            current_app.logger.error(f"Leave management error: {str(e)}")
            flash("Error loading leave management", "error")
            return render_template('error.html'), 500

    @app.route('/hr/leave/create', methods=['POST'], endpoint='hr.create_leave')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def create_leave():
        try:
            employee_id = request.form.get('employee_id')
            leave_type = request.form.get('leave_type')
            start_date = request.form.get('start_date')
            end_date = request.form.get('end_date')
            reason = request.form.get('reason', '')
            
            # Validate required fields
            if not all([employee_id, leave_type, start_date, end_date]):
                flash("All required fields must be filled", "error")
                return redirect(url_for('hr.leave_management'))
            
            # Convert dates
            start = datetime.strptime(start_date, '%Y-%m-%d').date()
            end = datetime.strptime(end_date, '%Y-%m-%d').date()
            
            # Validate dates
            if end < start:
                flash("End date cannot be before start date", "error")
                return redirect(url_for('hr.leave_management'))
            
            # Create leave request
            new_leave = Leave(
                employee_id=employee_id,
                type=leave_type,
                start=start,
                end=end,
                status='Pending',
                created_at=datetime.now()
            )
            
            db.session.add(new_leave)
            db.session.commit()
            
            flash(f"Leave request created successfully for {leave_type}", "success")
            current_app.logger.info(f"Leave request created: {new_leave.id} for employee {employee_id}")
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating leave: {str(e)}")
            flash("Error creating leave request", "error")
        
        return redirect(url_for('hr.leave_management'))

# Staff Query Routes
    @app.route('/hr/queries', methods=['GET', 'POST'], endpoint='hr.staff_queries')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def staff_queries():
        try:
        
        # Handle POST request for creating new query
            if request.method == 'POST':
                try:
                    data = request.get_json() if request.is_json else request.form
                
                # Create new query
                    new_query = Query(
                        employee_id=data.get('employee_id'),
                        subject=data.get('subject'),
                        category=data.get('category'),
                        priority=data.get('priority'),
                        description=data.get('description'),
                        status='Pending',
                        submitted_at=datetime.now()
                    )
                
                    db.session.add(new_query)
                    db.session.commit()
                
                    current_app.logger.info(f"New query created: {new_query.id}")
                
                    if request.is_json:
                        return jsonify({
                            'success': True, 
                            'message': 'Query submitted successfully',
                            'query_id': new_query.id
                        })
                    else:
                        flash('Query submitted successfully', 'success')
                        return redirect(url_for('hr.staff_queries'))
                    
                except Exception as e:
                    current_app.logger.error(f"Error creating query: {str(e)}")
                    if request.is_json:
                        return jsonify({'success': False, 'error': str(e)}), 400
                    else:
                        flash('Error submitting query', 'error')
        
        # GET request - display queries and form
        # Calculate stats with fallback
            stats = {
                'total': 0,
                'pending': 0,
                'in_progress': 0,
                'resolved': 0
            }
        
            queries_list = []
            all_employees = []
        
        # Get employee data for form dropdown
            try:
                all_employees = Employee.query.filter_by(status='Active').order_by(Employee.name.asc()).all()
            except Exception as emp_error:
                current_app.logger.warning(f"Error loading employees: {emp_error}")
            # Fallback employee data
                all_employees = [
                    type('Employee', (), {'id': 1, 'name': 'John Doe', 'department': 'Engineering'}),
                    type('Employee', (), {'id': 2, 'name': 'Jane Smith', 'department': 'Finance'}),
                    type('Employee', (), {'id': 3, 'name': 'Mike Johnson', 'department': 'Operations'})
                ]
        
            try:
                if hasattr(Query, 'status'):
                    stats = {
                        'total': Query.query.count(),
                        'pending': Query.query.filter_by(status='Pending').count(),
                        'in_progress': Query.query.filter_by(status='In Progress').count(),
                        'resolved': Query.query.filter_by(status='Resolved').count()
                    }
                
                # Get recent queries
                    recent_queries = Query.query.order_by(Query.submitted_at.desc()).limit(20).all() if hasattr(Query, 'submitted_at') else Query.query.limit(20).all()
                
                    for q in recent_queries:
                        staff = None
                        if hasattr(q, 'employee_id') and q.employee_id:
                            staff = Employee.query.get(q.employee_id)
                    
                        queries_list.append({
                            'id': q.id,
                            'subject': getattr(q, 'subject', f'Query #{q.id}'),
                            'staff': staff.name if staff else 'Unknown Staff',
                            'department': staff.department if staff and hasattr(staff, 'department') else 'Not assigned',
                            'status': getattr(q, 'status', 'Pending'),
                            'priority': getattr(q, 'priority', 'Medium'),
                            'category': getattr(q, 'category', 'General'),
                            'submitted_at': q.submitted_at.strftime('%Y-%m-%d %H:%M:%S') if hasattr(q, 'submitted_at') and q.submitted_at else datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'description': getattr(q, 'description', 'No description available')
                        })
            except Exception as query_error:
                current_app.logger.warning(f"Error loading queries from database: {query_error}")
            # Provide fallback sample data
                stats = {
                    'total': 15,
                    'pending': 8,
                    'in_progress': 5,
                    'resolved': 2
                }
            
            # Create sample queries
                sample_queries = [
                    {
                        'id': 1,
                        'subject': 'Leave Request Clarification',
                        'staff': 'John Doe',
                        'department': 'Engineering',
                        'status': 'Pending',
                        'priority': 'Medium',
                        'category': 'Leave',
                        'submitted_at': (datetime.now() - timedelta(days=2)).strftime('%Y-%m-%d %H:%M:%S'),
                        'description': 'Need clarification on annual leave policy'
                    },
                    {
                        'id': 2,
                        'subject': 'Payroll Inquiry',
                        'staff': 'Jane Smith',
                        'department': 'Finance',
                        'status': 'In Progress',
                        'priority': 'High',
                        'category': 'Payroll',
                        'submitted_at': (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d %H:%M:%S'),
                        'description': 'Question about overtime calculation'
                    },
                    {
                        'id': 3,
                        'subject': 'Benefits Information',
                        'staff': 'Mike Johnson',
                        'department': 'Operations',
                        'status': 'Pending',
                        'priority': 'Low',
                        'category': 'Benefits',
                        'submitted_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'description': 'Request for health insurance details'
                    }
                ]
                queries_list = sample_queries
        
        # Get categories with fallback
            categories = []
            try:
                if hasattr(Query, 'category'):
                    cats = Query.query.with_entities(Query.category).distinct().all()
                    categories = [{'id': i+1, 'name': c[0]} for i, c in enumerate(cats) if c[0]]
            except Exception:
                pass
            
            if not categories:
                categories = [
                    {'id': 1, 'name': 'Leave'},
                    {'id': 2, 'name': 'Payroll'},
                    {'id': 3, 'name': 'Benefits'},
                    {'id': 4, 'name': 'General'}
                ]
        
            return render_template('hr/queries/index.html', 
                                 stats=stats, 
                                 queries=queries_list, 
                                 categories=categories,
                                 all_employees=all_employees)
        
        except Exception as e:
            current_app.logger.error(f"Staff queries error: {str(e)}", exc_info=True)
            flash("Error loading staff queries", "error")
            return render_template('error.html'), 500

    @app.route('/hr/queries/<int:query_id>', endpoint='hr.query_details')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def query_details(query_id):
        """View detailed information about a specific query"""
        try:
        
            query = Query.query.get_or_404(query_id)
            employee = Employee.query.get(query.employee_id) if hasattr(query, 'employee_id') and query.employee_id else None
        
            query_data = {
                'id': query.id,
                'subject': getattr(query, 'subject', f'Query #{query.id}'),
                'staff': employee.name if employee else 'Unknown Staff',
                'department': employee.department if employee and hasattr(employee, 'department') else 'Not assigned',
                'status': getattr(query, 'status', 'Pending'),
                'priority': getattr(query, 'priority', 'Medium'),
                'category': getattr(query, 'category', 'General'),
                'submitted_at': query.submitted_at.strftime('%Y-%m-%d %H:%M:%S') if hasattr(query, 'submitted_at') and query.submitted_at else datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'description': getattr(query, 'description', 'No description available')
            }
        
            if request.headers.get('Content-Type') == 'application/json':
                return jsonify(query_data)
        
            return render_template('hr/queries/details.html', query=query_data)
        
        except Exception as e:
            current_app.logger.error(f"Query details error: {str(e)}", exc_info=True)
            if request.headers.get('Content-Type') == 'application/json':
                return jsonify({'error': 'Query not found'}), 404
            flash("Query not found", "error")
            return redirect(url_for('hr.staff_queries'))

    @app.route('/hr/queries/<int:query_id>/update', methods=['POST'], endpoint='hr.update_query_status')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def update_query_status(query_id):
        """Update the status of a query"""
        try:
        
            query = Query.query.get_or_404(query_id)
            data = request.get_json() if request.is_json else request.form
        
            new_status = data.get('status')
            if new_status and new_status in ['Pending', 'In Progress', 'Resolved']:
                query.status = new_status
                db.session.commit()
            
                current_app.logger.info(f"Query {query_id} status updated to {new_status}")
            
                if request.is_json:
                    return jsonify({
                        'success': True, 
                        'message': f'Query status updated to {new_status}',
                        'status': new_status
                    })
                else:
                    flash(f'Query status updated to {new_status}', 'success')
                    return redirect(url_for('hr.staff_queries'))
            else:
                if request.is_json:
                    return jsonify({'success': False, 'error': 'Invalid status'}), 400
                else:
                    flash('Invalid status', 'error')
                    return redirect(url_for('hr.staff_queries'))
                
        except Exception as e:
            current_app.logger.error(f"Update query status error: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'error': str(e)}), 500
            else:
                flash('Error updating query status', 'error')
                return redirect(url_for('hr.staff_queries'))

# Attendance Management Routes
    @app.route('/hr/attendance', endpoint='hr.attendance')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def attendance():
        try:
            today = datetime.now().date()
        
        # Calculate attendance statistics for today
            attendance_data = {
                'present': Attendance.query.filter_by(date=today, status='Present').count() if hasattr(Attendance, 'date') else 0,
                'absent': Attendance.query.filter_by(date=today, status='Absent').count() if hasattr(Attendance, 'date') else 0,
                'late': Attendance.query.filter_by(date=today, status='Late').count() if hasattr(Attendance, 'date') else 0,
                'on_leave': Attendance.query.filter_by(date=today, status='On Leave').count() if hasattr(Attendance, 'date') else 0
            }
        
        # Get today's attendance logs with employee details
            attendance_logs = []
            all_employees = []
        
            try:
            # Get all active employees for the dropdown
                all_employees = Employee.query.filter_by(status='Active').order_by(Employee.name.asc()).all()
            
                if hasattr(Attendance, 'date') and hasattr(Attendance, 'employee_id'):
                # Get attendance records for today
                    today_attendance = db.session.query(Attendance, Employee).join(
                        Employee, Attendance.employee_id == Employee.id
                    ).filter(Attendance.date == today).order_by(Employee.name.asc()).all()
                
                    for attendance_record, employee in today_attendance:
                        attendance_logs.append({
                            'id': attendance_record.id,
                            'staff_name': employee.name,
                            'staff_id': employee.staff_code or f"EMP{employee.id:04d}",
                            'department': employee.department or 'Not assigned',
                            'check_in': attendance_record.checkin_time.strftime('%H:%M') if hasattr(attendance_record, 'checkin_time') and attendance_record.checkin_time else '--',
                            'check_out': attendance_record.checkout_time.strftime('%H:%M') if hasattr(attendance_record, 'checkout_time') and attendance_record.checkout_time else '--',
                            'status': attendance_record.status,
                            'employee_id': employee.id
                        })
            
            # If no logs for today, show some active employees as "Not marked"
                if not attendance_logs:
                    for emp in all_employees[:10]:  # Show first 10 employees
                        attendance_logs.append({
                            'id': None,
                            'staff_name': emp.name,
                            'staff_id': emp.staff_code or f"EMP{emp.id:04d}",
                            'department': emp.department or 'Not assigned',
                            'check_in': '--',
                            'check_out': '--',
                            'status': 'Not Marked',
                            'employee_id': emp.id
                        })
                    
            except Exception as log_error:
                current_app.logger.warning(f"Error loading attendance logs: {log_error}")
            # Fallback to getting active employees only
                all_employees = Employee.query.filter_by(status='Active').order_by(Employee.name.asc()).all()
                attendance_logs = []
        
            return render_template('hr/attendance/index.html', 
                                 attendance=attendance_data, 
                                 attendance_logs=attendance_logs,
                                 all_employees=all_employees)
        
        except Exception as e:
            current_app.logger.error(f"Attendance error: {str(e)}", exc_info=True)
            flash("Error loading attendance", "error")
            return render_template('error.html'), 500

    @app.route('/hr/attendance/record', methods=['POST'], endpoint='hr.record_attendance')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def record_attendance():
        """Record manual attendance entry"""
        try:
        
        # Get form data
            employee_id = request.form.get('employee_id', type=int)
            attendance_date = request.form.get('date')
            check_in = request.form.get('check_in')
            check_out = request.form.get('check_out')
            status = request.form.get('status', 'Present')
        
        # Validation
            if not employee_id:
                flash("Employee is required", "error")
                return redirect(url_for('hr.attendance'))
        
            if not attendance_date:
                flash("Date is required", "error")
                return redirect(url_for('hr.attendance'))
        
        # Parse date
            try:
                attendance_date = datetime.strptime(attendance_date, '%Y-%m-%d').date()
            except ValueError:
                flash("Invalid date format", "error")
                return redirect(url_for('hr.attendance'))
        
        # Check if employee exists
            employee = Employee.query.get(employee_id)
            if not employee:
                flash("Employee not found", "error")
                return redirect(url_for('hr.attendance'))
        
        # Check if attendance already exists for this date
            existing_attendance = Attendance.query.filter_by(
                employee_id=employee_id, 
                date=attendance_date
            ).first() if hasattr(Attendance, 'employee_id') else None
        
        # Parse check-in and check-out times
            check_in_time = None
            check_out_time = None
        
            if check_in:
                try:
                    check_in_time = datetime.strptime(check_in, '%H:%M').time()
                except ValueError:
                    flash("Invalid check-in time format", "error")
                    return redirect(url_for('hr.attendance'))
        
            if check_out:
                try:
                    check_out_time = datetime.strptime(check_out, '%H:%M').time()
                except ValueError:
                    flash("Invalid check-out time format", "error")
                    return redirect(url_for('hr.attendance'))
        
            if existing_attendance:
            # Update existing record
                existing_attendance.status = status
                if hasattr(existing_attendance, 'checkin_time'):
                    existing_attendance.checkin_time = check_in_time
                if hasattr(existing_attendance, 'checkout_time'):
                    existing_attendance.checkout_time = check_out_time
                if hasattr(existing_attendance, 'updated_at'):
                    existing_attendance.updated_at = datetime.now(timezone.utc)
            
                action = "updated"
            else:
            # Create new attendance record
                attendance_data = {
                    'employee_id': employee_id,
                    'date': attendance_date,
                    'status': status
                }
            
            # Add optional fields if they exist in the model
                if hasattr(Attendance, 'checkin_time'):
                    attendance_data['checkin_time'] = check_in_time
                if hasattr(Attendance, 'checkout_time'):
                    attendance_data['checkout_time'] = check_out_time
                if hasattr(Attendance, 'recorded_by'):
                    attendance_data['recorded_by'] = session.get('user_id')
                if hasattr(Attendance, 'created_at'):
                    attendance_data['created_at'] = datetime.now(timezone.utc)
            
                new_attendance = Attendance(**attendance_data)
                db.session.add(new_attendance)
                action = "recorded"
        
            db.session.commit()
        
            current_app.logger.info(f"Attendance {action} for {employee.name} on {attendance_date}: {status}")
            flash(f"Attendance {action} successfully for {employee.name}", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Record attendance error: {str(e)}", exc_info=True)
            flash("Error recording attendance", "error")
    
        return redirect(url_for('hr.attendance'))

# Task Assignment Routes
    @app.route('/hr/tasks', methods=['GET', 'POST'], endpoint='hr.tasks')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def tasks():
        try:
        
        # Handle POST request for creating new task
            if request.method == 'POST':
                try:
                    data = request.get_json() if request.is_json else request.form
                
                # For HR tasks, we'll create a general project or use a default one
                # Check if HR project exists, create if not
                    hr_project = Project.query.filter_by(name='HR Operations').first()
                    if not hr_project:
                        hr_project = Project(
                            name='HR Operations',
                            description='General HR tasks and operations',
                            start_date=datetime.now().date(),
                            end_date=(datetime.now() + timedelta(days=365)).date(),
                            budget=0.0,
                            status='Active'
                        )
                        db.session.add(hr_project)
                        db.session.flush()  # Get the ID
                
                # Create new task
                    new_task = Task(
                        title=data.get('title'),
                        status='Pending',
                        due_date=datetime.strptime(data.get('due_date'), '%Y-%m-%d').date() if data.get('due_date') else None,
                        project_id=hr_project.id,
                        from_item=data.get('assignee_id'),  # Store assignee ID in from_item field
                        to_item=data.get('priority', 'Medium'),  # Store priority in to_item field
                        quantity=0.0,
                        percent_complete=0.0
                    )
                
                # Store description and other details in a way that works with current model
                # We'll use the existing fields creatively for HR task management
                
                    db.session.add(new_task)
                    db.session.commit()
                
                    current_app.logger.info(f"New HR task created: {new_task.id}")
                
                    if request.is_json:
                        return jsonify({
                            'success': True, 
                            'message': 'Task assigned successfully',
                            'task_id': new_task.id
                        })
                    else:
                        flash('Task assigned successfully', 'success')
                        return redirect(url_for('hr.tasks'))
                    
                except Exception as e:
                    current_app.logger.error(f"Error creating task: {str(e)}")
                    if request.is_json:
                        return jsonify({'success': False, 'error': str(e)}), 400
                    else:
                        flash('Error assigning task', 'error')
        
        # GET request - display tasks and form
        # Calculate stats with fallback
            stats = {
                'total': 0,
                'completed': 0,
                'in_progress': 0,
                'pending': 0,
                'overdue': 0
            }
        
            tasks_by_status = {
                'todo': [],
                'in_progress': [],
                'completed': []
            }
        
            all_employees = []
        
        # Get employee data for form dropdown
            try:
                all_employees = Employee.query.filter_by(status='Active').order_by(Employee.name.asc()).all()
            except Exception as emp_error:
                current_app.logger.warning(f"Error loading employees: {emp_error}")
            # Fallback employee data
                all_employees = [
                    type('Employee', (), {'id': 1, 'name': 'John Doe', 'department': 'Engineering'}),
                    type('Employee', (), {'id': 2, 'name': 'Jane Smith', 'department': 'Finance'}),
                    type('Employee', (), {'id': 3, 'name': 'Mike Johnson', 'department': 'Operations'})
                ]
        
            try:
            # Get HR project tasks or create sample data
                hr_project = Project.query.filter_by(name='HR Operations').first()
                tasks_query = Task.query.filter_by(project_id=hr_project.id) if hr_project else Task.query.filter(Task.project_id.is_(None))
            
                if hasattr(Task, 'status'):
                    all_tasks = tasks_query.order_by(Task.due_date.asc()).all()
                
                    stats = {
                        'total': len(all_tasks),
                        'completed': len([t for t in all_tasks if t.status == 'Completed']),
                        'in_progress': len([t for t in all_tasks if t.status == 'In Progress']),
                        'pending': len([t for t in all_tasks if t.status in ['Pending', 'pending']]),
                        'overdue': len([t for t in all_tasks if t.due_date and t.due_date < datetime.now().date() and t.status != 'Completed'])
                    }
                
                # Organize tasks by status for kanban board
                    for t in all_tasks:
                        assignee = None
                        if t.from_item:  # Employee ID stored in from_item
                            try:
                                assignee = Employee.query.get(int(t.from_item))
                            except (ValueError, TypeError):
                                pass
                    
                        task_data = {
                            'id': t.id,
                            'title': t.title,
                            'assignee': assignee.name if assignee else 'Unassigned',
                            'assignee_id': t.from_item,
                            'due_date': t.due_date.strftime('%Y-%m-%d') if t.due_date else datetime.now().strftime('%Y-%m-%d'),
                            'priority': t.to_item or 'Medium',  # Priority stored in to_item
                            'status': t.status,
                            'description': f"Task progress: {t.percent_complete:.0f}%",
                            'progress': t.percent_complete,
                            'department': assignee.department if assignee and hasattr(assignee, 'department') else 'No department'
                        }
                    
                    # Categorize by status for kanban board
                        if t.status in ['Pending', 'pending']:
                            tasks_by_status['todo'].append(task_data)
                        elif t.status == 'In Progress':
                            tasks_by_status['in_progress'].append(task_data)
                        elif t.status == 'Completed':
                            tasks_by_status['completed'].append(task_data)
                    
            except Exception as task_error:
                current_app.logger.warning(f"Error loading tasks from database: {task_error}")
            # Provide fallback sample data
                stats = {
                    'total': 8,
                    'completed': 2,
                    'in_progress': 3,
                    'pending': 3,
                    'overdue': 1
                }
            
            # Create sample tasks organized by status
                sample_tasks = {
                    'todo': [
                        {
                            'id': 1,
                            'title': 'Employee Performance Review',
                            'assignee': 'Sarah Wilson',
                            'assignee_id': '1',
                            'due_date': (datetime.now() + timedelta(days=5)).strftime('%Y-%m-%d'),
                            'priority': 'High',
                            'status': 'Pending',
                            'description': 'Conduct quarterly performance reviews',
                            'progress': 0,
                            'department': 'HR'
                        },
                        {
                            'id': 2,
                            'title': 'Training Material Update',
                            'assignee': 'David Brown',
                            'assignee_id': '2',
                            'due_date': (datetime.now() + timedelta(days=10)).strftime('%Y-%m-%d'),
                            'priority': 'Medium',
                            'status': 'Pending',
                            'description': 'Update onboarding training materials',
                            'progress': 0,
                            'department': 'HR'
                        }
                    ],
                    'in_progress': [
                        {
                            'id': 3,
                            'title': 'Policy Documentation',
                            'assignee': 'Lisa Johnson',
                            'assignee_id': '3',
                            'due_date': (datetime.now() + timedelta(days=3)).strftime('%Y-%m-%d'),
                            'priority': 'High',
                            'status': 'In Progress',
                            'description': 'Complete HR policy documentation',
                            'progress': 60,
                            'department': 'HR'
                        }
                    ],
                    'completed': [
                        {
                            'id': 4,
                            'title': 'Staff Meeting Coordination',
                            'assignee': 'John Smith',
                            'assignee_id': '4',
                            'due_date': (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d'),
                            'priority': 'Medium',
                            'status': 'Completed',
                            'description': 'Organize monthly all-hands meeting',
                            'progress': 100,
                            'department': 'HR'
                        }
                    ]
                }
                tasks_by_status = sample_tasks
        
        # Department list for filters with fallback
            departments = []
            try:
                if hasattr(Employee, 'department'):
                    depts = Employee.query.with_entities(Employee.department).distinct().all()
                    departments = [{'id': i+1, 'name': d[0]} for i, d in enumerate(depts) if d[0]]
            except Exception:
                pass
            
            if not departments:
                departments = [
                    {'id': 1, 'name': 'Engineering'},
                    {'id': 2, 'name': 'HR'},
                    {'id': 3, 'name': 'Finance'},
                    {'id': 4, 'name': 'Operations'}
                ]
        
            return render_template('hr/tasks/index.html', 
                                 stats=stats, 
                                 tasks=tasks_by_status, 
                                 departments=departments,
                                 all_employees=all_employees)
        
        except Exception as e:
            current_app.logger.error(f"Tasks error: {str(e)}", exc_info=True)
            flash("Error loading tasks", "error")
            return render_template('error.html'), 500

    @app.route('/hr/tasks/<int:task_id>/update', methods=['POST'], endpoint='hr.update_task_status')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def update_task_status(task_id):
        """Update the status of a task"""
        try:
            task = Task.query.get_or_404(task_id)
            data = request.get_json() if request.is_json else request.form
            
            new_status = data.get('status')
            new_progress = data.get('progress', type=float)
            
            if new_status and new_status in ['Pending', 'In Progress', 'Completed', 'pending', 'in progress', 'completed']:
                task.status = new_status
                
                # Update progress based on status
                if new_status in ['Completed', 'completed']:
                    task.percent_complete = 100.0
                elif new_status in ['In Progress', 'in progress'] and new_progress is not None:
                    task.percent_complete = min(max(new_progress, 0), 100)
                elif new_status in ['Pending', 'pending']:
                    task.percent_complete = 0.0
                
                task.updated_at = datetime.now(timezone.utc)
                db.session.commit()
                
                current_app.logger.info(f"Task {task_id} status updated to {new_status}")
                
                if request.is_json:
                    return jsonify({
                        'success': True, 
                        'message': f'Task status updated to {new_status}',
                        'status': new_status,
                        'progress': task.percent_complete
                    })
                else:
                    flash(f'Task status updated to {new_status}', 'success')
                    return redirect(url_for('hr.tasks'))
            else:
                if request.is_json:
                    return jsonify({'success': False, 'error': 'Invalid status'}), 400
                else:
                    flash('Invalid status', 'error')
                    return redirect(url_for('hr.tasks'))
                
        except Exception as e:
            current_app.logger.error(f"Update task status error: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'error': str(e)}), 500
            else:
                flash('Error updating task status', 'error')
                return redirect(url_for('hr.tasks'))

    @app.route('/hr/tasks/<int:task_id>', endpoint='hr.task_details')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def task_details(task_id):
        """View detailed information about a specific task"""
        try:
        
            task = Task.query.get_or_404(task_id)
        
        # Get assignee information
            assignee = None
            if task.from_item:  # Employee ID stored in from_item
                try:
                    assignee = Employee.query.get(int(task.from_item))
                except (ValueError, TypeError):
                    pass
        
            task_data = {
                'id': task.id,
                'title': task.title,
                'assignee': assignee.name if assignee else 'Unassigned',
                'assignee_id': task.from_item,
                'department': assignee.department if assignee and hasattr(assignee, 'department') else 'Not assigned',
                'status': task.status,
                'priority': task.to_item or 'Medium',
                'due_date': task.due_date.strftime('%Y-%m-%d') if task.due_date else datetime.now().strftime('%Y-%m-%d'),
                'progress': task.percent_complete,
                'created_at': task.created_at.strftime('%Y-%m-%d %H:%M:%S') if task.created_at else datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'updated_at': task.updated_at.strftime('%Y-%m-%d %H:%M:%S') if task.updated_at else datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'description': f"Task progress: {task.percent_complete:.0f}%"
            }
        
            if request.headers.get('Content-Type') == 'application/json':
                return jsonify(task_data)
        
            return render_template('hr/tasks/details.html', task=task_data)
        
        except Exception as e:
            current_app.logger.error(f"Task details error: {str(e)}", exc_info=True)
            if request.headers.get('Content-Type') == 'application/json':
                return jsonify({'error': 'Task not found'}), 404
            flash("Task not found", "error")
            return redirect(url_for('hr.tasks'))

# Payroll Routes
    @app.route('/hr/payroll', endpoint='hr.payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def payroll():
        try:
            current_app.logger.info("Starting payroll route processing")
        
        # Current period calculations
            current_date = datetime.now()
            current_month = current_date.month
            current_year = current_date.year
        
            current_app.logger.info(f"Current date info: {current_date}, month: {current_month}, year: {current_year}")
        
        # Calculate total payroll for current month
            total_payroll = db.session.query(db.func.sum(StaffPayroll.balance_salary)).filter(
                StaffPayroll.period_year == current_year,
                StaffPayroll.period_month == current_month
            ).scalar() or 0
        
            current_app.logger.info(f"Total payroll calculated: {total_payroll}")
        
        # Staff counts by employment type - using fallback for missing employment_type field
            total_active_staff = Employee.query.filter_by(status='Active').count()
            regular_staff = total_active_staff  # Fallback - assume all are regular for now
            contract_staff = 0  # Will be 0 until employment_type field is added
            part_time_staff = 0  # Will be 0 until employment_type field is added
        
        # Calculate next payday (usually end of month + 5 days)
            last_day = calendar.monthrange(current_year, current_month)[1]
            next_payday = datetime(current_year, current_month, last_day) + timedelta(days=5)
        
        # Debug: Check the type of next_payday
            current_app.logger.info(f"next_payday type: {type(next_payday)}, value: {next_payday}")
        
        # Recent payroll activities
            activities = []
            recent_payrolls = PayrollHistory.query.order_by(PayrollHistory.created_at.desc()).limit(10).all()
            current_app.logger.info(f"Found {len(recent_payrolls)} payroll history records")
        
            for pr in recent_payrolls:
                try:
                    current_app.logger.info(f"Processing payroll record: created_at type={type(pr.created_at)}, period_start type={type(pr.period_start)}")
                
                # Handle date formatting properly
                    if pr.created_at:
                        date_str = pr.created_at.strftime('%Y-%m-%d')
                    else:
                        date_str = 'N/A'
                
                    if pr.period_start:
                    # Check if period_start is a date/datetime object or string
                        if hasattr(pr.period_start, 'strftime'):
                            period_str = pr.period_start.strftime('%B %Y')
                        else:
                        # Convert to string safely
                            period_str = f"{pr.period_start}"
                    else:
                        period_str = "Unknown Period"
                
                    activities.append({
                        'date': date_str,
                        'description': f'Payroll processed for {period_str}',
                        'amount': pr.total_payroll or 0,
                        'status': 'Completed'
                    })
                except (AttributeError, TypeError) as e:
                    current_app.logger.error(f"Error processing payroll history: {e}")
                # Skip this record if there's an issue with the data
                    continue
        
        # Get pending payroll items and approval status
            pending_payrolls = StaffPayroll.query.filter(
                StaffPayroll.period_year == current_year,
                StaffPayroll.period_month == current_month
            ).count()
        
        # Get current month's payroll approval status
            current_app.logger.info("Querying PayrollApproval")
            current_approval = PayrollApproval.query.filter(
                PayrollApproval.period_year == current_year,
                PayrollApproval.period_month == current_month
            ).first()
        
            current_app.logger.info(f"Current approval found: {current_approval}")
        
            approval_status = 'draft'
            approval_details = None
        
            if current_approval:
                approval_status = current_approval.status
                current_app.logger.info(f"Building approval details for approval ID: {current_approval.id}")
                approval_details = {
                    'id': current_approval.id,
                    'total_amount': current_approval.total_amount,
                    'employee_count': current_approval.employee_count,
                    'submitted_at': current_approval.submitted_at,
                    'admin_approved_at': current_approval.admin_approved_at,
                    'finance_processed_at': current_approval.finance_processed_at,
                    'rejection_reason': current_approval.rejection_reason
                }
        
            current_app.logger.info("Getting detailed payroll breakdown")
        # Get detailed payroll breakdown for current month
            current_payrolls = StaffPayroll.query.filter(
                StaffPayroll.period_year == current_year,
                StaffPayroll.period_month == current_month
            ).all()
        
            current_app.logger.info(f"Found {len(current_payrolls)} current payrolls")
        
        # Calculate detailed totals
            current_app.logger.info("Calculating totals")
            total_gross = sum([p.gross or 0 for p in current_payrolls])
            total_deductions = sum([
                (p.loan_or_salary_advance or 0) + 
                (p.jaco or 0) + 
                (p.minna_paye or 0) + 
                (p.late_deduction or 0) 
                for p in current_payrolls
            ])
            total_net = sum([p.balance_salary or 0 for p in current_payrolls])
        
            current_app.logger.info(f"Totals calculated - Gross: {total_gross}, Deductions: {total_deductions}, Net: {total_net}")
        
            current_app.logger.info("Building payroll data dictionary")
        
            try:
            # Build each field carefully to identify the issue
                next_payday_str = next_payday.strftime('%B %d, %Y') if isinstance(next_payday, datetime) else "Invalid Date"
                current_month_str = current_date.strftime('%B') if isinstance(current_date, datetime) else "Invalid Month"
            
                current_app.logger.info(f"Date strings created - next_payday: {next_payday_str}, current_month: {current_month_str}")
            
                payroll_data = {
                    'total_payroll': total_net,
                    'total_gross': total_gross,
                    'total_deductions': total_deductions,
                    'regular_staff': regular_staff,
                    'contract_staff': contract_staff,
                    'part_time_staff': part_time_staff,
                    'next_payday': next_payday_str,
                    'current_month': current_month_str,
                    'current_year': current_year,
                    'current_month_num': current_month,
                    'pending_payrolls': pending_payrolls,
                    'employee_count': len(current_payrolls),
                    'approval_status': approval_status,
                    'approval_details': approval_details,
                    'has_current_payroll': len(current_payrolls) > 0
                }
            
                current_app.logger.info(f"Payroll data created successfully")
            
            except Exception as dict_error:
                current_app.logger.error(f"Error creating payroll data dictionary: {dict_error}")
                raise dict_error
        
            try:
                current_app.logger.info("About to render template")
                return render_template('hr/payroll/index.html', 
                                     payroll=payroll_data, 
                                     activities=activities)
            except Exception as template_error:
                current_app.logger.error(f"Template rendering error: {template_error}")
                raise template_error
                             
        except Exception as e:
            current_app.logger.error(f"Payroll error: {e}", exc_info=True)
            flash("Error loading payroll", "error")
            return render_template('error.html'), 500

# Payroll Processing Routes
# Staff Deduction Management Routes
    @app.route('/hr/deductions', endpoint='hr.manage_deductions')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def manage_deductions():
        """View and manage staff deductions"""
        try:
        
        # Get all active deductions with employee details
            deductions = db.session.query(StaffDeduction, Employee).join(
                Employee, StaffDeduction.employee_id == Employee.id
            ).filter(StaffDeduction.status.in_(['active', 'pending'])).all()
        
        # Calculate summary statistics
            total_active = StaffDeduction.query.filter_by(status='active').count()
            total_pending = StaffDeduction.query.filter_by(status='pending').count()
            total_amount = db.session.query(db.func.sum(StaffDeduction.amount)).filter_by(status='active').scalar() or 0
        
            deduction_list = []
            for deduction, employee in deductions:
                deduction_list.append({
                    'id': deduction.id,
                    'employee_name': employee.name,
                    'employee_id': employee.id,
                    'staff_code': getattr(employee, 'staff_code', ''),
                    'description': deduction.reason,  # reason field is used as description
                    'amount': deduction.amount,
                    'deduction_type': deduction.deduction_type,
                    'status': deduction.status,
                    'created_at': deduction.created_at.strftime('%Y-%m-%d') if deduction.created_at else '',
                    'notes': ''  # No notes field in model
                })
        
            stats = {
                'total_active': total_active,
                'total_pending': total_pending,
                'total_amount': total_amount,
                'total_deductions': len(deduction_list)
            }
        
        # Get all active employees for the add deduction form
            employees = Employee.query.filter_by(status='Active').order_by(Employee.name.asc()).all()
        
            return render_template('hr/deductions/index.html', 
                                 deductions=deduction_list, 
                                 stats=stats,
                                 employees=employees)
        
        except Exception as e:
            current_app.logger.error(f"Deductions management error: {str(e)}")
            flash("Error loading deductions", "error")
            return render_template('error.html'), 500

    @app.route('/hr/deductions/add', methods=['POST'], endpoint='hr.add_deduction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def add_deduction():
        """Add a new staff deduction"""
        try:
        
            employee_id = request.form.get('employee_id', type=int)
            description = request.form.get('description', '').strip()
            amount = request.form.get('amount', '').replace(',', '')
            deduction_type = request.form.get('deduction_type', '').strip()
            notes = request.form.get('notes', '').strip()  # Will be ignored since no notes field
        
        # Validation
            if not employee_id:
                flash("Employee is required", "error")
                return redirect(url_for('hr.manage_deductions'))
        
            if not description:
                flash("Description is required", "error")
                return redirect(url_for('hr.manage_deductions'))
        
            try:
                amount = float(amount)
                if amount <= 0:
                    flash("Amount must be greater than zero", "error")
                    return redirect(url_for('hr.manage_deductions'))
            except (ValueError, TypeError):
                flash("Invalid amount", "error")
                return redirect(url_for('hr.manage_deductions'))
        
        # Check if employee exists
            employee = Employee.query.get(employee_id)
            if not employee:
                flash("Employee not found", "error")
                return redirect(url_for('hr.manage_deductions'))
        
        # Create deduction using correct field names
            deduction = StaffDeduction(
                employee_id=employee_id,
                reason=description,  # Use reason field instead of description
                amount=amount,
                deduction_type=deduction_type or 'other',
                status='active',
                created_by=session.get('user_id', 1),  # Default to 1 if no user_id in session
                created_at=datetime.now()
            )
        
            db.session.add(deduction)
            db.session.commit()
        
            current_app.logger.info(f"Deduction added: {employee.name} - {description} - {amount:,.2f}")
            flash(f"Deduction added for {employee.name}: {description} - {amount:,.2f}", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Add deduction error: {str(e)}")
            flash("Error adding deduction", "error")
    
        return redirect(url_for('hr.manage_deductions'))

    @app.route('/hr/deductions/<int:deduction_id>/edit', methods=['POST'], endpoint='hr.edit_deduction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def edit_deduction(deduction_id):
        """Edit an existing deduction"""
        try:
        
            deduction = StaffDeduction.query.get_or_404(deduction_id)
        
            if deduction.status == 'completed':
                flash("Cannot edit completed deductions", "error")
                return redirect(url_for('hr.manage_deductions'))
        
            description = request.form.get('description', '').strip()
            amount = request.form.get('amount', '').replace(',', '')
            deduction_type = request.form.get('deduction_type', '').strip()
            notes = request.form.get('notes', '').strip()  # Will be ignored
            status = request.form.get('status', '').strip()
        
        # Validation
            if not description:
                flash("Description is required", "error")
                return redirect(url_for('hr.manage_deductions'))
        
            try:
                amount = float(amount)
                if amount <= 0:
                    flash("Amount must be greater than zero", "error")
                    return redirect(url_for('hr.manage_deductions'))
            except (ValueError, TypeError):
                flash("Invalid amount", "error")
                return redirect(url_for('hr.manage_deductions'))
        
        # Update deduction using correct field names
            deduction.reason = description  # Use reason field instead of description
            deduction.amount = amount
            deduction.deduction_type = deduction_type or deduction.deduction_type
            deduction.status = status or deduction.status
        
            db.session.commit()
        
            current_app.logger.info(f"Deduction updated: ID {deduction_id} - {description} - {amount:,.2f}")
            flash("Deduction updated successfully", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Edit deduction error: {str(e)}")
            flash("Error updating deduction", "error")
    
        return redirect(url_for('hr.manage_deductions'))

    @app.route('/hr/deductions/<int:deduction_id>/delete', methods=['POST'], endpoint='hr.delete_deduction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def delete_deduction(deduction_id):
        """Delete a deduction"""
        try:
        
            deduction = StaffDeduction.query.get_or_404(deduction_id)
        
            if deduction.status == 'completed':
                flash("Cannot delete completed deductions", "error")
                return redirect(url_for('hr.manage_deductions'))
        
            db.session.delete(deduction)
            db.session.commit()
        
            current_app.logger.info(f"Deduction deleted: ID {deduction_id}")
            flash("Deduction deleted successfully", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Delete deduction error: {str(e)}")
            flash("Error deleting deduction", "error")
    
        return redirect(url_for('hr.manage_deductions'))

    @app.route('/hr/payroll/review-draft', endpoint='hr.review_draft_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def review_draft_payroll():
        """Review and edit draft payroll before submission"""
        try:
        
            current_date = datetime.now()
        
        # Get draft payrolls for current month
            draft_payrolls = db.session.query(StaffPayroll, Employee).join(
                Employee, StaffPayroll.employee_id == Employee.id
            ).filter(
                StaffPayroll.period_year == current_date.year,
                StaffPayroll.period_month == current_date.month,
                StaffPayroll.approval_status == 'draft'
            ).all()
        
            if not draft_payrolls:
                flash("No draft payroll found for current month", "warning")
                return redirect(url_for('hr.payroll'))
        
        # Calculate totals
            total_gross = sum([p.gross or 0 for p, e in draft_payrolls])
            total_deductions = sum([
                (p.loan_or_salary_advance or 0) + 
                (p.jaco or 0) + 
                (p.minna_paye or 0) + 
                (p.late_deduction or 0) 
                for p, e in draft_payrolls
            ])
            total_net = sum([p.balance_salary or 0 for p, e in draft_payrolls])
        
            payroll_list = []
            for payroll, employee in draft_payrolls:
                payroll_list.append({
                    'id': payroll.id,
                    'employee_id': employee.id,
                    'employee_name': employee.name,
                    'staff_code': getattr(employee, 'staff_code', ''),
                    'department': employee.department or 'N/A',
                    'position': employee.position or 'N/A',
                    'gross': payroll.gross or 0,
                    'loan_or_salary_advance': payroll.loan_or_salary_advance or 0,
                    'jaco': payroll.jaco or 0,
                    'minna_paye': payroll.minna_paye or 0,
                    'late_deduction': payroll.late_deduction or 0,
                    'balance_salary': payroll.balance_salary or 0,
                    'work_days': payroll.work_days or 30,
                    'days_worked': payroll.days_worked or 30
                })
        
            summary = {
                'total_gross': total_gross,
                'total_deductions': total_deductions,
                'total_net': total_net,
                'employee_count': len(payroll_list),
                'period': current_date.strftime('%B %Y')
            }
        
            return render_template('hr/payroll/review_draft.html', 
                                 payrolls=payroll_list, 
                                 summary=summary)
        
        except Exception as e:
            current_app.logger.error(f"Review draft payroll error: {str(e)}")
            flash("Error loading draft payroll", "error")
            return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/update-draft', methods=['POST'], endpoint='hr.update_draft_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def update_draft_payroll():
        """Update individual payroll items in draft status"""
        try:
        
            payroll_id = request.form.get('payroll_id', type=int)
            gross = request.form.get('gross', type=float)
            loan_or_salary_advance = request.form.get('loan_or_salary_advance', type=float) or 0
            jaco = request.form.get('jaco', type=float) or 0
            minna_paye = request.form.get('minna_paye', type=float) or 0
            late_deduction = request.form.get('late_deduction', type=float) or 0
            work_days = request.form.get('work_days', type=int) or 30
            days_worked = request.form.get('days_worked', type=int) or 30
        
        # Get the payroll record
            payroll = StaffPayroll.query.get_or_404(payroll_id)
        
        # Only allow editing if status is draft
            if payroll.approval_status != 'draft':
                flash("Cannot edit payroll that is not in draft status", "error")
                return redirect(url_for('hr.review_draft_payroll'))
        
        # Update fields
            payroll.gross = gross
            payroll.loan_or_salary_advance = loan_or_salary_advance
            payroll.jaco = jaco
            payroll.minna_paye = minna_paye
            payroll.late_deduction = late_deduction
            payroll.work_days = work_days
            payroll.days_worked = days_worked
        
        # Recalculate balance salary
            total_deductions = loan_or_salary_advance + jaco + minna_paye + late_deduction
            payroll.balance_salary = gross - total_deductions
        
            db.session.commit()
        
            current_app.logger.info(f"Draft payroll updated for employee ID {payroll.employee_id}")
            flash("Payroll updated successfully", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Update draft payroll error: {str(e)}")
            flash("Error updating payroll", "error")
    
        return redirect(url_for('hr.review_draft_payroll'))

    @app.route('/hr/payroll/generate', methods=['POST'], endpoint='hr.generate_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def generate_payroll():
        """Generate comprehensive payroll using proper business logic with staff deductions"""
        try:
        
            period_start = request.form.get('period_start')
            period_end = request.form.get('period_end')
        
            if not period_start or not period_end:
                flash("Period start and end dates are required", "error")
                return redirect(url_for('hr.payroll'))
        
            start_date = datetime.strptime(period_start, '%Y-%m-%d')
            end_date = datetime.strptime(period_end, '%Y-%m-%d')
        
        # Get all active employees
            active_employees = Employee.query.filter_by(status='Active').all()
        
            if not active_employees:
                flash("No active employees found for payroll generation", "warning")
                return redirect(url_for('hr.payroll'))
        
        # Check if payroll already exists for this period
            existing_payroll = StaffPayroll.query.filter(
                StaffPayroll.period_year == start_date.year,
                StaffPayroll.period_month == start_date.month
            ).first()
        
            if existing_payroll:
                flash(f"Payroll already exists for {start_date.strftime('%B %Y')}", "warning")
                return redirect(url_for('hr.payroll'))
        
        # Get all active custom deductions grouped by employee
            staff_deductions_dict = {}
            active_deductions = StaffDeduction.query.filter_by(status='active').all()
        
            for deduction in active_deductions:
                if deduction.employee_id not in staff_deductions_dict:
                    staff_deductions_dict[deduction.employee_id] = []
                staff_deductions_dict[deduction.employee_id].append(deduction)
        
        # Process batch payroll
            payroll_batch = PayrollBatch()
            batch_result = payroll_batch.process_employees(
                employees=active_employees,
                staff_deductions_dict=staff_deductions_dict
            )
        
        # Save individual staff payrolls
            payroll_items = []
            for employee_payroll in batch_result['employees']:
                breakdown = employee_payroll['breakdown']
                employee = Employee.query.get(employee_payroll['employee_id'])
                
                # Calculate salary components
                gross = employee_payroll['gross_salary']
                basic_salary = gross * 0.6  # 60% basic salary
                housing_allowance = gross * 0.25  # 25% housing
                transport_allowance = gross * 0.10  # 10% transport
                meal_allowance = gross * 0.05  # 5% meal
            
            # Create StaffPayroll record with detailed breakdown
                staff_payroll = StaffPayroll(
                    employee_id=employee_payroll['employee_id'],
                    period_year=start_date.year,
                    period_month=start_date.month,
                    site=employee.site or 'Main Office',
                    employment_date=employee.date_of_employment,
                    designation=employee.position or employee.role,
                    work_days=30,  # Standard monthly working days
                    days_worked=30,  # Assume full attendance (can be modified later)
                    overtime_hours=breakdown.get('overtime_hours', 0),
                
                # Salary components breakdown
                    basic_salary=basic_salary,
                    housing_allowance=housing_allowance,
                    transport_allowance=transport_allowance,
                    meal_allowance=meal_allowance,
                    other_allowances=0,
                    
                # Total salary
                    gross=gross,
                    arrears=0,  # No arrears in standard calculation
                    rice_contribution=0,  # Not applicable
                
                # Deductions
                    loan_or_salary_advance=breakdown.get('total_custom_deductions', 0),
                    jaco=breakdown.get('statutory_deductions', {}).get('pension', 0),
                    minna_paye=breakdown.get('statutory_deductions', {}).get('paye_tax', 0),
                    late_deduction=0,  # No late deductions in standard calculation
                
                # Final salary
                    balance_salary=employee_payroll['net_salary'],
                
                # Approval workflow
                    approval_status='draft',
                    submitted_at=datetime.now(),
                    created_at=datetime.now()
                )
            
                payroll_items.append(staff_payroll)
            
            # Mark applied custom deductions as completed
                if employee_payroll['employee_id'] in staff_deductions_dict:
                    for deduction in staff_deductions_dict[employee_payroll['employee_id']]:
                        deduction.status = 'completed'
                        deduction.applied_at = datetime.now()
        
        # Save all payroll items
            for item in payroll_items:
                db.session.add(item)
        
        # Create comprehensive payroll history record
            summary = batch_result['summary']
            payroll_history = PayrollHistory(
                period_start=start_date,
                period_end=end_date,
                total_payroll=summary['total_net_salary'],
                total_deductions=summary['total_deductions'],
                generated_by=session.get('user_id'),
                created_at=datetime.now()
            )
        
            db.session.add(payroll_history)
            db.session.commit()
        
            current_app.logger.info(f"Comprehensive payroll generated: {summary['employee_count']} employees, "
                                   f"Total Gross: {summary['total_gross_salary']:,.2f}, "
                                   f"Total Deductions: {summary['total_deductions']:,.2f}, "
                                   f"Total Net: {summary['total_net_salary']:,.2f}")
        
            flash(f"Payroll generated successfully for {summary['employee_count']} employees. "
                  f"Total Net Payroll: {summary['total_net_salary']:,.2f}", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Payroll generation error: {str(e)}", exc_info=True)
            flash(f"Error generating payroll: {str(e)}", "error")
    
        return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/submit-for-approval', methods=['POST'], endpoint='hr.submit_payroll_for_approval')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def submit_payroll_for_approval():
        """Submit payroll for Finance approval with workflow"""
        try:
            period_year = request.form.get('period_year', type=int)
            period_month = request.form.get('period_month', type=int)
        
            if not period_year or not period_month:
                flash("Period year and month are required", "error")
                return redirect(url_for('hr.payroll'))
        
            # Get all draft payrolls for the specified period
            draft_payrolls = StaffPayroll.query.filter(
                StaffPayroll.period_year == period_year,
                StaffPayroll.period_month == period_month,
                StaffPayroll.approval_status == 'draft'
            ).all()
        
            if not draft_payrolls:
                flash(f"No draft payrolls found for {datetime(period_year, period_month, 1).strftime('%B %Y')}", "warning")
                return redirect(url_for('hr.payroll'))
        
            # Update all payrolls to pending finance status (workflow goes HR  Finance  Admin notified)
            for payroll in draft_payrolls:
                payroll.approval_status = 'pending_finance'
                payroll.submitted_at = datetime.now(timezone.utc)
        
            # Create payroll approval record
            total_amount = sum([p.balance_salary for p in draft_payrolls if p.balance_salary])
            total_employees = len(draft_payrolls)
        
            # Generate payroll reference number
            payroll_ref = f"PAY-{period_year}-{period_month:02d}"
            
            # Create payroll approval record
            payroll_approval = PayrollApproval(
                period_year=period_year,
                period_month=period_month,
                total_amount=total_amount,
                employee_count=total_employees,
                status='pending_finance',
                submitted_by=current_user.id,
                submitted_at=datetime.now(timezone.utc)
            )
        
            db.session.add(payroll_approval)
            db.session.flush()  # Get the payroll_approval ID
        
            # Import workflow utilities
            from utils.workflow import create_approval_workflow
            
            # Create approval workflow (HR  Finance, then notify Admin)
            workflow = create_approval_workflow(
                workflow_type='payroll',
                reference_id=payroll_approval.id,
                reference_number=payroll_ref,
                initiated_by=current_user.id,
                total_amount=total_amount,
                description=f"Payroll for {datetime(period_year, period_month, 1).strftime('%B %Y')} - {total_employees} employees",
                project_id=None,
                priority='high'  # Payroll is always high priority
            )
            
            db.session.commit()
        
            current_app.logger.info(f"Payroll submitted for approval: {total_employees} employees, "
                                   f"Total: {total_amount:,.2f} for {datetime(period_year, period_month, 1).strftime('%B %Y')}")
        
            flash(f"Payroll for {datetime(period_year, period_month, 1).strftime('%B %Y')} "
                  f"submitted to Finance for approval. Total: {total_amount:,.2f} ({total_employees} employees)", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Payroll submission error: {str(e)}", exc_info=True)
            flash(f"Error submitting payroll for approval: {str(e)}", "error")
    
        return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/approve/<int:payroll_id>', methods=['POST'], endpoint='hr.approve_payroll')
    @role_required([Roles.SUPER_HQ])
    def approve_payroll(payroll_id):
        """Approve payroll batch (Admin approval)"""
        try:
        
            payroll_approval = PayrollApproval.query.get_or_404(payroll_id)
        
            if payroll_approval.status != 'pending_admin':
                flash("Payroll is not in pending admin approval status", "warning")
                return redirect(url_for('hr.payroll'))
        
        # Update approval record
            payroll_approval.status = 'approved_by_admin'
            payroll_approval.admin_approved_by = session.get('user_id')
            payroll_approval.admin_approved_at = datetime.now()
        
        # Update all related staff payrolls
            staff_payrolls = StaffPayroll.query.filter(
                StaffPayroll.period_year == payroll_approval.period_year,
                StaffPayroll.period_month == payroll_approval.period_month,
                StaffPayroll.approval_status == 'pending_admin'
            ).all()
        
            for payroll in staff_payrolls:
                payroll.approval_status = 'approved_by_admin'
                payroll.approved_by_admin = session.get('user_id')
                payroll.admin_approved_at = datetime.now()
        
            db.session.commit()
        
            period_name = datetime(payroll_approval.period_year, payroll_approval.period_month, 1).strftime('%B %Y')
        
            current_app.logger.info(f"Payroll approved by admin: {period_name}, "
                                   f"Total: {payroll_approval.total_amount:,.2f}")
        
            flash(f"Payroll for {period_name} approved successfully. "
                  f"Ready for finance processing.", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Payroll approval error: {str(e)}", exc_info=True)
            flash(f"Error approving payroll: {str(e)}", "error")
    
        return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/reject/<int:payroll_id>', methods=['POST'], endpoint='hr.reject_payroll')
    @role_required([Roles.SUPER_HQ])
    def reject_payroll(payroll_id):
        """Reject payroll batch"""
        try:
        
            payroll_approval = PayrollApproval.query.get_or_404(payroll_id)
            rejection_reason = request.form.get('rejection_reason', '').strip()
        
            if not rejection_reason:
                flash("Rejection reason is required", "error")
                return redirect(url_for('hr.payroll'))
        
        # Update approval record
            payroll_approval.status = 'rejected'
            payroll_approval.rejection_reason = rejection_reason
            payroll_approval.rejected_by = session.get('user_id')
            payroll_approval.rejected_at = datetime.now()
        
        # Update all related staff payrolls back to draft
            staff_payrolls = StaffPayroll.query.filter(
                StaffPayroll.period_year == payroll_approval.period_year,
                StaffPayroll.period_month == payroll_approval.period_month,
                StaffPayroll.approval_status.in_(['pending_admin', 'approved_by_admin'])
            ).all()
        
            for payroll in staff_payrolls:
                payroll.approval_status = 'draft'
                payroll.approved_by_admin = None
                payroll.admin_approved_at = None
        
            db.session.commit()
        
            period_name = datetime(payroll_approval.period_year, payroll_approval.period_month, 1).strftime('%B %Y')
        
            current_app.logger.info(f"Payroll rejected: {period_name}, Reason: {rejection_reason}")
        
            flash(f"Payroll for {period_name} rejected. Reason: {rejection_reason}", "warning")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Payroll rejection error: {str(e)}", exc_info=True)
            flash(f"Error rejecting payroll: {str(e)}", "error")
    
        return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/process/<int:payroll_id>', methods=['POST'], endpoint='hr.process_payroll')
    @role_required([Roles.SUPER_HQ])  # Finance role would be ideal here
    def process_payroll(payroll_id):
        """Process approved payroll for payment (Finance processing)"""
        try:
        
            payroll_approval = PayrollApproval.query.get_or_404(payroll_id)
        
            if payroll_approval.status != 'approved_by_admin':
                flash("Payroll must be approved by admin before finance processing", "warning")
                return redirect(url_for('hr.payroll'))
        
        # Update approval record
            payroll_approval.status = 'processed_by_finance'
            payroll_approval.finance_processed_by = session.get('user_id')
            payroll_approval.finance_processed_at = datetime.now()
        
        # Update all related staff payrolls
            staff_payrolls = StaffPayroll.query.filter(
                StaffPayroll.period_year == payroll_approval.period_year,
                StaffPayroll.period_month == payroll_approval.period_month,
                StaffPayroll.approval_status == 'approved_by_admin'
            ).all()
        
            for payroll in staff_payrolls:
                payroll.approval_status = 'processed_by_finance'
                payroll.approved_by_finance = session.get('user_id')
                payroll.finance_approved_at = datetime.now()
        
            db.session.commit()
        
            period_name = datetime(payroll_approval.period_year, payroll_approval.period_month, 1).strftime('%B %Y')
        
            current_app.logger.info(f"Payroll processed by finance: {period_name}, "
                                   f"Total: {payroll_approval.total_amount:,.2f}")
        
            flash(f"Payroll for {period_name} processed successfully by finance. "
                  f"Ready for payment disbursement.", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Payroll processing error: {str(e)}", exc_info=True)
            flash(f"Error processing payroll: {str(e)}", "error")
    
        return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/staff', endpoint='hr.payroll_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def payroll_staff():
        """View staff payroll details"""
        try:
        
        # Get current month staff payrolls
            current_date = datetime.now()
        
            staff_payrolls = db.session.query(StaffPayroll, Employee).join(
                Employee, StaffPayroll.employee_id == Employee.id
            ).filter(
                StaffPayroll.period_year == current_date.year,
                StaffPayroll.period_month == current_date.month
            ).all()
        
            return render_template('hr/payroll/staff.html', staff_payrolls=staff_payrolls)
        
        except Exception as e:
            current_app.logger.error(f"Staff payroll error: {str(e)}")
            flash("Error loading staff payroll", "error")
            return redirect(url_for('hr.payroll'))

    @app.route('/hr/payroll/payslip/<int:employee_id>', endpoint='hr.generate_payslip')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def generate_payslip(employee_id):
        """Generate payslip for employee"""
        try:
        
            employee = Employee.query.get_or_404(employee_id)
        
        # Get current month's payroll
            current_date = datetime.now()
            staff_payroll = StaffPayroll.query.filter(
                StaffPayroll.employee_id == employee_id,
                StaffPayroll.period_year == current_date.year,
                StaffPayroll.period_month == current_date.month
            ).first()
        
            if not staff_payroll:
                flash("No payroll found for this employee for the current month", "error")
                return redirect(url_for('hr.payroll_staff'))
        
            current_app.logger.info(f"Generating payslip for employee {employee.name} (ID: {employee_id})")
        
            return render_template('hr/payroll/payslip.html', 
                                 employee=employee, 
                                 payroll=staff_payroll,
                                 period=current_date.strftime('%B %Y'),
                                 generated_date=current_date.strftime('%B %d, %Y'))
        
        except Exception as e:
            current_app.logger.error(f"Payslip generation error: {str(e)}", exc_info=True)
            flash(f"Error generating payslip: {str(e)}", "error")
            return redirect(url_for('hr.payroll_staff'))

# Staff Details Routes
    @app.route('/hr/staff', endpoint='hr.staff_list')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def staff_list():
        try:
        
        # Verify database connection
            try:
                db.session.query(Employee).first()
            except Exception as dbe:
                current_app.logger.error(f"Database connection error: {str(dbe)}")
                flash("Database connection error. Please try again later.", "error")
                return render_template('hr/staff/index.html', error=True, staff_list=[], stats={
                    'total_staff': 0, 'active': 0, 'departments': 0, 'new_staff': 0
                }, departments=[], roles=[])
        
        # Get stats
            try:
                stats = {
                    'total_staff': Employee.query.count(),
                    'active': Employee.query.filter_by(status='Active').count(),
                    'departments': Employee.query.with_entities(Employee.department).distinct().count(),
                    'new_staff': Employee.query.filter(
                        Employee.date_of_employment >= datetime.now().date() - timedelta(days=30)
                    ).count() if hasattr(Employee, 'date_of_employment') else 0
                }
            except Exception as se:
                current_app.logger.error(f"Error getting stats: {str(se)}")
                stats = {'total_staff': 0, 'active': 0, 'departments': 0, 'new_staff': 0}
        
        # Get staff list
            staff_list = []
            try:
                employees = Employee.query.order_by(Employee.date_of_employment.desc()).limit(50).all()
                for emp in employees:
                    staff_list.append({
                        'id': emp.id,
                        'staff_code': getattr(emp, 'staff_code', ''),
                        'name': emp.name,
                        'email': emp.email,
                        'department': emp.department if emp.department else 'Unassigned',
                        'position': emp.position if emp.position else 'Not set',
                        'role': emp.role if emp.role else 'Not assigned',
                        'status': emp.status if emp.status else 'Active',
                        'avatar_url': f"https://ui-avatars.com/api/?name={emp.name.replace(' ', '+')}&background=random"
                    })
            except Exception as le:
                current_app.logger.error(f"Error getting staff list: {str(le)}")
                flash("Error loading staff list", "error")
        
        # Get departments
            try:
                departments = []
                depts = Employee.query.with_entities(Employee.department).distinct().all()
                departments = [{'id': i+1, 'name': d[0] or 'Unassigned'} for i, d in enumerate(depts) if d[0]]
                if not departments:
                    departments = [
                        {'id': 1, 'name': 'Engineering'},
                        {'id': 2, 'name': 'HR'},
                        {'id': 3, 'name': 'Finance'},
                        {'id': 4, 'name': 'Operations'}
                    ]
            except Exception as de:
                current_app.logger.error(f"Error getting departments: {str(de)}")
                departments = []
            
        # Get roles
            try:
                roles = Role.query.all()
            except Exception as re:
                current_app.logger.error(f"Error getting roles: {str(re)}")
                roles = []
        
            return render_template('hr/staff/index.html', 
                                 stats=stats, 
                                 staff_list=staff_list, 
                                 departments=departments,
                                 roles=roles,
                                 error=False)
        except Exception as e:
            current_app.logger.error(f"Staff list error: {str(e)}")
            flash("Error loading staff list. Please try again later.", "error")
            return render_template('hr/staff/index.html', 
                                 error=True,
                                 staff_list=[],
                                 stats={'total_staff': 0, 'active': 0, 'departments': 0, 'new_staff': 0},
                                 departments=[],
                                 roles=[])

    @app.route('/hr/staff/<int:staff_id>', endpoint='hr.staff_details')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def staff_details(staff_id):
        try:
            emp = db.session.get(Employee, staff_id)
            if not emp:
                flash("Staff not found", "error")
                return render_template('error.html'), 404
        # Recent activities: could be fetched from logs or related tables
            recent_activities = []
        # Example: last 5 leaves
            leaves = Leave.query.filter_by(employee_id=emp.id).order_by(Leave.start.desc()).limit(5).all() if hasattr(Leave, 'employee_id') else []
            leave_history = []
            for l in leaves:
                leave_history.append({
                    'type': l.type if hasattr(l, 'type') else '',
                    'start_date': l.start.strftime('%Y-%m-%d') if hasattr(l, 'start') else '',
                    'end_date': l.end.strftime('%Y-%m-%d') if hasattr(l, 'end') else '',
                    'status': l.status if hasattr(l, 'status') else ''
                })
            staff = {
                'id': emp.id,
                'name': emp.name,
                'staff_code': getattr(emp, 'staff_code', ''),
                'email': emp.email,
                'phone': getattr(emp, 'phone', ''),
                'department': getattr(emp, 'department', ''),
                'position': getattr(emp, 'position', ''),
                'status': getattr(emp, 'status', ''),
                'role': getattr(emp, 'role', ''),
                'avatar_url': f"https://ui-avatars.com/api/?name={emp.name.replace(' ', '+')}",
                'dob': getattr(emp, 'dob', None),
                'current_address': getattr(emp, 'current_address', ''),
                'next_of_kin': getattr(emp, 'next_of_kin', ''),
                'next_of_kin_phone': getattr(emp, 'next_of_kin_phone', ''),
                'date_of_employment': getattr(emp, 'date_of_employment', None),
                'employment_type': getattr(emp, 'employment_type', ''),
                'gender': getattr(emp, 'gender', ''),
                'academic_qualification_at_employment': getattr(emp, 'academic_qualification_at_employment', ''),
                'institution': getattr(emp, 'institution', ''),
                'notes': getattr(emp, 'notes', ''),
                'manager': {},
                'recent_activities': recent_activities,
                'leave_history': leave_history,
                'attendance_records': [],  # TODO: Add actual attendance data
                'tasks': [],  # TODO: Add actual task data
                'documents': [],  # TODO: Add actual document data
                'performance_reviews': []  # TODO: Add actual performance data
            }
            roles = Role.query.order_by(Role.name.asc()).all()

        # Fetch payroll breakdowns
            payrolls = []
            try:
                for p in StaffPayroll.query.filter_by(employee_id=emp.id).order_by(StaffPayroll.created_at.desc()).limit(24).all():
                    payrolls.append({
                        'id': p.id,
                        'site': p.site or emp.department,
                        'employment_date': p.employment_date.strftime('%Y-%m-%d') if p.employment_date else (emp.date_of_employment.strftime('%Y-%m-%d') if getattr(emp, 'date_of_employment', None) else ''),
                        'bank_name': p.bank_name or '',
                        'account_number': p.account_number or '',
                        'designation': p.designation or emp.position,
                        'work_days': p.work_days or 0,
                        'days_worked': p.days_worked or 0,
                        'overtime_hours': p.overtime_hours or 0,
                        'gross': p.gross or 0.0,
                        'arrears': p.arrears or 0.0,
                        'rice_contribution': p.rice_contribution or 0.0,
                        'loan_or_salary_advance': p.loan_or_salary_advance or 0.0,
                        'jaco': p.jaco or 0.0,
                        'minna_paye': p.minna_paye or 0.0,
                        'late_deduction': p.late_deduction or 0.0,
                        'balance_salary': p.balance_salary or 0.0,
                        'period_year': p.period_year,
                        'period_month': p.period_month,
                    })
            except Exception as pe:
                current_app.logger.warning(f"Unable to load payroll breakdowns for staff {staff_id}: {pe}")

            return render_template('hr/staff/details.html', staff=staff, roles=roles, payrolls=payrolls)
        except Exception as e:
            current_app.logger.error(f"Staff details error: {str(e)}")
            flash("Error loading staff details", "error")
            return render_template('error.html'), 500


    @app.route('/hr/staff/<int:staff_id>/json', endpoint='hr.staff_details_json')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def staff_details_json(staff_id):
        """Return staff details as JSON for use in admin modals and AJAX."""
        try:
            emp = db.session.get(Employee, staff_id)
            if not emp:
                return jsonify({'error': 'Staff not found'}), 404

        # Build staff payload (mirror of staff_details)
            recent_activities = []
            leaves = Leave.query.filter_by(employee_id=emp.id).order_by(Leave.start.desc()).limit(5).all() if hasattr(Leave, 'employee_id') else []
            leave_history = []
            for l in leaves:
                leave_history.append({
                    'type': getattr(l, 'type', ''),
                    'start_date': l.start.strftime('%Y-%m-%d') if getattr(l, 'start', None) else None,
                    'end_date': l.end.strftime('%Y-%m-%d') if getattr(l, 'end', None) else None,
                    'status': getattr(l, 'status', '')
                })

            staff = {
                'id': emp.id,
                'name': emp.name,
                'staff_code': getattr(emp, 'staff_code', ''),
                'email': emp.email,
                'phone': getattr(emp, 'phone', ''),
                'department': getattr(emp, 'department', ''),
                'position': getattr(emp, 'position', ''),
                'status': getattr(emp, 'status', ''),
                'role': getattr(emp, 'role', ''),
                'avatar_url': f"https://ui-avatars.com/api/?name={emp.name.replace(' ', '+')}",
                'dob': getattr(emp, 'dob', None).isoformat() if getattr(emp, 'dob', None) else None,
                'current_address': getattr(emp, 'current_address', ''),
                'next_of_kin': getattr(emp, 'next_of_kin', ''),
                'next_of_kin_phone': getattr(emp, 'next_of_kin_phone', ''),
                'date_of_employment': getattr(emp, 'date_of_employment', None).isoformat() if getattr(emp, 'date_of_employment', None) else None,
                'employment_type': getattr(emp, 'employment_type', ''),
                'gender': getattr(emp, 'gender', ''),
                'academic_qualification_at_employment': getattr(emp, 'academic_qualification_at_employment', ''),
                'institution': getattr(emp, 'institution', ''),
                'notes': getattr(emp, 'notes', ''),
                'recent_activities': recent_activities,
                'leave_history': leave_history,
                'attendance_records': [],
                'tasks': [],
                'documents': [],
                'performance_reviews': []
            }

            payrolls = []
            try:
                for p in StaffPayroll.query.filter_by(employee_id=emp.id).order_by(StaffPayroll.created_at.desc()).limit(24).all():
                    payrolls.append({
                        'id': p.id,
                        'site': p.site or emp.department,
                        'employment_date': p.employment_date.isoformat() if getattr(p, 'employment_date', None) else (getattr(emp, 'date_of_employment', None).isoformat() if getattr(emp, 'date_of_employment', None) else None),
                        'bank_name': p.bank_name or '',
                        'account_number': p.account_number or '',
                        'designation': p.designation or emp.position,
                        'work_days': p.work_days or 0,
                        'days_worked': p.days_worked or 0,
                        'overtime_hours': p.overtime_hours or 0,
                        'gross': p.gross or 0.0,
                        'arrears': p.arrears or 0.0,
                        'period_year': p.period_year,
                        'period_month': p.period_month,
                    })
            except Exception:
                current_app.logger.warning(f"Unable to load payroll breakdowns for staff {staff_id}")

            return jsonify({'staff': staff, 'payrolls': payrolls})
        except Exception as e:
            current_app.logger.error(f"Staff details JSON error: {e}")
            return jsonify({'error': 'internal_error'}), 500
    @app.route('/hr/staff/<int:staff_id>/edit', methods=["GET", "POST"], endpoint='hr.edit_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def edit_staff(staff_id):
        try:
            emp = db.session.get(Employee, staff_id)
            if not emp:
                flash("Staff not found", "error")
                return redirect(url_for('hr.staff_list'))
            
            # GET request - show edit form
            if request.method == 'GET':
                # Prepare staff data
                staff_data = {
                    'id': emp.id,
                    'staff_code': getattr(emp, 'staff_code', ''),
                    'name': emp.name,
                    'email': emp.email,
                    'phone': emp.phone,
                    'dob': emp.dob,
                    'gender': getattr(emp, 'gender', ''),
                    'current_address': emp.current_address,
                    'next_of_kin': emp.next_of_kin,
                    'next_of_kin_phone': emp.next_of_kin_phone,
                    'date_of_employment': emp.date_of_employment,
                    'employment_type': emp.employment_type,
                    'position': emp.position,
                    'department': emp.department,
                    'status': emp.status,
                    'academic_qualification_at_employment': emp.academic_qualification_at_employment,
                    'institution': getattr(emp, 'institution', ''),
                    'notes': getattr(emp, 'notes', ''),
                    'avatar_url': f"https://ui-avatars.com/api/?name={emp.name.replace(' ', '+')}&background=random"
                }
                
                # Create a simple object to pass to template
                class StaffObj:
                    def __init__(self, data):
                        for key, value in data.items():
                            setattr(self, key, value)
                
                return render_template('hr/staff/edit.html', staff=StaffObj(staff_data))

        # Get form data
            name = (request.form.get('name') or '').strip()
            staff_code = (request.form.get('staff_code') or '').strip() or None
            email = (request.form.get('email') or '').strip() or None
            phone = (request.form.get('phone') or '').strip() or None
            dob_raw = (request.form.get('dob') or '').strip()
            address = (request.form.get('address') or '').strip() or None
            emergency_contact_name = (request.form.get('emergency_contact_name') or '').strip() or None
            emergency_contact_phone = (request.form.get('emergency_contact_phone') or '').strip() or None
            employment_date_raw = (request.form.get('employment_date') or '').strip()
            employment_type = (request.form.get('employment_type') or '').strip() or None
            designation = (request.form.get('designation') or '').strip() or None
            site_department = (request.form.get('site_department') or '').strip() or None
            status = (request.form.get('status') or '').strip() or 'Active'
            academic_qualification = (request.form.get('academic_qualification') or '').strip() or None
            institution = (request.form.get('institution') or '').strip() or None
            notes = (request.form.get('notes') or '').strip() or None

            if not name:
                flash("Name is required", "error")
                return redirect(url_for('hr.staff_details', staff_id=staff_id))

        # Parse dates
            dob_date = None
            if dob_raw:
                try:
                    dob_date = datetime.strptime(dob_raw, '%Y-%m-%d').date()
                except Exception:
                    pass

            emp_date = None
            if employment_date_raw:
                try:
                    emp_date = datetime.strptime(employment_date_raw, '%Y-%m-%d').date()
                except Exception:
                    pass

        # Handle email uniqueness
            if email and email != emp.email:
                existing_email = Employee.query.filter(Employee.email == email, Employee.id != emp.id).first()
                if existing_email:
                # Make email unique by appending a counter
                    counter = 1
                    base_email = email.split('@')[0]
                    domain = email.split('@')[1] if '@' in email else 'company.com'
                    unique_email = f"{base_email}+{counter}@{domain}"
                
                    while Employee.query.filter(Employee.email == unique_email, Employee.id != emp.id).first():
                        counter += 1
                        unique_email = f"{base_email}+{counter}@{domain}"
                
                    email = unique_email
                    flash(f'Email already exists. Updated to: {unique_email}', 'info')

        # Update employee
            emp.name = name
            emp.staff_code = staff_code
            emp.email = email
            emp.phone = phone
            emp.dob = dob_date
            emp.current_address = address
            emp.next_of_kin = emergency_contact_name
            emp.next_of_kin_phone = emergency_contact_phone
            emp.date_of_employment = emp_date
            emp.employment_type = employment_type
            emp.position = designation
            emp.department = site_department
            emp.site = site_department
            emp.status = status
            emp.academic_qualification_at_employment = academic_qualification
            emp.institution = institution
            emp.notes = notes
            emp.updated_at = datetime.now(timezone.utc)

            db.session.commit()
            flash("Staff information updated successfully", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Edit staff error: {str(e)}")
            flash("Error updating staff information", "error")

        return redirect(url_for('hr.staff_details', staff_id=staff_id))

    @app.route('/hr/staff/<int:staff_id>/payroll', methods=['POST'], endpoint='hr.add_staff_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def add_staff_payroll(staff_id):
        try:
            emp = db.session.get(Employee, staff_id)
            if not emp:
                flash('Staff not found', 'error')
                return redirect(url_for('hr.staff_list'))

            def to_float(val):
                try:
                    if val is None or val == '':
                        return 0.0
                    return float(str(val).replace(',', ''))
                except Exception:
                    return 0.0

            def to_int(val):
                try:
                    return int(val)
                except Exception:
                    return 0

            employment_date = None
            ed = request.form.get('employment_date')
            if ed:
                for fmt in ('%Y-%m-%d', '%d/%m/%Y', '%d-%m-%Y', '%m/%d/%Y'):
                    try:
                        employment_date = datetime.strptime(ed, fmt).date()
                        break
                    except Exception:
                        continue

            p = StaffPayroll(
                employee_id=staff_id,
                period_year=to_int(request.form.get('period_year') or datetime.now().year),
                period_month=to_int(request.form.get('period_month') or datetime.now().month),
                site=request.form.get('site') or emp.department,
                employment_date=employment_date or getattr(emp, 'date_of_employment', None),
                bank_name=request.form.get('bank_name') or '',
                account_number=request.form.get('account_number') or '',
                designation=request.form.get('designation') or emp.position,
                work_days=to_int(request.form.get('work_days')),
                days_worked=to_int(request.form.get('days_worked')),
                overtime_hours=to_float(request.form.get('overtime_hours')),
                gross=to_float(request.form.get('gross')),
                arrears=to_float(request.form.get('arrears')),
                rice_contribution=to_float(request.form.get('rice_contribution')),
                loan_or_salary_advance=to_float(request.form.get('loan_or_salary_advance')),
                jaco=to_float(request.form.get('jaco')),
                minna_paye=to_float(request.form.get('minna_paye')),
                late_deduction=to_float(request.form.get('late_deduction')),
                balance_salary=to_float(request.form.get('balance_salary')),
            )
            db.session.add(p)
            db.session.commit()
            flash('Payroll breakdown added', 'success')
        except Exception as e:
            current_app.logger.error(f"Add staff payroll error: {e}")
            flash('Failed to add payroll breakdown', 'error')
        return redirect(url_for('hr.staff_details', staff_id=staff_id))

# API Routes for AJAX calls

    @app.route('/hr/staff/<int:staff_id>/delete', methods=['POST'], endpoint='hr.delete_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def delete_staff(staff_id):
        try:
            emp = db.session.get(Employee, staff_id)
            if not emp:
                flash('Staff not found', 'error')
                return redirect(url_for('hr.staff_list'))
            db.session.delete(emp)
            db.session.commit()
            flash('Staff deleted successfully', 'success')
        except Exception as e:
            current_app.logger.error(f"Delete staff error: {e}")
            flash('Failed to delete staff', 'error')
        return redirect(url_for('hr.staff_list'))

# Enhanced staff search/filter API
    @app.route('/hr/api/staff/search', endpoint='hr.search_staff')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def search_staff():
        try:
            name = request.args.get('name', '').lower()
            department = request.args.get('department', '').lower()
            role = request.args.get('role', '').lower()
            status = request.args.get('status', '').lower()
            query = Employee.query
            if status:
                query = query.filter(Employee.status.ilike(f"%{status}%"))
            if department:
                query = query.filter(Employee.department.ilike(f"%{department}%"))
            if role:
                query = query.filter(Employee.role.ilike(f"%{role}%"))
            if name:
                query = query.filter(Employee.name.ilike(f"%{name}%"))
            results = []
            for emp in query.all():
                results.append({
                    'id': emp.id,
                    'name': emp.name,
                    'employee_id': getattr(emp, 'employee_id', ''),
                    'department': getattr(emp, 'department', ''),
                    'role': getattr(emp, 'role', ''),
                    'position': getattr(emp, 'position', ''),
                    'status': getattr(emp, 'status', '')
                })
            return jsonify({
                'status': 'success',
                'data': results,
                'count': len(results)
            })
        except Exception as e:
            current_app.logger.error(f"Staff search error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/hr/api/attendance/today', endpoint='hr.today_attendance')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def today_attendance():
        try:
            today = datetime.now().date()
            summary = {
                'present': Attendance.query.filter_by(date=today, status='Present').count() if hasattr(Attendance, 'date') else 0,
                'absent': Attendance.query.filter_by(date=today, status='Absent').count() if hasattr(Attendance, 'date') else 0,
                'late': Attendance.query.filter_by(date=today, status='Late').count() if hasattr(Attendance, 'date') else 0,
                'on_leave': Attendance.query.filter_by(date=today, status='On Leave').count() if hasattr(Attendance, 'date') else 0
            }
            details = []
            for att in Attendance.query.filter_by(date=today).all():
                emp = db.session.get(Employee, att.employee_id) if hasattr(att, 'employee_id') else None
                details.append({
                    'employee_id': getattr(emp, 'employee_id', '') if emp else '',
                    'name': emp.name if emp else '',
                    'status': att.status if hasattr(att, 'status') else '',
                    'check_in': getattr(att, 'check_in', None),
                    'check_out': getattr(att, 'check_out', None),
                    'department': getattr(emp, 'department', '') if emp else ''
                })
            attendance_data = {
                'date': today.strftime('%Y-%m-%d'),
                'summary': summary,
                'details': details
            }
            return jsonify({
                'status': 'success',
                'data': attendance_data
            })
        except Exception as e:
            current_app.logger.error(f"Attendance fetch error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

# Additional API endpoints for other functionalities
    @app.route('/hr/api/leave/pending', endpoint='hr.pending_leaves')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def pending_leaves():
        try:
            pending_leaves = []
            for l in Leave.query.filter_by(status='Pending').order_by(Leave.start.desc()).limit(20).all() if hasattr(Leave, 'status') else []:
                emp = db.session.get(Employee, l.employee_id) if hasattr(l, 'employee_id') else None
                pending_leaves.append({
                    'id': l.id,
                    'employee': emp.name if emp else '',
                    'type': l.type if hasattr(l, 'type') else '',
                    'start_date': l.start.strftime('%Y-%m-%d') if hasattr(l, 'start') else '',
                    'end_date': l.end.strftime('%Y-%m-%d') if hasattr(l, 'end') else '',
                    'status': l.status if hasattr(l, 'status') else '',
                    'applied_on': l.created_at.strftime('%Y-%m-%d') if hasattr(l, 'created_at') else ''
                })
            return jsonify({
                'status': 'success',
                'data': pending_leaves
            })
        except Exception as e:
            current_app.logger.error(f"Pending leaves fetch error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/hr/api/tasks/summary', endpoint='hr.task_summary')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def task_summary():
        try:
            summary = {
                'total': Task.query.count() if hasattr(Task, 'status') else 0,
                'completed': Task.query.filter_by(status='Completed').count() if hasattr(Task, 'status') else 0,
                'in_progress': Task.query.filter_by(status='In Progress').count() if hasattr(Task, 'status') else 0,
                'pending': Task.query.filter_by(status='Pending').count() if hasattr(Task, 'status') else 0,
                'overdue': Task.query.filter(Task.due_date < datetime.now().date(), Task.status != 'Completed').count() if hasattr(Task, 'due_date') else 0,
                'recent_tasks': []
            }
            for t in Task.query.order_by(Task.due_date.desc()).limit(5).all() if hasattr(Task, 'due_date') else []:
                summary['recent_tasks'].append({
                    'id': t.id,
                    'title': t.title if hasattr(t, 'title') else '',
                    'due_date': t.due_date.strftime('%Y-%m-%d') if hasattr(t, 'due_date') and t.due_date else '',
                    'priority': t.priority if hasattr(t, 'priority') else '',
                    'status': t.status if hasattr(t, 'status') else ''
                })
            return jsonify({
                'status': 'success',
                'data': summary
            })
        except Exception as e:
            current_app.logger.error(f"Task summary fetch error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

# Reports Routes
    @app.route('/hr/reports', endpoint='hr.reports')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def reports():
        try:
        
        # Generate dynamic report data based on actual database information
            current_date = datetime.now()
            current_month = current_date.month
            current_year = current_date.year
        
        # Calculate available reports with real data
            available_reports = []
            recent_downloads = []
        
            try:
            # Attendance Report - Always show
                attendance_count = Attendance.query.filter(
                    extract('month', Attendance.date) == current_month,
                    extract('year', Attendance.date) == current_year
                ).count() if hasattr(Attendance, 'date') else 0
            
                available_reports.append({
                    'id': 1,
                    'title': f'Attendance Report - {current_date.strftime("%B %Y")}',
                    'type': 'attendance',
                    'description': f'{attendance_count} attendance records' if attendance_count > 0 else 'No records for this period',
                    'last_generated': current_date.strftime('%Y-%m-%d'),
                    'format': 'PDF',
                    'record_count': attendance_count
                })
            
            # Leave Statistics Report - Always show
                leave_count = Leave.query.filter(
                    extract('month', Leave.start_date) == current_month,
                    extract('year', Leave.start_date) == current_year
                ).count() if hasattr(Leave, 'start_date') else 0
            
                available_reports.append({
                    'id': 2,
                    'title': f'Leave Statistics - {current_date.strftime("%B %Y")}',
                    'type': 'leave',
                    'description': f'{leave_count} leave applications' if leave_count > 0 else 'No applications for this period',
                    'last_generated': current_date.strftime('%Y-%m-%d'),
                    'format': 'Excel',
                    'record_count': leave_count
                })
            
            # Payroll Report - Always show
                payroll_count = StaffPayroll.query.filter(
                    StaffPayroll.period_month == current_month,
                    StaffPayroll.period_year == current_year
                ).count() if hasattr(StaffPayroll, 'period_month') else 0
            
                total_payroll = db.session.query(func.sum(StaffPayroll.balance_salary)).filter(
                    StaffPayroll.period_month == current_month,
                    StaffPayroll.period_year == current_year
                ).scalar() or 0
            
                available_reports.append({
                    'id': 3,
                    'title': f'Payroll Summary - {current_date.strftime("%B %Y")}',
                    'type': 'payroll',
                    'description': f'{payroll_count} employees, {total_payroll:,.2f} total' if payroll_count > 0 else 'No payroll data for this period',
                    'last_generated': current_date.strftime('%Y-%m-%d'),
                    'format': 'Excel',
                    'record_count': payroll_count,
                    'total_amount': total_payroll
                })
            
            # Employee Report - Always show
                active_employees = Employee.query.filter_by(status='Active').count() if hasattr(Employee, 'status') else Employee.query.count()
            
                available_reports.append({
                    'id': 4,
                    'title': 'Employee Directory Report',
                    'type': 'employee',
                    'description': f'{active_employees} active employees' if active_employees > 0 else 'No employees found',
                    'last_generated': current_date.strftime('%Y-%m-%d'),
                    'format': 'PDF',
                    'record_count': active_employees
                })
            
            # Performance Report - Always show
                completed_tasks = Task.query.filter_by(status='Completed').count() if hasattr(Task, 'status') else 0
                total_tasks = Task.query.count() if hasattr(Task, 'id') else 0
            
                available_reports.append({
                    'id': 5,
                    'title': 'Performance Review Report',
                    'type': 'performance',
                    'description': f'{completed_tasks} completed tasks analyzed' if completed_tasks > 0 else f'{total_tasks} tasks available',
                    'last_generated': current_date.strftime('%Y-%m-%d'),
                    'format': 'PDF',
                    'record_count': completed_tasks if completed_tasks > 0 else total_tasks
                })
            
            except Exception as report_error:
                current_app.logger.error(f"Error generating report data: {report_error}", exc_info=True)
                # If there's an error, show empty list or minimal data
                if not available_reports:
                    available_reports = []
        
        # Get recent downloads from session
            recent_downloads = []
            try:
                if 'report_downloads' in session:
                    recent_downloads = session.get('report_downloads', [])[-10:]  # Last 10 downloads
            except Exception as e:
                current_app.logger.warning(f"Error loading download history: {e}")
                recent_downloads = []
        
        # Calculate actual report statistics from database
            total_reports = len(available_reports)
            total_downloads = len(recent_downloads)
            
            # Calculate pending reports (reports requested but not yet generated)
            pending_reports = session.get('pending_reports_count', 0)
            
            # Calculate storage used from actual report files
            storage_used = calculate_reports_storage()
        
            report_stats = {
                'total_reports': total_reports,
                'pending_reports': pending_reports,
                'total_downloads': total_downloads,
                'storage_used': storage_used
            }
        
            report_data = {
                'available_reports': available_reports,
                'recent_downloads': recent_downloads,
                'stats': report_stats,
                'departments': get_departments_list()
            }
        
            return render_template('hr/reports/index.html', reports=report_data)
        
        except Exception as e:
            current_app.logger.error(f"Reports error: {str(e)}", exc_info=True)
            flash("Error loading reports", "error")
            return render_template('error.html'), 500

    def get_departments_list():
        """Get list of unique departments from employees"""
        try:
            departments = db.session.query(Employee.department).distinct().filter(
                Employee.department.isnot(None),
                Employee.department != ''
            ).all()
            
            dept_list = [{'id': '1', 'name': 'All Departments'}]
            dept_list.extend([
                {'id': str(idx + 2), 'name': dept[0]} 
                for idx, dept in enumerate(departments)
            ])
            return dept_list
        except Exception:
            return [
                {'id': '1', 'name': 'All Departments'},
                {'id': '2', 'name': 'HR'},
                {'id': '3', 'name': 'Finance'},
                {'id': '4', 'name': 'Operations'},
                {'id': '5', 'name': 'Engineering'}
            ]

    def calculate_reports_storage():
        """Calculate storage used by generated reports"""
        try:
            import os
            reports_dir = os.path.join(current_app.root_path, 'instance', 'reports')
            
            if not os.path.exists(reports_dir):
                return '0 KB'
            
            total_size = 0
            for dirpath, dirnames, filenames in os.walk(reports_dir):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    if os.path.exists(filepath):
                        total_size += os.path.getsize(filepath)
            
            # Convert to human-readable format
            if total_size < 1024:
                return f'{total_size} B'
            elif total_size < 1024 * 1024:
                return f'{total_size / 1024:.1f} KB'
            elif total_size < 1024 * 1024 * 1024:
                return f'{total_size / (1024 * 1024):.1f} MB'
            else:
                return f'{total_size / (1024 * 1024 * 1024):.1f} GB'
        except Exception as e:
            current_app.logger.warning(f"Error calculating storage: {e}")
            return '0 KB'

    @app.route('/hr/analytics', endpoint='hr.analytics')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def analytics():
        try:
            from sqlalchemy import func, extract
        
            current_year = datetime.now().year
            current_month = datetime.now().month
        
        # Calculate attendance trends for last 4 months
            attendance_trends = {
                'labels': [],
                'present': [],
                'absent': [],
                'late': []
            }
        
            for i in range(3, -1, -1):  # Last 4 months
                target_month = current_month - i
                target_year = current_year
            
                if target_month <= 0:
                    target_month += 12
                    target_year -= 1
            
                month_name = datetime(target_year, target_month, 1).strftime('%b')
                attendance_trends['labels'].append(month_name)
            
            # Get attendance counts for this month
                if hasattr(Attendance, 'date') and hasattr(Attendance, 'status'):
                    present_count = Attendance.query.filter(
                        extract('year', Attendance.date) == target_year,
                        extract('month', Attendance.date) == target_month,
                        Attendance.status == 'Present'
                    ).count()
                
                    absent_count = Attendance.query.filter(
                        extract('year', Attendance.date) == target_year,
                        extract('month', Attendance.date) == target_month,
                        Attendance.status == 'Absent'
                    ).count()
                
                    late_count = Attendance.query.filter(
                        extract('year', Attendance.date) == target_year,
                        extract('month', Attendance.date) == target_month,
                        Attendance.status == 'Late'
                    ).count()
                else:
                    # No data available - use zeros
                    present_count = 0
                    absent_count = 0
                    late_count = 0
            
                attendance_trends['present'].append(present_count)
                attendance_trends['absent'].append(absent_count)
                attendance_trends['late'].append(late_count)
        
        # Calculate leave distribution for current year
            leave_distribution = {
                'annual': 0,
                'sick': 0,
                'maternity': 0,
                'study': 0
            }
        
            if hasattr(Leave, 'type') and hasattr(Leave, 'start'):
            # Count leaves by type for current year
                annual_leaves = Leave.query.filter(
                    extract('year', Leave.start) == current_year,
                    Leave.type.in_(['Annual', 'Vacation', 'annual'])
                ).count()
            
                sick_leaves = Leave.query.filter(
                    extract('year', Leave.start) == current_year,
                    Leave.type.in_(['Sick', 'Medical', 'sick'])
                ).count()
            
                maternity_leaves = Leave.query.filter(
                    extract('year', Leave.start) == current_year,
                    Leave.type.in_(['Maternity', 'Paternity', 'maternity'])
                ).count()
            
                study_leaves = Leave.query.filter(
                    extract('year', Leave.start) == current_year,
                    Leave.type.in_(['Study', 'Training', 'study'])
                ).count()
            
                leave_distribution = {
                    'annual': annual_leaves,
                    'sick': sick_leaves,
                    'maternity': maternity_leaves,
                    'study': study_leaves
                }
            else:
            # Fallback values - return empty if Employee or Leave models don't have required fields
                leave_distribution = {
                    'annual': 0,
                    'sick': 0,
                    'maternity': 0,
                    'study': 0
                }
        
        # Calculate department statistics
            department_stats = []
        
        # Get all departments with employee counts
            if hasattr(Employee, 'department'):
                departments = db.session.query(
                    Employee.department,
                    func.count(Employee.id).label('staff_count')
                ).filter(
                    Employee.status == 'Active',
                    Employee.department.isnot(None)
                ).group_by(Employee.department).all()
            
                for dept_name, staff_count in departments:
                    if not dept_name:
                        continue
                
                # Calculate attendance rate for this department
                    if hasattr(Attendance, 'employee_id'):
                        dept_employees = Employee.query.filter_by(department=dept_name, status='Active').all()
                        dept_employee_ids = [e.id for e in dept_employees]
                    
                        total_attendance = Attendance.query.filter(
                            Attendance.employee_id.in_(dept_employee_ids),
                            extract('year', Attendance.date) == current_year
                        ).count() if dept_employee_ids else 0
                    
                        present_attendance = Attendance.query.filter(
                            Attendance.employee_id.in_(dept_employee_ids),
                            extract('year', Attendance.date) == current_year,
                            Attendance.status.in_(['Present', 'Late'])
                        ).count() if dept_employee_ids else 0
                    
                        attendance_rate = round((present_attendance / total_attendance) * 100, 1) if total_attendance > 0 else 98
                    else:
                        attendance_rate = 96  # Default
                
                # Calculate average leave usage
                    if hasattr(Leave, 'employee_id'):
                        dept_leaves = Leave.query.filter(
                            Leave.employee_id.in_(dept_employee_ids),
                            extract('year', Leave.start) == current_year
                        ).all() if dept_employee_ids else []
                    
                        total_leave_days = sum([(l.end - l.start).days + 1 for l in dept_leaves if l.start and l.end])
                        leave_usage = round(total_leave_days / staff_count, 1) if staff_count > 0 else 0
                    else:
                        leave_usage = 12  # Default
                
                    department_stats.append({
                        'name': dept_name,
                        'staff_count': staff_count,
                        'attendance_rate': attendance_rate,
                        'leave_usage': leave_usage
                    })
        
        # Fallback department stats if no real data
            if not department_stats:
                department_stats = []
        
        # Calculate performance metrics
            performance_metrics = {
                'high_performers': 0,
                'average_performers': 0,
                'needs_improvement': 0
            }
        
            if hasattr(Task, 'assignee_id') and hasattr(Task, 'status'):
            # Calculate based on task completion rates
                employees_with_tasks = db.session.query(
                    Task.assignee_id,
                    func.count(Task.id).label('total_tasks'),
                    func.sum(func.case([(Task.status == 'Completed', 1)], else_=0)).label('completed_tasks')
                ).filter(
                    extract('year', Task.created_at) == current_year
                ).group_by(Task.assignee_id).all()
            
                for emp_id, total, completed in employees_with_tasks:
                    completion_rate = (completed / total) * 100 if total > 0 else 0
                
                    if completion_rate >= 85:
                        performance_metrics['high_performers'] += 1
                    elif completion_rate >= 60:
                        performance_metrics['average_performers'] += 1
                    else:
                        performance_metrics['needs_improvement'] += 1
            else:
            # Fallback values
                total_staff = Employee.query.filter_by(status='Active').count()
                performance_metrics = {
                    'high_performers': int(total_staff * 0.2),  # 20%
                    'average_performers': int(total_staff * 0.7),  # 70%
                    'needs_improvement': int(total_staff * 0.1)  # 10%
                }
        
            analytics_data = {
                'attendance_trends': attendance_trends,
                'leave_distribution': leave_distribution,
                'department_stats': department_stats,
                'performance_metrics': performance_metrics
            }
        
            return render_template('hr/analytics/index.html', analytics=analytics_data)
        
        except Exception as e:
            current_app.logger.error(f"Analytics error: {str(e)}", exc_info=True)
            flash("Error loading analytics", "error")
            return render_template('error.html'), 500

# API Routes for Reports and Analytics
    @app.route('/hr/api/reports/generate', methods=['POST'], endpoint='hr.generate_report')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def generate_report():
        try:
            data = request.get_json() if request.is_json else request.form
            report_type = data.get('type')
            date_range = data.get('date_range', {})
            format_type = data.get('format', 'PDF')
            department_id = data.get('department_id')
        
        # Validate required fields
            if not report_type:
                return jsonify({'status': 'error', 'message': 'Report type is required'}), 400
        
            start_date = date_range.get('start')
            end_date = date_range.get('end')
        
            if not start_date or not end_date:
                return jsonify({'status': 'error', 'message': 'Date range is required'}), 400
        
        # Parse dates
            try:
                start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
                end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
            except ValueError:
                return jsonify({'status': 'error', 'message': 'Invalid date format'}), 400
        
        # Validate date range
            if start_date > end_date:
                return jsonify({'status': 'error', 'message': 'Start date must be before end date'}), 400
        
            if (end_date - start_date).days > 365:
                return jsonify({'status': 'error', 'message': 'Date range cannot exceed 365 days'}), 400
        
        # Generate report based on type
            report_data = None
            record_count = 0
        
            try:
                if report_type == 'attendance':
                    report_data, record_count = generate_attendance_report(start_date, end_date, department_id)
                elif report_type == 'leave':
                    report_data, record_count = generate_leave_report(start_date, end_date, department_id)
                elif report_type == 'payroll':
                    report_data, record_count = generate_payroll_report(start_date, end_date, department_id)
                elif report_type == 'employee':
                    report_data, record_count = generate_employee_report(department_id)
                elif report_type == 'performance':
                    report_data, record_count = generate_performance_report(start_date, end_date, department_id)
                else:
                    return jsonify({'status': 'error', 'message': 'Invalid report type'}), 400
            
            # Generate job ID for tracking
                job_id = str(uuid.uuid4())[:8]
            
            # Store report generation request in session for tracking
                if 'report_jobs' not in session:
                    session['report_jobs'] = {}
            
                session['report_jobs'][job_id] = {
                    'type': report_type,
                    'format': format_type,
                    'record_count': record_count,
                    'status': 'completed',
                    'created_at': datetime.now().isoformat(),
                    'download_ready': True
                }
            
                session.permanent = True
            
                return jsonify({
                    'status': 'success',
                    'message': f'{report_type.title()} report generated successfully',
                    'job_id': job_id,
                    'record_count': record_count,
                    'download_url': f'/hr/api/reports/download/{job_id}',
                    'estimated_size': f'{max(record_count * 0.1, 0.1):.1f} MB'
                })
            
            except Exception as generation_error:
                current_app.logger.error(f"Report generation error: {generation_error}")
                return jsonify({
                    'status': 'error',
                    'message': f'Error generating {report_type} report: {str(generation_error)}'
                }), 500
            
        except Exception as e:
            current_app.logger.error(f"Report generation error: {str(e)}", exc_info=True)
            return jsonify({'status': 'error', 'message': str(e)}), 500

    def generate_attendance_report(start_date, end_date, department_id=None):
        """Generate attendance report data"""
    
        try:
        # Query attendance records within date range
            query = Attendance.query.filter(
                Attendance.date >= start_date,
                Attendance.date <= end_date
            ) if hasattr(Attendance, 'date') else Attendance.query
        
        # Filter by department if specified
            if department_id and department_id != '1':  # '1' is "All Departments"
                employees = Employee.query.filter_by(department=get_department_name(department_id)).all()
                employee_ids = [emp.id for emp in employees]
                if hasattr(Attendance, 'employee_id'):
                    query = query.filter(Attendance.employee_id.in_(employee_ids))
        
            attendance_records = query.all()
        
        # Calculate attendance statistics
            total_records = len(attendance_records)
            present_count = len([r for r in attendance_records if getattr(r, 'status', '') == 'Present'])
            absent_count = len([r for r in attendance_records if getattr(r, 'status', '') == 'Absent'])
            late_count = len([r for r in attendance_records if getattr(r, 'status', '') == 'Late'])
        
            report_data = {
                'total_records': total_records,
                'present_count': present_count,
                'absent_count': absent_count,
                'late_count': late_count,
                'attendance_rate': (present_count / total_records * 100) if total_records > 0 else 0,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"
            }
        
            return report_data, total_records
        
        except Exception as e:
            current_app.logger.error(f"Attendance report generation error: {e}", exc_info=True)
            # Return empty data on error
            return {
                'total_records': 0,
                'present_count': 0,
                'absent_count': 0,
                'late_count': 0,
                'attendance_rate': 0,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}",
                'error': str(e)
            }, 0

    def generate_leave_report(start_date, end_date, department_id=None):
        """Generate leave report data"""
    
        try:
            query = Leave.query.filter(
                Leave.start_date >= start_date,
                Leave.end_date <= end_date
            ) if hasattr(Leave, 'start_date') else Leave.query
        
            leave_applications = query.all()
            total_applications = len(leave_applications)
        
        # Calculate leave statistics
            approved_count = len([l for l in leave_applications if getattr(l, 'status', '') == 'Approved'])
            pending_count = len([l for l in leave_applications if getattr(l, 'status', '') == 'Pending'])
            rejected_count = len([l for l in leave_applications if getattr(l, 'status', '') == 'Rejected'])
        
            report_data = {
                'total_applications': total_applications,
                'approved_count': approved_count,
                'pending_count': pending_count,
                'rejected_count': rejected_count,
                'approval_rate': (approved_count / total_applications * 100) if total_applications > 0 else 0,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"
            }
        
            return report_data, total_applications
        
        except Exception as e:
            current_app.logger.warning(f"Leave report generation error: {e}")
            return {
                'total_applications': 0,
                'approved_count': 0,
                'pending_count': 0,
                'rejected_count': 0,
                'approval_rate': 0.0,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}",
                'error': str(e)
            }, 0

    def generate_payroll_report(start_date, end_date, department_id=None):
        """Generate payroll report data"""
    
        try:
        # Get payroll records for the period
            query = StaffPayroll.query
        
        # Filter by date range if possible
            if hasattr(StaffPayroll, 'period_month') and hasattr(StaffPayroll, 'period_year'):
                months = []
                current_date = start_date.replace(day=1)
                while current_date <= end_date:
                    months.append((current_date.month, current_date.year))
                    next_month = current_date.month % 12 + 1
                    next_year = current_date.year + (1 if next_month == 1 else 0)
                    current_date = current_date.replace(month=next_month, year=next_year)
            
            # Filter by months in range
                filters = []
                for month, year in months:
                    filters.append(db.and_(StaffPayroll.period_month == month, StaffPayroll.period_year == year))
            
                if filters:
                    query = query.filter(db.or_(*filters))
        
            payroll_records = query.all()
            total_records = len(payroll_records)
        
        # Calculate payroll statistics
            total_gross = sum(getattr(r, 'gross_salary', 0) for r in payroll_records)
            total_deductions = sum(getattr(r, 'total_deductions', 0) for r in payroll_records)
            total_net = sum(getattr(r, 'balance_salary', 0) for r in payroll_records)
        
            report_data = {
                'total_employees': total_records,
                'total_gross_pay': total_gross,
                'total_deductions': total_deductions,
                'total_net_pay': total_net,
                'average_salary': (total_net / total_records) if total_records > 0 else 0,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"
            }
        
            return report_data, total_records
        
        except Exception as e:
            current_app.logger.warning(f"Payroll report generation error: {e}")
            return {
                'total_employees': 0,
                'total_gross_pay': 0.00,
                'total_deductions': 0.00,
                'total_net_pay': 0.00,
                'average_salary': 0.00,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}",
                'error': str(e)
            }, 0

    def generate_employee_report(department_id=None):
        """Generate employee report data"""
    
        try:
            query = Employee.query
        
        # Filter by department if specified
            if department_id and department_id != '1':
                dept_name = get_department_name(department_id)
                if hasattr(Employee, 'department'):
                    query = query.filter_by(department=dept_name)
        
            employees = query.all()
            total_employees = len(employees)
        
        # Calculate employee statistics
            active_count = len([e for e in employees if getattr(e, 'status', '') == 'Active'])
            inactive_count = total_employees - active_count
        
        # Department breakdown
            departments = {}
            for emp in employees:
                dept = getattr(emp, 'department', 'Unknown')
                departments[dept] = departments.get(dept, 0) + 1
        
            report_data = {
                'total_employees': total_employees,
                'active_employees': active_count,
                'inactive_employees': inactive_count,
                'department_breakdown': departments,
                'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
        
            return report_data, total_employees
        
        except Exception as e:
            current_app.logger.warning(f"Employee report generation error: {e}")
            return {
                'total_employees': 0,
                'active_employees': 0,
                'inactive_employees': 0,
                'department_breakdown': {},
                'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'error': str(e)
            }, 0

    def generate_performance_report(start_date, end_date, department_id=None):
        """Generate performance report data"""
    
        try:
            query = Task.query
        
        # Filter by date range if possible
            if hasattr(Task, 'created_at'):
                query = query.filter(
                    Task.created_at >= datetime.combine(start_date, datetime.min.time()),
                    Task.created_at <= datetime.combine(end_date, datetime.max.time())
                )
        
            tasks = query.all()
            total_tasks = len(tasks)
        
        # Calculate performance statistics
            completed_tasks = len([t for t in tasks if getattr(t, 'status', '') == 'Completed'])
            in_progress_tasks = len([t for t in tasks if getattr(t, 'status', '') == 'In Progress'])
            pending_tasks = len([t for t in tasks if getattr(t, 'status', '') in ['Pending', 'pending']])
        
            completion_rate = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
        
            report_data = {
                'total_tasks': total_tasks,
                'completed_tasks': completed_tasks,
                'in_progress_tasks': in_progress_tasks,
                'pending_tasks': pending_tasks,
                'completion_rate': completion_rate,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"
            }
        
            return report_data, total_tasks
        
        except Exception as e:
            current_app.logger.warning(f"Performance report generation error: {e}")
            return {
                'total_tasks': 0,
                'completed_tasks': 0,
                'in_progress_tasks': 0,
                'pending_tasks': 0,
                'completion_rate': 0.0,
                'period': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}",
                'error': str(e)
            }, 0

    def get_department_name(department_id):
        """Get department name by ID"""
        departments = {
            '2': 'HR',
            '3': 'Finance', 
            '4': 'Operations',
            '5': 'Engineering'
        }
        return departments.get(department_id, 'HR')

    @app.route('/hr/api/reports/download/<job_id>', endpoint='hr.download_report')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def download_report(job_id):
        """Download generated report"""
        try:
        # Check if job exists in session
            if 'report_jobs' not in session or job_id not in session['report_jobs']:
                return jsonify({'error': 'Report not found or expired'}), 404
        
            job = session['report_jobs'][job_id]
        
            if not job.get('download_ready'):
                return jsonify({'error': 'Report not ready for download'}), 400
        
        # Generate download response
            report_type = job['type']
            format_type = job['format']
        
        # Create a simple report file content (in a real system, this would generate actual PDF/Excel)
            report_content = f"""
            {report_type.upper()} REPORT
            Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            Format: {format_type}
            Records: {job['record_count']}
        
            This is a sample {report_type} report.
            In a production system, this would contain the actual report data.
            """
        
        # Set appropriate headers for download
            filename = f"{report_type}_report_{datetime.now().strftime('%Y%m%d')}.{format_type.lower()}"
        
            response = make_response(report_content)
            response.headers['Content-Disposition'] = f'attachment; filename={filename}'
            response.headers['Content-Type'] = 'application/octet-stream'
        
        # Log download
            current_app.logger.info(f"Report downloaded: {job_id} by user {session.get('user_name', 'Unknown')}")
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Report download error: {str(e)}", exc_info=True)
            return jsonify({'error': 'Error downloading report'}), 500

    @app.route('/hr/api/reports/status/<job_id>', endpoint='hr.report_status')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def report_status(job_id):
        """Get report generation status"""
        try:
            if 'report_jobs' not in session or job_id not in session['report_jobs']:
                return jsonify({'error': 'Report not found'}), 404
        
            job = session['report_jobs'][job_id]
        
            return jsonify({
                'status': 'success',
                'job': {
                    'id': job_id,
                    'type': job['type'],
                    'format': job['format'],
                    'status': job['status'],
                    'record_count': job['record_count'],
                    'download_ready': job['download_ready'],
                    'created_at': job['created_at']
                }
            })
        
        except Exception as e:
            current_app.logger.error(f"Report status error: {str(e)}")
            return jsonify({'error': 'Error fetching report status'}), 500

    @app.route('/hr/api/reports/<int:report_id>/view', endpoint='hr.view_report_details')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def view_report_details(report_id):
        """View detailed information about a specific report"""
        try:
        
        # Get report details based on ID and type
            report_details = None
        
            if report_id == 1:  # Attendance Report
                current_date = datetime.now()
                current_month = current_date.month
                current_year = current_date.year
            
                try:
                # Get attendance statistics
                    total_records = Attendance.query.filter(
                        extract('month', Attendance.date) == current_month,
                        extract('year', Attendance.date) == current_year
                    ).count() if hasattr(Attendance, 'date') else 0
                
                    present_count = Attendance.query.filter(
                        extract('month', Attendance.date) == current_month,
                        extract('year', Attendance.date) == current_year,
                        Attendance.status == 'Present'
                    ).count() if hasattr(Attendance, 'status') else 0
                
                    absent_count = total_records - present_count
                    attendance_rate = (present_count / total_records * 100) if total_records > 0 else 0
                
                    report_details = {
                        'id': report_id,
                        'title': f'Attendance Report - {current_date.strftime("%B %Y")}',
                        'type': 'attendance',
                        'period': f'{current_date.strftime("%B %Y")}',
                        'summary': {
                            'total_records': total_records,
                            'present_count': present_count,
                            'absent_count': absent_count,
                            'attendance_rate': round(attendance_rate, 1)
                        },
                        'details': f'Comprehensive attendance analysis for {current_date.strftime("%B %Y")} showing daily attendance patterns, late arrivals, and overall presence statistics.',
                        'generated_at': current_date.strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'PDF'
                    }
                
                except Exception:
                # Fallback data - return empty report on error
                    report_details = {
                        'id': report_id,
                        'title': f'Attendance Report - {current_date.strftime("%B %Y")}',
                        'type': 'attendance',
                        'period': f'{current_date.strftime("%B %Y")}',
                        'summary': {
                            'total_records': 0,
                            'present_count': 0,
                            'absent_count': 0,
                            'attendance_rate': 0.0
                        },
                        'details': 'Comprehensive attendance analysis showing daily attendance patterns, late arrivals, and overall presence statistics.',
                        'generated_at': current_date.strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'PDF'
                    }
                
            elif report_id == 2:  # Leave Report
                current_date = datetime.now()
            
                try:
                    leave_applications = Leave.query.filter(
                        extract('month', Leave.start_date) == current_date.month,
                        extract('year', Leave.start_date) == current_date.year
                    ).count() if hasattr(Leave, 'start_date') else 0
                
                    report_details = {
                        'id': report_id,
                        'title': f'Leave Statistics - {current_date.strftime("%B %Y")}',
                        'type': 'leave',
                        'period': f'{current_date.strftime("%B %Y")}',
                        'summary': {
                            'total_applications': leave_applications,
                            'approved_count': int(leave_applications * 0.8),
                            'pending_count': int(leave_applications * 0.15),
                            'rejected_count': int(leave_applications * 0.05)
                        },
                        'details': 'Detailed leave analysis including leave types, approval rates, and department-wise distribution.',
                        'generated_at': current_date.strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'Excel'
                    }
                except Exception:
                    report_details = {
                        'id': report_id,
                        'title': f'Leave Statistics - {current_date.strftime("%B %Y")}',
                        'type': 'leave',
                        'period': f'{current_date.strftime("%B %Y")}',
                        'summary': {
                            'total_applications': 0,
                            'approved_count': 0,
                            'pending_count': 0,
                            'rejected_count': 0
                        },
                        'details': 'Detailed leave analysis including leave types, approval rates, and department-wise distribution.',
                        'generated_at': current_date.strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'Excel'
                    }
                
            elif report_id == 3:  # Payroll Report
                current_date = datetime.now()
            
                try:
                    total_employees = StaffPayroll.query.filter(
                        StaffPayroll.period_month == current_date.month,
                        StaffPayroll.period_year == current_date.year
                    ).count() if hasattr(StaffPayroll, 'period_month') else 0
                
                    total_payroll = db.session.query(func.sum(StaffPayroll.balance_salary)).filter(
                        StaffPayroll.period_month == current_date.month,
                        StaffPayroll.period_year == current_date.year
                    ).scalar() or 0.00
                
                    report_details = {
                        'id': report_id,
                        'title': f'Payroll Summary - {current_date.strftime("%B %Y")}',
                        'type': 'payroll',
                        'period': f'{current_date.strftime("%B %Y")}',
                        'summary': {
                            'total_employees': total_employees,
                            'total_gross_pay': total_payroll * 1.2,
                            'total_deductions': total_payroll * 0.2,
                            'total_net_pay': total_payroll,
                            'average_salary': total_payroll / total_employees if total_employees > 0 else 0
                        },
                        'details': 'Complete payroll breakdown including gross salaries, deductions, taxes, and net pay distribution across all departments.',
                        'generated_at': current_date.strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'Excel'
                    }
                except Exception:
                    report_details = {
                        'id': report_id,
                        'title': f'Payroll Summary - {current_date.strftime("%B %Y")}',
                        'type': 'payroll',
                        'period': f'{current_date.strftime("%B %Y")}',
                        'summary': {
                            'total_employees': 0,
                            'total_gross_pay': 0.00,
                            'total_deductions': 0.00,
                            'total_net_pay': 0.00,
                            'average_salary': 0.00
                        },
                        'details': 'Complete payroll breakdown including gross salaries, deductions, taxes, and net pay distribution across all departments.',
                        'generated_at': current_date.strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'Excel'
                    }
                
            elif report_id == 4:  # Employee Report
                try:
                    active_employees = Employee.query.filter_by(status='Active').count() if hasattr(Employee, 'status') else 0
                    total_employees = Employee.query.count() if hasattr(Employee, 'status') else 0
                
                    report_details = {
                        'id': report_id,
                        'title': 'Employee Directory Report',
                        'type': 'employee',
                        'period': 'Current',
                        'summary': {
                            'total_employees': total_employees,
                            'active_employees': active_employees,
                            'inactive_employees': total_employees - active_employees,
                            'departments': 4
                        },
                        'details': 'Comprehensive employee directory with contact information, department assignments, roles, and employment status.',
                        'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'PDF'
                    }
                except Exception:
                    report_details = {
                        'id': report_id,
                        'title': 'Employee Directory Report',
                        'type': 'employee',
                        'period': 'Current',
                        'summary': {
                            'total_employees': 0,
                            'active_employees': 0,
                            'inactive_employees': 0,
                            'departments': 0
                        },
                        'details': 'Comprehensive employee directory with contact information, department assignments, roles, and employment status.',
                        'generated_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'format': 'PDF'
                    }
            else:
                return jsonify({'error': 'Report not found'}), 404
        
            return jsonify({
                'status': 'success',
                'report': report_details
            })
        
        except Exception as e:
            current_app.logger.error(f"View report details error: {str(e)}", exc_info=True)
            return jsonify({'error': 'Error fetching report details'}), 500

    @app.route('/hr/api/reports/<int:report_id>/send-to-admin', methods=['POST'], endpoint='hr.send_report_to_admin')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def send_report_to_admin(report_id):
        """Send report to admin for review/approval"""
        try:
            data = request.get_json() if request.is_json else request.form
            message = data.get('message', '')
            priority = data.get('priority', 'Medium')
        
        # Get report details
            report_response = view_report_details(report_id)
            
            # Handle both tuple and direct response formats
            if isinstance(report_response, tuple):
                response_obj, status_code = report_response
                if status_code != 200:
                    return jsonify({'error': 'Report not found'}), 404
                report_data = response_obj.get_json()['report']
            else:
                response_data = report_response.get_json()
                if response_data.get('status') != 'success':
                    return jsonify({'error': 'Report not found'}), 404
                report_data = response_data['report']
        
        # Get sender information
            sender_name = session.get('user_name', 'HR Staff')
            sender_id = session.get('user_id', 'unknown')
        
        # Create notification/message to admin
            admin_notification = {
                'id': f"report_{report_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                'type': 'report_submission',
                'from': sender_name,
                'from_id': sender_id,
                'report_id': report_id,
                'report_title': report_data['title'],
                'report_type': report_data['type'],
                'message': message,
                'priority': priority,
                'submitted_at': datetime.now().isoformat(),
                'status': 'pending_review'
            }
        
        # Store in session (in a real system, this would go to a database or message queue)
            if 'admin_notifications' not in session:
                session['admin_notifications'] = []
        
            session['admin_notifications'].append(admin_notification)
            session.permanent = True
        
        # Log the submission
            current_app.logger.info(f"Report {report_id} sent to admin by {sender_name} with message: {message}")
        
            return jsonify({
                'status': 'success',
                'message': f'Report "{report_data["title"]}" has been sent to admin for review',
                'notification_id': admin_notification['id'],
                'submitted_at': admin_notification['submitted_at']
            })
        
        except Exception as e:
            current_app.logger.error(f"Send report to admin error: {str(e)}", exc_info=True)
            return jsonify({'error': 'Error sending report to admin'}), 500

    @app.route('/hr/api/admin/notifications', endpoint='hr.get_admin_notifications')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def get_admin_notifications():
        """Get pending admin notifications"""
        try:
            notifications = session.get('admin_notifications', [])
        
        # Filter for pending notifications
            pending_notifications = [n for n in notifications if n.get('status') == 'pending_review']
        
            return jsonify({
                'status': 'success',
                'notifications': pending_notifications,
                'count': len(pending_notifications)
            })
        
        except Exception as e:
            current_app.logger.error(f"Get admin notifications error: {str(e)}")
            return jsonify({'error': 'Error fetching notifications'}), 500

    @app.route('/hr/api/analytics/data', endpoint='hr.analytics_data')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def analytics_data():
        try:
            metric = request.args.get('metric')
            period = request.args.get('period', 'monthly')
        
        # Mock analytics data response
            data = {
                'labels': ['Week 1', 'Week 2', 'Week 3', 'Week 4'],
                'values': [92, 95, 88, 93],
                'trend': 'positive',
                'change_percentage': 2.5
            }
        
            return jsonify({
                'status': 'success',
                'data': data
            })
        except Exception as e:
            current_app.logger.error(f"Analytics data fetch error: {str(e)}")
            return jsonify({'status': 'error', 'message': str(e)})

    @app.route('/hr/logout', endpoint='hr.logout')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def logout():
        try:
        # Clear all session data
            session.clear()
            flash("Successfully logged out", "success")
            return redirect(url_for('login'))
        except Exception as e:
            current_app.logger.error(f"Logout error: {str(e)}")
            flash("Error during logout", "error")
            return redirect(url_for('hr.hr_home'))

    @app.route('/hr/profile', endpoint='hr.profile')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def profile():
        try:
        
        # Get current user from session
            user_id = session.get('user_id')
            if not user_id:
                flash("Please log in to view your profile", "error")
                return redirect(url_for('login'))
        
        # Get user from database
            user = User.query.get_or_404(user_id)
        
        # Try to find corresponding employee record (by email or name)
            employee = None
            if user.email:
                employee = Employee.query.filter_by(email=user.email).first()
            if not employee and user.name:
                employee = Employee.query.filter_by(name=user.name).first()
        
        # Calculate user statistics
            current_year = datetime.now().year
        
        # Calculate leave balance (default 25 days annual leave)
            leave_balance = 25
            if employee:
                used_leaves = Leave.query.filter(
                    Leave.employee_id == employee.id,
                    db.extract('year', Leave.start) == current_year,
                    Leave.status.in_(['Approved', 'Completed'])
                ).all() if hasattr(Leave, 'employee_id') else []
            
                total_days_used = sum([(l.end - l.start).days + 1 for l in used_leaves if l.start and l.end])
                leave_balance = max(0, 25 - total_days_used)
        
        # Calculate attendance rate
            attendance_rate = 98  # Default
            if employee:
                total_attendance = Attendance.query.filter(
                    Attendance.employee_id == employee.id,
                    db.extract('year', Attendance.date) == current_year
                ).count() if hasattr(Attendance, 'employee_id') else 0
            
                present_attendance = Attendance.query.filter(
                    Attendance.employee_id == employee.id,
                    db.extract('year', Attendance.date) == current_year,
                    Attendance.status.in_(['Present', 'Late'])
                ).count() if hasattr(Attendance, 'employee_id') else 0
            
                if total_attendance > 0:
                    attendance_rate = round((present_attendance / total_attendance) * 100, 1)
        
        # Calculate completed tasks
            completed_tasks = 0
            if employee:
                completed_tasks = Task.query.filter(
                    Task.assignee_id == employee.id,
                    Task.status == 'Completed',
                    db.extract('year', Task.created_at) == current_year
                ).count() if hasattr(Task, 'assignee_id') else 0
        
        # Get recent activities
            recent_activities = []
            if employee:
            # Recent payroll activities
                recent_payrolls = PayrollHistory.query.filter_by(
                    generated_by=user_id
                ).order_by(PayrollHistory.created_at.desc()).limit(3).all()
            
                for pr in recent_payrolls:
                    recent_activities.append({
                        'icon': 'bx-money',
                        'description': f'Generated payroll for {pr.period_start.strftime("%B %Y") if pr.period_start else "N/A"}',
                        'timestamp': pr.created_at.strftime('%B %d, %Y') if pr.created_at else 'N/A'
                    })
            
            # Recent leave approvals (if user is HR)
                if user.role in ['SUPER_HQ', 'HQ_HR']:
                    recent_leaves = Leave.query.filter(
                        Leave.status == 'Approved',
                        Leave.approved_by == user_id
                    ).order_by(Leave.updated_at.desc()).limit(2).all() if hasattr(Leave, 'approved_by') else []
                
                    for leave in recent_leaves:
                        emp = Employee.query.get(leave.employee_id) if hasattr(leave, 'employee_id') else None
                        recent_activities.append({
                            'icon': 'bx-check-circle',
                            'description': f'Approved leave request for {emp.name if emp else "Staff"}',
                            'timestamp': leave.updated_at.strftime('%B %d, %Y') if hasattr(leave, 'updated_at') and leave.updated_at else 'N/A'
                        })
        
        # Default activities if none found
            if not recent_activities:
                recent_activities = [
                    {
                        'icon': 'bx-user-check',
                        'description': 'Profile accessed successfully',
                        'timestamp': datetime.now().strftime('%B %d, %Y')
                    }
                ]
        
        # Build user data
            user_data = {
                'id': user.id,
                'name': user.name,
                'position': employee.position if employee else user.role,
                'email': user.email,
                'phone': employee.phone if employee else 'Not set',
                'avatar_url': None,  # Will use UI Avatars as fallback
                'leave_balance': leave_balance,
                'attendance_rate': attendance_rate,
                'completed_tasks': completed_tasks,
                'recent_activities': recent_activities,
                'department': employee.department if employee else 'Not assigned',
                'employee_id': employee.id if employee else None,
                'role': user.role
            }
        
            return render_template('hr/profile/index.html', user=user_data)
        
        except Exception as e:
            current_app.logger.error(f"Profile error: {str(e)}", exc_info=True)
            flash("Error loading profile", "error")
            return render_template('error.html'), 500

    @app.route('/hr/profile/update', methods=['POST'], endpoint='hr.update_profile')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def update_profile():
        """Update user profile information"""
        try:
        
            user_id = session.get('user_id')
            if not user_id:
                flash("Please log in to update your profile", "error")
                return redirect(url_for('login'))
        
        # Get current user
            user = User.query.get_or_404(user_id)
        
        # Get form data
            name = request.form.get('name', '').strip()
            email = request.form.get('email', '').strip()
            phone = request.form.get('phone', '').strip()
        
        # Validation
            if not name:
                flash("Name is required", "error")
                return redirect(url_for('hr.profile'))
        
            if not email:
                flash("Email is required", "error")
                return redirect(url_for('hr.profile'))
        
        # Check if email is already taken by another user
            existing_user = User.query.filter(User.email == email, User.id != user_id).first()
            if existing_user:
                flash("Email is already taken by another user", "error")
                return redirect(url_for('hr.profile'))
        
        # Update user record
            user.name = name
            user.email = email
            user.updated_at = datetime.now(timezone.utc)
        
        # Update corresponding employee record if exists
            employee = Employee.query.filter_by(email=user.email).first()
            if not employee:
                employee = Employee.query.filter_by(name=user.name).first()
        
            if employee:
                employee.name = name
                employee.email = email
                employee.phone = phone
                employee.updated_at = datetime.now(timezone.utc)
        
            db.session.commit()
        
            current_app.logger.info(f"Profile updated for user {user.name} (ID: {user.id})")
            flash("Profile updated successfully", "success")
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Profile update error: {str(e)}", exc_info=True)
            flash("Error updating profile", "error")
    
        return redirect(url_for('hr.profile'))

    @app.route('/hr/settings', endpoint='hr.settings')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def settings():
        try:
            user_id = session.get('user_id')
            if not user_id:
                flash("Please log in to access settings", "error")
                return redirect(url_for('login'))
            
            user = User.query.get_or_404(user_id)
            return render_template('hr/settings/index.html', user=user)
        except Exception as e:
            current_app.logger.error(f"Settings error: {str(e)}")
            flash("Error loading settings", "error")
            return render_template('error.html'), 500

    @app.route('/hr/settings/password', methods=['POST'], endpoint='hr.change_password')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def change_password():
        """Change user password"""
        try:
            user_id = session.get('user_id')
            if not user_id:
                return jsonify({'success': False, 'message': 'Please log in'}), 401
            
            user = User.query.get_or_404(user_id)
            
            current_password = request.form.get('current_password')
            new_password = request.form.get('new_password')
            confirm_password = request.form.get('confirm_password')
            
            # Validate inputs
            if not all([current_password, new_password, confirm_password]):
                flash("All password fields are required", "error")
                return redirect(url_for('hr.settings'))
            
            # Verify current password
            if not user.check_password(current_password):
                flash("Current password is incorrect", "error")
                return redirect(url_for('hr.settings'))
            
            # Check if new passwords match
            if new_password != confirm_password:
                flash("New passwords do not match", "error")
                return redirect(url_for('hr.settings'))
            
            # Check password strength (minimum 8 characters)
            if len(new_password) < 8:
                flash("Password must be at least 8 characters long", "error")
                return redirect(url_for('hr.settings'))
            
            # Update password
            user.set_password(new_password)
            user.updated_at = datetime.now(timezone.utc)
            db.session.commit()
            
            current_app.logger.info(f"Password changed for user {user.name} (ID: {user.id})")
            flash("Password changed successfully", "success")
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Password change error: {str(e)}", exc_info=True)
            flash("Error changing password", "error")
        
        return redirect(url_for('hr.settings'))

    @app.route('/hr/settings/preferences', methods=['POST'], endpoint='hr.update_preferences')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def update_preferences():
        """Update user preferences"""
        try:
            user_id = session.get('user_id')
            if not user_id:
                return jsonify({'success': False, 'message': 'Please log in'}), 401
            
            user = User.query.get_or_404(user_id)
            
            # Get form data
            language = request.form.get('language', 'English')
            timezone_pref = request.form.get('timezone', 'UTC (GMT+0)')
            date_format = request.form.get('date_format', 'DD/MM/YYYY')
            
            # Note: These would typically be stored in a UserPreferences table
            # For now, we'll just acknowledge the update
            
            current_app.logger.info(f"Preferences updated for user {user.name} (ID: {user.id})")
            flash("Preferences updated successfully", "success")
            
        except Exception as e:
            current_app.logger.error(f"Preference update error: {str(e)}", exc_info=True)
            flash("Error updating preferences", "error")
        
        return redirect(url_for('hr.settings'))

# Bulk import employees from payroll table (expects JSON list of dicts)
    @app.route('/hr/employee/import', methods=["POST"], endpoint='hr.import_employees')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def import_employees():
        data = request.get_json()
        created, updated = 0, 0
        for row in data:
            emp = Employee.query.filter_by(email=row.get('email')).first()
            if not emp:
                emp = Employee()
                created += 1
            else:
                updated += 1
            emp.name = row.get('name')
            emp.role = row.get('designation')
            emp.status = 'Active'
            emp.department = row.get('site')
            emp.position = row.get('designation')
            emp.phone = row.get('phone')
            emp.email = row.get('email')
            emp.grade = row.get('grade')
            emp.salary = float(row.get('gross', 0))
            emp.date_of_employment = datetime.strptime(row.get('employment_date'), '%d/%m/%Y').date() if row.get('employment_date') else None
            db.session.add(emp)
        db.session.commit()
        return jsonify({'status': 'success', 'created': created, 'updated': updated})

# --- Employee CRUD Endpoint ---
    @app.route('/hr/employee', methods=["POST"], endpoint='hr.create_or_update_employee')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def create_or_update_employee():
        data = request.get_json()
        emp_id = data.get('id')
        if emp_id:
            emp = db.session.get(Employee, emp_id)
            if not emp:
                return jsonify({'error': 'Employee not found'}), 404
        else:
            emp = Employee()
        emp.name = data.get('name', emp.name)
        emp.role = data.get('role', emp.role)
        emp.status = data.get('status', emp.status)
        emp.department = data.get('department', emp.department)
        emp.position = data.get('position', emp.position)
        emp.phone = data.get('phone', emp.phone)
        emp.email = data.get('email', emp.email)
        emp.grade = data.get('grade', getattr(emp, 'grade', None))
        emp.salary = data.get('salary', getattr(emp, 'salary', None))
        if not emp_id:
            db.session.add(emp)
        db.session.commit()
        return jsonify({'status': 'success', 'id': emp.id})

# --- Staff Deduction API Endpoint (Legacy) ---
    @app.route('/hr/deduction', methods=["POST"], endpoint='hr.legacy_add_deduction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def legacy_add_deduction():
        from sqlalchemy import extract
        data = request.get_json()
        employee_id = data.get('employee_id')
        name = data.get('name')
        amount = data.get('amount')
        month = data.get('month')  # format: 'YYYY-MM'
        if not (employee_id and name and amount and month):
            return jsonify({'error': 'Missing required fields'}), 400
    # Parse month
        try:
            month_dt = datetime.strptime(month, '%Y-%m')
        except Exception:
            return jsonify({'error': 'Invalid month format'}), 400
    # Deduction model assumed
        from sqlalchemy import text
        db.session.execute(text('''INSERT INTO deduction (employee_id, name, amount, month) VALUES (:employee_id, :name, :amount, :month)'''), {
            'employee_id': employee_id, 'name': name, 'amount': amount, 'month': month
        })
        db.session.commit()
        return jsonify({'status': 'success'})

# --- Payroll Compilation Endpoint ---
    @app.route('/hr/payroll', methods=["POST"], endpoint='hr.compile_payroll')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def compile_payroll():
        data = request.get_json()
        period_start = data.get('period_start')
        period_end = data.get('period_end')
        if not (period_start and period_end):
            return jsonify({'error': 'Missing period'}), 400
        period_start_dt = datetime.strptime(period_start, '%Y-%m-%d').date()
        period_end_dt = datetime.strptime(period_end, '%Y-%m-%d').date()
        employees = Employee.query.filter_by(status='Active').all()
        payroll_records = []
        for emp in employees:
            salary = float(getattr(emp, 'salary', 0.0) or 0.0)
        # Sum deductions for this employee and month
            month_str = period_start_dt.strftime('%Y-%m')
            result = db.session.execute(
                "SELECT SUM(amount) FROM deduction WHERE employee_id = :eid AND month = :month",
                {'eid': emp.id, 'month': month_str}
            )
            deductions = result.scalar() or 0.0
            net_salary = salary - deductions
            payroll = Payroll(
                employee_id=emp.id,
                period_start=period_start_dt,
                period_end=period_end_dt,
                amount=salary,
                deductions=deductions,
                status='Pending Approval',
                created_at=datetime.now(timezone.utc)
            )
            db.session.add(payroll)
            payroll_records.append({
                'employee_id': emp.id,
                'name': emp.name,
                'site': emp.department,
                'employment_date': emp.date_of_employment.strftime('%d/%m/%Y') if emp.date_of_employment else '',
                'designation': emp.position,
                'gross': salary,
                'deductions': deductions,
                'net_salary': net_salary
            })
        db.session.commit()
    # Forward to management for approval (could trigger notification here)
        return jsonify({'status': 'success', 'records': payroll_records})

# --- Payroll by Month Endpoint ---
    @app.route('/hr/payroll/<string:month>', methods=["GET"], endpoint='hr.get_payroll_by_month')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def get_payroll_by_month(month):
    # month: 'YYYY-MM'
        try:
            period_start = datetime.strptime(month + '-01', '%Y-%m-%d').date()
        except Exception:
            return jsonify({'error': 'Invalid month format'}), 400
        payrolls = Payroll.query.filter(
            db.extract('year', Payroll.period_start) == period_start.year,
            db.extract('month', Payroll.period_start) == period_start.month
        ).all()
        result = []
        for p in payrolls:
            emp = db.session.get(Employee, p.employee_id)
            result.append({
                'employee_id': p.employee_id,
                'name': emp.name if emp else '',
                'gross_salary': p.gross or 0,
                'deductions': (p.minna_paye or 0) + (p.jaco or 0) + (p.late_deduction or 0),
                'net_salary': p.balance_salary or 0,
                'status': 'Paid'
            })
        return jsonify({'payroll': result})

# --- HR Document Management Routes ---
    @app.route('/hr/staff/<int:staff_id>/documents', endpoint='hr.staff_documents')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def staff_documents(staff_id):
        """View documents for a specific staff member"""
    
        emp = db.session.get(Employee, staff_id)
        if not emp:
            flash("Staff not found", "error")
            return redirect(url_for('hr.staff_list'))
    
    # Get documents for this employee
        documents = UploadedFile.query.filter_by(employee_id=staff_id).order_by(UploadedFile.uploaded_at.desc()).all()
    
        return render_template('hr/staff/documents.html', 
                             staff=emp, 
                             documents=documents)

    @app.route('/hr/staff/<int:staff_id>/documents/upload', methods=['GET', 'POST'], endpoint='hr.upload_staff_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def upload_staff_document(staff_id):
        """Upload a document for a specific staff member"""
        from werkzeug.utils import secure_filename
    
        emp = db.session.get(Employee, staff_id)
        if not emp:
            flash("Staff not found", "error")
            return redirect(url_for('hr.staff_list'))
    
        if request.method == 'POST':
            if 'file' not in request.files:
                flash('No file selected', 'error')
                return redirect(request.url)
        
            file = request.files['file']
            if file.filename == '':
                flash('No file selected', 'error')
                return redirect(request.url)
        
        # Allowed file types for HR documents
            ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'txt', 'jpg', 'jpeg', 'png'}
        
            def allowed_file(filename):
                return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
        
            if not allowed_file(file.filename):
                flash('File type not allowed. Please upload PDF, DOC, DOCX, TXT, JPG, JPEG, or PNG files.', 'error')
                return redirect(request.url)
        
        # Create uploads directory if it doesn't exist
            upload_folder = os.path.join(current_app.instance_path, 'uploads', 'staff_documents')
            os.makedirs(upload_folder, exist_ok=True)
        
        # Secure filename
            filename = secure_filename(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_')
            filename = timestamp + filename
        
            file_path = os.path.join(upload_folder, filename)
        
            try:
                file.save(file_path)
            
            # Get file info
                file_size = os.path.getsize(file_path)
                document_type = request.form.get('document_type', 'Other')
                description = request.form.get('description', '')
            
            # Save to database
                uploaded_file = UploadedFile(
                    filename=filename,
                    name=file.filename,  # original filename
                    path=file_path,  # using 'path' field instead of 'file_path'
                    file_size=file_size,
                    uploaded_by=session.get('user_id'),
                    employee_id=staff_id,
                    folder=document_type,
                    tags=description
                )
            
                db.session.add(uploaded_file)
                db.session.commit()
            
                flash(f'Document "{file.filename}" uploaded successfully for {emp.name}', 'success')
                return redirect(url_for('hr.staff_documents', staff_id=staff_id))
            
            except Exception as e:
                current_app.logger.error(f"Error uploading file: {str(e)}")
                flash('Error uploading file', 'error')
                return redirect(request.url)
    
        return render_template('hr/staff/upload_document.html', staff=emp)

    @app.route('/hr/staff/<int:staff_id>/documents/<int:doc_id>/download', endpoint='hr.download_staff_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def download_staff_document(staff_id, doc_id):
        """Download a document for a specific staff member"""
    
        emp = db.session.get(Employee, staff_id)
        if not emp:
            flash("Staff not found", "error")
            return redirect(url_for('hr.staff_list'))
    
        doc = UploadedFile.query.filter_by(id=doc_id, employee_id=staff_id).first()
        if not doc:
            flash("Document not found", "error")
            return redirect(url_for('hr.staff_documents', staff_id=staff_id))
    
        if not os.path.exists(doc.path):
            flash("File not found on server", "error")
            return redirect(url_for('hr.staff_documents', staff_id=staff_id))
    
        return send_file(doc.path, 
                         as_attachment=True, 
                         download_name=doc.name)

    @app.route('/hr/staff/<int:staff_id>/documents/<int:doc_id>/delete', methods=['POST'], endpoint='hr.delete_staff_document')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def delete_staff_document(staff_id, doc_id):
        """Delete a document for a specific staff member"""
    
        emp = db.session.get(Employee, staff_id)
        if not emp:
            flash("Staff not found", "error")
            return redirect(url_for('hr.staff_list'))
    
        doc = UploadedFile.query.filter_by(id=doc_id, employee_id=staff_id).first()
        if not doc:
            flash("Document not found", "error")
            return redirect(url_for('hr.staff_documents', staff_id=staff_id))
    
        try:
        # Delete file from filesystem
            if os.path.exists(doc.path):
                os.remove(doc.path)
        
        # Delete from database
            db.session.delete(doc)
            db.session.commit()
        
            flash(f'Document "{doc.name}" deleted successfully', 'success')
        except Exception as e:
            current_app.logger.error(f"Error deleting document: {str(e)}")
            flash('Error deleting document', 'error')
    
        return redirect(url_for('hr.staff_documents', staff_id=staff_id))

# --- Staff Deduction Management Routes ---
    @app.route('/hr/staff/<int:staff_id>/deductions', endpoint='hr.staff_deductions')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def staff_deductions(staff_id):
        """View staff deductions"""
        try:
        
            employee = db.session.get(Employee, staff_id)
            if not employee:
                flash("Employee not found", "error")
                return redirect(url_for('hr.staff_list'))
        
        # Get active deductions for this employee
            deductions = db.session.query(StaffDeduction, User).join(
                User, StaffDeduction.created_by == User.id
            ).filter(
                StaffDeduction.employee_id == staff_id,
                StaffDeduction.status.in_(['active', 'completed'])
            ).order_by(StaffDeduction.created_at.desc()).all()
        
            return render_template('hr/staff/deductions.html', 
                                 employee=employee, 
                                 deductions=deductions)
        
        except Exception as e:
            current_app.logger.error(f"Error loading staff deductions: {str(e)}")
            flash("Error loading deductions", "error")
            return redirect(url_for('hr.staff_list'))

    @app.route('/hr/staff/<int:staff_id>/deductions/add', methods=['GET', 'POST'], endpoint='hr.add_staff_deduction')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def add_staff_deduction(staff_id):
        """Add a new deduction for staff member"""
        try:
        
            employee = db.session.get(Employee, staff_id)
            if not employee:
                flash("Employee not found", "error")
                return redirect(url_for('hr.staff_list'))
        
            if request.method == 'POST':
                deduction_type = request.form.get('deduction_type')
                amount = float(request.form.get('amount', 0))
                reason = request.form.get('reason')
            
                if not all([deduction_type, amount, reason]):
                    flash("All fields are required", "error")
                    return render_template('hr/staff/add_deduction.html', employee=employee)
            
                if amount <= 0:
                    flash("Amount must be greater than zero", "error")
                    return render_template('hr/staff/add_deduction.html', employee=employee)
            
            # Create new deduction
                new_deduction = StaffDeduction(
                    employee_id=staff_id,
                    deduction_type=deduction_type,
                    amount=amount,
                    reason=reason,
                    created_by=session.get('user_id'),
                    status='active'
                )
            
                db.session.add(new_deduction)
                db.session.commit()
            
                current_app.logger.info(f"Added deduction for {employee.name}: {deduction_type} - {amount}")
                flash(f"Deduction added successfully for {employee.name}", "success")
                return redirect(url_for('hr.staff_deductions', staff_id=staff_id))
        
            return render_template('hr/staff/add_deduction.html', employee=employee)
        
        except ValueError:
            flash("Invalid amount entered", "error")
            return redirect(url_for('hr.staff_deductions', staff_id=staff_id))
        except Exception as e:
            current_app.logger.error(f"Error adding staff deduction: {str(e)}")
            flash("Error adding deduction", "error")
            return redirect(url_for('hr.staff_deductions', staff_id=staff_id))

    @app.route('/hr/deductions/<int:deduction_id>/toggle', methods=['POST'], endpoint='hr.toggle_deduction_status')
    @role_required([Roles.SUPER_HQ, Roles.HQ_HR])
    def toggle_deduction_status(deduction_id):
        """Toggle deduction between active and cancelled"""
        try:
        
            deduction = db.session.get(StaffDeduction, deduction_id)
            if not deduction:
                flash("Deduction not found", "error")
                return redirect(url_for('hr.staff_list'))
        
        # Toggle status
            if deduction.status == 'active':
                deduction.status = 'cancelled'
                flash("Deduction cancelled", "success")
            else:
                deduction.status = 'active'
                flash("Deduction reactivated", "success")
        
            db.session.commit()
        
            return redirect(url_for('hr.staff_deductions', staff_id=deduction.employee_id))
        
        except Exception as e:
            current_app.logger.error(f"Error toggling deduction status: {str(e)}")
            flash("Error updating deduction", "error")
            return redirect(url_for('hr.staff_list'))


    # ============================================================================
    # ROUTES FROM ADMIN.PY
    # ============================================================================

    # All imports already at top of file

    def send_order_notification(user_email, order_number, status, reason=None):
        """Send email notification for purchase order status changes"""
        try:
            subject = f"Purchase Order {order_number} - Status Update"
        
            if status == 'Approved':
                body = f"""
    Dear User,

    Your Purchase Order {order_number} has been APPROVED.

    The order is now approved and will proceed to the next stage in the procurement process.

    Best regards,
    Construction Management Team
                """
            elif status == 'Rejected':
                body = f"""
    Dear User,

    Your Purchase Order {order_number} has been REJECTED.

    Reason: {reason or 'No specific reason provided'}

    Please review the rejection reason and resubmit the order with necessary corrections if required.

    Best regards,
    Construction Management Team
                """
        
            msg = Message(subject,
                         sender=current_app.config['MAIL_DEFAULT_SENDER'],
                         recipients=[user_email])
            msg.body = body
        
            mail.send(msg)
            return True
        except Exception as e:
            current_app.logger.error(f"Failed to send order notification: {str(e)}")
            return False


# Dashboard Route
    @app.route('/admin', endpoint='admin.dashboard')
    @role_required([Roles.SUPER_HQ])
    def dashboard():
        try:
            # Get summary stats for dashboard
            total_projects = Project.query.count()
            active_projects = Project.query.filter(Project.status.in_(['Active', 'In Progress', 'Ongoing'])).count()
            total_staff = Employee.query.count()
            total_alerts = Alert.query.filter_by(status='Active').count()
            
            # Get recent activity logs (last 10 activities)
            recent_activities = ProjectActivity.query.order_by(ProjectActivity.created_at.desc()).limit(10).all()
            
            summary = {
                'total_projects': total_projects,
                'active_projects': active_projects,
                'total_staff': total_staff,
                'total_alerts': total_alerts
            }
            
            return render_template('admin/index.html', summary=summary, current_datetime=datetime.now(), recent_activities=recent_activities)
        except Exception as e:
            current_app.logger.error(f'Admin dashboard error: {str(e)}')
            import traceback
            current_app.logger.error(traceback.format_exc())
            flash(f'Error loading dashboard: {str(e)}', 'error')
            return render_template('error.html'), 500

# Activity Log View
    @app.route('/admin/activity-log', endpoint='admin.activity_log')
    @role_required([Roles.SUPER_HQ])
    def activity_log():
        try:
            # Get pagination parameters
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 50, type=int)
            
            # Get filter parameters
            action_type = request.args.get('action_type', '')
            user_name = request.args.get('user_name', '')
            date_from = request.args.get('date_from', '')
            date_to = request.args.get('date_to', '')
            
            # Build query
            query = ProjectActivity.query
            
            # Apply filters
            if action_type:
                query = query.filter(ProjectActivity.action_type.ilike(f'%{action_type}%'))
            if user_name:
                query = query.filter(ProjectActivity.user_name.ilike(f'%{user_name}%'))
            if date_from:
                try:
                    date_from_obj = datetime.strptime(date_from, '%Y-%m-%d')
                    query = query.filter(ProjectActivity.created_at >= date_from_obj)
                except ValueError:
                    pass
            if date_to:
                try:
                    date_to_obj = datetime.strptime(date_to, '%Y-%m-%d')
                    # Add one day to include the entire end date
                    date_to_obj = date_to_obj + timedelta(days=1)
                    query = query.filter(ProjectActivity.created_at < date_to_obj)
                except ValueError:
                    pass
            
            # Order by most recent first and paginate
            pagination = query.order_by(ProjectActivity.created_at.desc()).paginate(
                page=page, per_page=per_page, error_out=False
            )
            
            activities = pagination.items
            
            # Get unique action types and users for filter dropdowns
            action_types = db.session.query(ProjectActivity.action_type).distinct().all()
            action_types = [at[0] for at in action_types if at[0]]
            
            user_names = db.session.query(ProjectActivity.user_name).distinct().all()
            user_names = [un[0] for un in user_names if un[0]]
            
            return render_template('admin/activity_log.html', 
                                 activities=activities,
                                 pagination=pagination,
                                 action_types=action_types,
                                 user_names=user_names,
                                 current_filters={
                                     'action_type': action_type,
                                     'user_name': user_name,
                                     'date_from': date_from,
                                     'date_to': date_to
                                 })
        except Exception as e:
            current_app.logger.error(f'Activity log error: {str(e)}')
            import traceback
            current_app.logger.error(traceback.format_exc())
            flash(f'Error loading activity log: {str(e)}', 'error')
            return redirect(url_for('admin.dashboard'))

# Approvals Management
    @app.route('/admin/approvals', endpoint='admin.approvals')
    @role_required([Roles.SUPER_HQ])
    def approvals():
        try:
            # Get all pending approvals from different modules
            
            # 1. PROCUREMENT - Purchase Orders pending approval
            pending_purchase_orders = PurchaseOrder.query.filter_by(status='Pending').order_by(PurchaseOrder.created_at.desc()).all()
            
            # 2. PROCUREMENT - Procurement Requests
            pending_procurements = ProcurementRequest.query.filter(
                ProcurementRequest.status.in_(['Pending', 'pending'])
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # 3. HR - Payroll approvals pending
            pending_payrolls = PayrollApproval.query.filter(
                PayrollApproval.status.in_(['pending_admin', 'approved_by_admin', 'Pending', 'pending'])
            ).order_by(PayrollApproval.submitted_at.desc()).all()
            
            # 4. HR - Leave Requests
            pending_leaves = Leave.query.filter(
                Leave.status.in_(['Pending', 'pending'])
            ).order_by(Leave.created_at.desc()).all()
            
            # 5. FINANCE - Expenses pending approval
            pending_expenses = Expense.query.filter(
                Expense.status.in_(['Pending', 'pending'])
            ).order_by(Expense.date.desc()).all()
            
            # 6. FINANCE - Budget requests
            recent_budgets = Budget.query.order_by(Budget.created_at.desc()).limit(20).all()
            pending_budgets = [b for b in recent_budgets if b.usage_percentage < 100]
            
            # 7. PROJECT MANAGEMENT - Project Approvals (new projects or status pending)
            pending_projects = Project.query.filter(
                Project.status.in_(['Pending', 'pending', 'pending_approval'])
            ).order_by(Project.created_at.desc()).all()
            
            # 8. COST CONTROL - Asset Purchases or Transfers
            pending_assets = Asset.query.filter(
                Asset.status.in_(['Pending', 'pending', 'pending_approval'])
            ).order_by(Asset.purchase_date.desc()).all()
            
            # 9. QUARRY/SAFETY - Incident Reports requiring review
            pending_incidents = Incident.query.filter(
                Incident.status.in_(['Pending', 'pending', 'under_review', 'Open'])
            ).order_by(Incident.date_reported.desc()).all()
            
            # 10. GENERAL - Document Approvals
            pending_documents = Document.query.filter(
                Document.status.in_(['pending_review', 'Pending'])
            ).order_by(Document.uploaded_at.desc()).all()
            
            # Organize approvals by department with detailed info
            approvals_data = []
            
            # PROCUREMENT APPROVALS
            for order in pending_purchase_orders:
                requester = db.session.get(Employee, order.requested_by) if order.requested_by else None
                requester_name = requester.name if requester else 'Unknown'
                approvals_data.append({
                    'id': order.id,
                    'type': 'purchase_order',
                    'department': 'Procurement',
                    'title': f"Purchase Order: {order.order_number}",
                    'description': order.description or 'No description',
                    'amount': float(order.total_amount) if order.total_amount else 0,
                    'requested_by': requester_name,
                    'requested_date': order.created_at.strftime('%Y-%m-%d %H:%M') if order.created_at else 'N/A',
                    'priority': 'High' if order.total_amount and order.total_amount > 500000 else 'Medium',
                    'details': {
                        'order_number': order.order_number,
                        'supplier': order.supplier_name,
                        'total_amount': f"{order.total_amount:,.2f}" if order.total_amount else 'N/A',
                        'expected_delivery': order.expected_delivery.strftime('%Y-%m-%d') if order.expected_delivery else 'N/A'
                    }
                })
            
            for proc in pending_procurements:
                total_value = (proc.price * proc.qty) if proc.price and proc.qty else 0
                approvals_data.append({
                    'id': proc.id,
                    'type': 'procurement',
                    'department': 'Procurement',
                    'title': f"Procurement: {proc.item_name}",
                    'description': f"Quantity: {proc.qty} {proc.unit}",
                    'amount': total_value,
                    'requested_by': proc.current_approver or 'Procurement Team',
                    'requested_date': proc.created_at.strftime('%Y-%m-%d %H:%M') if proc.created_at else 'N/A',
                    'priority': 'High' if total_value > 300000 else 'Medium',
                    'details': {
                        'item_name': proc.item_name,
                        'quantity': f"{proc.qty} {proc.unit}",
                        'unit_price': f"{proc.price:,.2f}" if proc.price else 'N/A',
                        'total_value': f"{total_value:,.2f}"
                    }
                })
            
            # HR APPROVALS
            for payroll in pending_payrolls:
                submitter = db.session.get(User, payroll.submitted_by) if payroll.submitted_by else None
                submitter_name = submitter.name if submitter else 'HR Department'
                approvals_data.append({
                    'id': payroll.id,
                    'type': 'payroll',
                    'department': 'HR',
                    'title': f"Payroll: {payroll.period_month}/{payroll.period_year}",
                    'description': f"Monthly payroll processing",
                    'amount': float(payroll.total_amount) if payroll.total_amount else 0,
                    'requested_by': submitter_name,
                    'requested_date': payroll.submitted_at.strftime('%Y-%m-%d %H:%M') if payroll.submitted_at else 'N/A',
                    'priority': 'High',
                    'details': {
                        'period': f"{payroll.period_month}/{payroll.period_year}",
                        'employee_count': payroll.employee_count,
                        'total_amount': f"{payroll.total_amount:,.2f}" if payroll.total_amount else 'N/A'
                    }
                })
            
            for leave in pending_leaves:
                employee = db.session.get(Employee, leave.employee_id) if leave.employee_id else None
                employee_name = employee.name if employee else 'Unknown'
                approvals_data.append({
                    'id': leave.id,
                    'type': 'leave',
                    'department': 'HR',
                    'title': f"Leave Request: {employee_name}",
                    'description': f"{leave.type} leave request" if leave.type else 'Leave request',
                    'amount': 0,
                    'requested_by': employee_name,
                    'requested_date': leave.created_at.strftime('%Y-%m-%d %H:%M') if leave.created_at else 'N/A',
                    'priority': 'Medium',
                    'details': {
                        'leave_type': leave.type if leave.type else 'N/A',
                        'start_date': leave.start.strftime('%Y-%m-%d') if leave.start else 'N/A',
                        'end_date': leave.end.strftime('%Y-%m-%d') if leave.end else 'N/A',
                        'status': leave.status,
                        'employee_id': leave.employee_id
                    }
                })
            
            # FINANCE APPROVALS
            for expense in pending_expenses:
                user = db.session.get(User, expense.user_id) if expense.user_id else None
                user_name = user.name if user else 'Unknown'
                approvals_data.append({
                    'id': expense.id,
                    'type': 'expense',
                    'department': 'Finance',
                    'title': f"Expense: {expense.description[:50] if expense.description else 'N/A'}",
                    'description': expense.description or 'No description',
                    'amount': float(expense.amount) if expense.amount else 0,
                    'requested_by': user_name,
                    'requested_date': expense.date.strftime('%Y-%m-%d') if expense.date else 'N/A',
                    'priority': 'High' if expense.amount and expense.amount > 100000 else 'Medium',
                    'details': {
                        'category': expense.category,
                        'amount': f"{expense.amount:,.2f}" if expense.amount else 'N/A',
                        'date': expense.date.strftime('%Y-%m-%d') if expense.date else 'N/A',
                        'requester_email': user.email if user else None
                    }
                })
            
            for budget in pending_budgets:
                project_name = budget.project.name if budget.project else 'General'
                approvals_data.append({
                    'id': budget.id,
                    'type': 'budget',
                    'department': 'Finance',
                    'title': f"Budget: {project_name} - {budget.category}",
                    'description': f"Budget allocation for {budget.category}",
                    'amount': float(budget.allocated_amount) if budget.allocated_amount else 0,
                    'requested_by': 'Finance Team',
                    'requested_date': budget.created_at.strftime('%Y-%m-%d %H:%M') if budget.created_at else 'N/A',
                    'priority': 'Medium',
                    'details': {
                        'category': budget.category,
                        'allocated': f"{budget.allocated_amount:,.2f}" if budget.allocated_amount else 'N/A',
                        'spent': f"{budget.spent_amount:,.2f}" if budget.spent_amount else 'N/A',
                        'remaining': f"{(budget.allocated_amount - budget.spent_amount):,.2f}" if budget.allocated_amount and budget.spent_amount else 'N/A',
                        'usage': f"{budget.usage_percentage:.1f}%"
                    }
                })
            
            # PROJECT MANAGEMENT APPROVALS
            for project in pending_projects:
                approvals_data.append({
                    'id': project.id,
                    'type': 'project',
                    'department': 'Project Management',
                    'title': f"Project: {project.name}",
                    'description': project.description or 'No description',
                    'amount': float(project.budget) if project.budget else 0,
                    'requested_by': project.project_manager if project.project_manager else 'PM Team',
                    'requested_date': project.created_at.strftime('%Y-%m-%d %H:%M') if project.created_at else 'N/A',
                    'priority': 'High',
                    'details': {
                        'location': project.site_location if project.site_location else 'N/A',
                        'budget': f"{project.budget:,.2f}" if project.budget else 'N/A',
                        'start_date': project.start_date.strftime('%Y-%m-%d') if project.start_date else 'N/A',
                        'end_date': project.end_date.strftime('%Y-%m-%d') if project.end_date else 'N/A',
                        'client': project.client_name if project.client_name else 'N/A'
                    }
                })
            
            # COST CONTROL APPROVALS
            for asset in pending_assets:
                approvals_data.append({
                    'id': asset.id,
                    'type': 'asset',
                    'department': 'Cost Control',
                    'title': f"Asset: {asset.name}",
                    'description': f"{asset.type} - {asset.name}",
                    'amount': 0,
                    'requested_by': 'Cost Control Team',
                    'requested_date': asset.purchase_date.strftime('%Y-%m-%d') if asset.purchase_date else 'N/A',
                    'priority': 'Medium',
                    'details': {
                        'type': asset.type,
                        'status': asset.status,
                        'location': asset.location if asset.location else 'N/A',
                        'purchase_date': asset.purchase_date.strftime('%Y-%m-%d') if asset.purchase_date else 'N/A'
                    }
                })
            
            # QUARRY/SAFETY APPROVALS
            for incident in pending_incidents:
                approvals_data.append({
                    'id': incident.id,
                    'type': 'incident',
                    'department': 'Quarry/Safety',
                    'title': f"Incident Report: {incident.title}",
                    'description': incident.description or 'No description',
                    'amount': 0,
                    'requested_by': incident.reported_by if incident.reported_by else 'Safety Team',
                    'requested_date': incident.date_reported.strftime('%Y-%m-%d %H:%M') if incident.date_reported else 'N/A',
                    'priority': 'High' if incident.severity in ['Critical', 'High'] else 'Medium',
                    'details': {
                        'title': incident.title,
                        'severity': incident.severity if incident.severity else 'N/A',
                        'status': incident.status,
                        'date_reported': incident.date_reported.strftime('%Y-%m-%d') if incident.date_reported else 'N/A'
                    }
                })
            
            # DOCUMENT APPROVALS
            for doc in pending_documents:
                uploader_name = doc.uploader.name if doc.uploader else 'Unknown'
                approvals_data.append({
                    'id': doc.id,
                    'type': 'document',
                    'department': doc.category if doc.category else 'General',
                    'title': f"Document: {doc.filename}",
                    'description': f"Document category: {doc.category}" if doc.category else 'Document review required',
                    'amount': 0,
                    'requested_by': uploader_name,
                    'requested_date': doc.uploaded_at.strftime('%Y-%m-%d %H:%M') if doc.uploaded_at else 'N/A',
                    'priority': 'Medium',
                    'details': {
                        'filename': doc.filename,
                        'category': doc.category,
                        'size': f"{doc.size / 1024:.2f} KB" if doc.size else 'N/A',
                        'project_id': doc.project_id if doc.project_id else 'N/A'
                    }
                })
            
            # Sort by priority and date
            approvals_data.sort(key=lambda x: (
                0 if x['priority'] == 'High' else 1,
                x['requested_date']
            ), reverse=True)
            
            # Count totals by department
            totals = {
                'procurement': len(pending_purchase_orders) + len(pending_procurements),
                'hr': len(pending_payrolls) + len(pending_leaves),
                'finance': len(pending_expenses) + len(pending_budgets),
                'project_management': len(pending_projects),
                'cost_control': len(pending_assets),
                'quarry_safety': len(pending_incidents),
                'documents': len(pending_documents),
                'total': len(approvals_data)
            }
            
            return render_template('admin/approvals_new.html',
                                 approvals=approvals_data,
                                 totals=totals)
        except Exception as e:
            current_app.logger.error(f'Approvals page error: {str(e)}')
            current_app.logger.error(traceback.format_exc())
            flash(f'Error loading approvals: {str(e)}', 'error')
            return redirect(url_for('admin.dashboard'))

    @app.route('/admin/process-approval-request', methods=['POST'], endpoint='admin.process_approval_request')
    @role_required([Roles.SUPER_HQ])
    def process_approval_request():
        try:
            data = request.get_json()
            action = data.get('action')  # 'approve' or 'reject'
            item_type = data.get('type')
            item_id = data.get('id')
            comments = data.get('comments', '')
            forward = data.get('forward', False)
            forward_email = data.get('forwardEmail', '')
            forward_message = data.get('forwardMessage', '')
            
            current_app.logger.info(f'Processing approval: {action} for {item_type} #{item_id}')
            
            item_details = {}
            requester_email = None
            requester_name = 'User'
            
            # Process based on item type
            if item_type == 'purchase_order':
                item = db.session.get(PurchaseOrder, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Purchase order not found'}), 404
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                item_details = {'type': 'Purchase Order', 'order_number': item.order_number, 'supplier': item.supplier_name, 'amount': f"{item.total_amount:,.2f}" if item.total_amount else 'N/A'}
                
            elif item_type == 'procurement':
                item = db.session.get(ProcurementRequest, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Procurement request not found'}), 404
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                item_details = {'type': 'Procurement Request', 'item': item.item_name, 'quantity': f"{item.qty} {item.unit}"}
                
            elif item_type == 'payroll':
                item = db.session.get(PayrollApproval, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Payroll not found'}), 404
                item.status = 'approved_by_admin' if action == 'approve' else 'rejected'
                submitter = db.session.get(User, item.submitted_by) if item.submitted_by else None
                requester_name = submitter.name if submitter else 'HR Department'
                requester_email = submitter.email if submitter else None
                item_details = {'type': 'Payroll Request', 'period': f"{item.period_month}/{item.period_year}", 'amount': f"{item.total_amount:,.2f}" if item.total_amount else 'N/A'}
                
            elif item_type == 'leave':
                item = db.session.get(Leave, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Leave request not found'}), 404
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                employee = db.session.get(Employee, item.employee_id) if item.employee_id else None
                requester_name = employee.name if employee else 'Unknown'
                requester_email = employee.email if employee else None
                item_details = {'type': 'Leave Request', 'employee': requester_name, 'leave_type': item.type if item.type else 'N/A', 'start_date': item.start.strftime('%Y-%m-%d') if item.start else 'N/A'}
                
            elif item_type == 'expense':
                item = db.session.get(Expense, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Expense not found'}), 404
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                user = db.session.get(User, item.user_id) if item.user_id else None
                requester_name = user.name if user else 'Unknown'
                requester_email = user.email if user else None
                item_details = {'type': 'Expense Claim', 'description': item.description or 'N/A', 'amount': f"{item.amount:,.2f}" if item.amount else 'N/A'}
                
            elif item_type == 'budget':
                item = db.session.get(Budget, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Budget not found'}), 404
                # Budget doesn't have status, so we'll just log the approval
                item_details = {'type': 'Budget Request', 'category': item.category, 'amount': f"{item.allocated_amount:,.2f}" if item.allocated_amount else 'N/A'}
                
            elif item_type == 'project':
                item = db.session.get(Project, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Project not found'}), 404
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                item_details = {'type': 'Project Approval', 'name': item.name, 'location': item.site_location if item.site_location else 'N/A', 'budget': f"{item.budget:,.2f}" if item.budget else 'N/A'}
                
            elif item_type == 'asset':
                item = db.session.get(Asset, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Asset not found'}), 404
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                item_details = {'type': 'Asset Purchase', 'name': item.name, 'type': item.type, 'location': item.location if item.location else 'N/A'}
                
            elif item_type == 'incident':
                item = db.session.get(Incident, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Incident report not found'}), 404
                item.status = 'Closed' if action == 'approve' else 'Rejected'
                item_details = {'type': 'Incident Report', 'title': item.title, 'severity': item.severity if item.severity else 'N/A'}
                
            elif item_type == 'document':
                item = db.session.get(Document, item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Document not found'}), 404
                item.status = 'approved' if action == 'approve' else 'rejected'
                item_details = {'type': 'Document Review', 'filename': item.filename}
                
            else:
                return jsonify({'success': False, 'message': 'Invalid item type'}), 400
            
            db.session.commit()
            current_app.logger.info(f'Successfully committed {action} for {item_type} #{item_id}')
            
            # Send email to requester
            if requester_email:
                status_text = 'Approved' if action == 'approve' else 'Rejected'
                status_color = '#10B981' if action == 'approve' else '#EF4444'
                email_body = f"""
                <html><head><style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .header {{ background-color: {status_color}; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }}
                    .content {{ background-color: #f9fafb; padding: 30px; border: 1px solid #e5e7eb; }}
                    .details {{ background-color: white; padding: 15px; margin: 15px 0; border-radius: 6px; border-left: 4px solid {status_color}; }}
                    .detail-row {{ padding: 8px 0; border-bottom: 1px solid #e5e7eb; }}
                    .status-badge {{ display: inline-block; padding: 8px 16px; background-color: {status_color}; color: white; border-radius: 20px; font-weight: bold; }}
                </style></head><body>
                    <div class="container">
                        <div class="header"><h1>Request {status_text}</h1></div>
                        <div class="content">
                            <p>Dear {requester_name},</p>
                            <p>Your request has been <strong>{status_text.lower()}</strong> by {current_user.name}.</p>
                            <div class="details">
                                <h3 style="margin-top: 0;">Request Details</h3>
                                {''.join([f'<div class="detail-row"><strong>{key}:</strong> {value}</div>' for key, value in item_details.items()])}
                            </div>
                            {'<div class="details"><h3 style="margin-top: 0;">Comments</h3><p>' + comments + '</p></div>' if comments else ''}
                            <p style="margin-top: 20px;"><span class="status-badge">Status: {status_text}</span></p>
                        </div>
                    </div>
                </body></html>
                """
                try:
                    send_email(to=requester_email, subject=f'Request {status_text}: {item_details.get("type", "Your Request")}', body=email_body)
                except Exception as email_error:
                    current_app.logger.error(f'Failed to send email: {str(email_error)}')
            
            # If forwarding to another approver
            if forward and forward_email:
                forward_email_body = f"""
                <html><head><style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .header {{ background-color: #3B82F6; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }}
                    .content {{ background-color: #f9fafb; padding: 30px; border: 1px solid #e5e7eb; }}
                    .details {{ background-color: white; padding: 15px; margin: 15px 0; border-radius: 6px; border-left: 4px solid #3B82F6; }}
                </style></head><body>
                    <div class="container">
                        <div class="header"><h1>Approval Request Forwarded</h1></div>
                        <div class="content">
                            <p>Dear Approver,</p>
                            <p>A request has been forwarded to you for approval by <strong>{current_user.name}</strong>.</p>
                            <div class="details">
                                <h3 style="margin-top: 0;">Request Details</h3>
                                {''.join([f'<div><strong>{key}:</strong> {value}</div>' for key, value in item_details.items()])}
                            </div>
                            {'<div class="details"><h3 style="margin-top: 0;">Message</h3><p>' + forward_message + '</p></div>' if forward_message else ''}
                            <p>Please review this request at your earliest convenience.</p>
                        </div>
                    </div>
                </body></html>
                """
                try:
                    send_email(to=forward_email, subject=f'Approval Request Forwarded: {item_details.get("type", "Request")}', body=forward_email_body)
                except Exception as email_error:
                    current_app.logger.error(f'Failed to send forward email: {str(email_error)}')
            
            current_app.logger.info(f'Returning success response for {action} on {item_type} #{item_id}')
            return jsonify({'success': True, 'message': f'Request {action}d successfully'})
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Error processing approval: {str(e)}')
            current_app.logger.error(traceback.format_exc())
            return jsonify({'success': False, 'message': str(e)}), 500

# Roles Management Views
    @app.route('/admin/roles-view', endpoint='admin.roles_view')
    @role_required([Roles.SUPER_HQ])
    def roles_view():
        try:
            # Get all employees
            employees = Employee.query.all()
            
            # Get system roles from the Role model
            system_roles = Role.query.all()
            
            # Get available system roles from constants for role assignment
            available_roles = [
                {'id': 1, 'value': Roles.SUPER_HQ, 'name': 'Super HQ Admin'},
                {'id': 2, 'value': Roles.HQ_FINANCE, 'name': 'HQ Finance Manager'},
                {'id': 3, 'value': Roles.HQ, 'name': 'HQ Manager'},
                {'id': 4, 'value': Roles.HQ_HR, 'name': 'HQ HR Manager'},
                {'id': 5, 'value': Roles.HQ_PROCUREMENT, 'name': 'HQ Procurement Manager'},
                {'id': 6, 'value': Roles.QUARRY_MANAGER, 'name': 'Quarry Manager'},
                {'id': 7, 'value': Roles.PROJECT_MANAGER, 'name': 'Project Manager'},
                {'id': 8, 'value': Roles.HQ_COST_CONTROL, 'name': 'HQ Cost Control Manager'},
                {'id': 9, 'value': Roles.FINANCE_STAFF, 'name': 'Finance Staff'},
                {'id': 10, 'value': Roles.HR_STAFF, 'name': 'HR Staff'},
                {'id': 11, 'value': Roles.PROCUREMENT_STAFF, 'name': 'Procurement Staff'},
                {'id': 12, 'value': Roles.PROCUREMENT_OFFICER, 'name': 'Procurement Officer'},
                {'id': 13, 'value': Roles.QUARRY_STAFF, 'name': 'Quarry Staff'},
                {'id': 14, 'value': Roles.PROJECT_STAFF, 'name': 'Project Staff'},
            ]
        
        # Role display names mapping
            role_names = {
                'super_hq': 'Super HQ Admin',
                'hq_finance': 'HQ Finance Manager',
                'hr': 'HQ Manager',
                'hq_hr': 'HQ HR Manager',
                'hq_procurement': 'HQ Procurement Manager',
                'hq_quarry': 'Quarry Manager',
                'hq_project': 'Project Manager',
                'hq_cost_control': 'HQ Cost Control Manager',
                'finance_staff': 'Finance Staff',
                'hr_staff': 'HR Staff',
                'procurement_staff': 'Procurement Staff',
                'procurement_officer': 'Procurement Officer',
                'quarry_staff': 'Quarry Staff',
                'project_staff': 'Project Staff',
            }
        
        # Create employee data with current role information
            employee_data = []
            for emp in employees:
                current_role_name = role_names.get(emp.role, emp.role or 'No Role Assigned')
            
            # Find role ID if employee has a role
                current_role_id = None
                if emp.role:
                # Try to find matching role from available roles
                    for role in available_roles:
                        if role['value'] == emp.role:
                            current_role_id = role['id']  # Use the proper role ID
                            break
            
                employee_data.append({
                    'id': emp.id,
                    'name': emp.name,
                    'email': getattr(emp, 'email', 'N/A'),
                    'department': getattr(emp, 'department', 'N/A'),
                    'position': getattr(emp, 'position', 'N/A'),
                    'current_role': current_role_name,
                    'current_role_value': emp.role,
                    'current_role_id': current_role_id,  # Add current_role_id for template
                    'status': getattr(emp, 'status', 'Active'),
                    'is_verified': True,
                    'created_at': emp.created_at.strftime('%Y-%m-%d') if emp.created_at else 'N/A'
                })
        
        # Count employees by role and get employee lists
            role_counts = {}
            role_users = {}
        
            for role in available_roles:
                employees_with_role = Employee.query.filter_by(role=role['value']).all()
                count = len(employees_with_role)
                role_counts[role['value']] = count
                role_users[role['value']] = [{'id': emp.id, 'name': emp.name, 'email': emp.email} for emp in employees_with_role]
        
        # Also count employees with no role
            unassigned_employees = Employee.query.filter(
                (Employee.role == None) | 
                (Employee.role == '') | 
                (~Employee.role.in_([role['value'] for role in available_roles]))
            ).all()
        
            role_counts['no_role'] = len(unassigned_employees)
            role_users['no_role'] = [{'id': emp.id, 'name': emp.name, 'email': emp.email} for emp in unassigned_employees]

            return render_template('admin/roles.html', 
                                 available_roles=available_roles,
                                 roles=available_roles,  # Provide roles for template compatibility
                                 employees=employee_data,
                                 users=employee_data,  # Alias for template compatibility
                                 role_counts=role_counts,
                                 role_users=role_users)
        except Exception as e:
            flash(f'Error loading roles: {str(e)}', 'error')
            return render_template('error.html'), 500
        except Exception as e:
            flash(f'Error loading roles: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/assign-role', methods=['POST'], endpoint='admin.assign_role')
    @role_required([Roles.SUPER_HQ])
    def assign_role():
        try:
            current_app.logger.info("=== ASSIGN ROLE DEBUG START ===")
        
            data = request.get_json()
            current_app.logger.info(f"Request data: {data}")
        
            employee_id = data.get('employee_id')
            role_id = data.get('role_id')
        
            current_app.logger.info(f"Employee ID: {employee_id}, Role ID: {role_id}")
        
        # Get the employee
            employee = Employee.query.get(employee_id)
            if not employee:
                current_app.logger.error(f"Employee not found with ID: {employee_id}")
                flash('Employee not found', 'error')
                return redirect(url_for('admin.roles_view'))
        
            current_app.logger.info(f"Found employee: {employee.name}")
        
        # Get available roles for validation
            available_roles = [
                {'id': 1, 'value': Roles.SUPER_HQ, 'name': 'Super HQ Admin'},
                {'id': 2, 'value': Roles.HQ_FINANCE, 'name': 'HQ Finance Manager'},
                {'id': 3, 'value': Roles.HQ, 'name': 'HQ Manager'},
                {'id': 4, 'value': Roles.HQ_HR, 'name': 'HQ HR Manager'},
                {'id': 5, 'value': Roles.HQ_PROCUREMENT, 'name': 'HQ Procurement Manager'},
                {'id': 6, 'value': Roles.QUARRY_MANAGER, 'name': 'Quarry Manager'},
                {'id': 7, 'value': Roles.PROJECT_MANAGER, 'name': 'Project Manager'},
                {'id': 8, 'value': Roles.HQ_COST_CONTROL, 'name': 'HQ Cost Control Manager'},
                {'id': 9, 'value': Roles.FINANCE_STAFF, 'name': 'Finance Staff'},
                {'id': 10, 'value': Roles.HR_STAFF, 'name': 'HR Staff'},
                {'id': 11, 'value': Roles.PROCUREMENT_STAFF, 'name': 'Procurement Staff'},
                {'id': 12, 'value': Roles.PROCUREMENT_OFFICER, 'name': 'Procurement Officer'},
                {'id': 13, 'value': Roles.QUARRY_STAFF, 'name': 'Quarry Staff'},
                {'id': 14, 'value': Roles.PROJECT_STAFF, 'name': 'Project Staff'},
            ]
        
        # Find the role by ID
            selected_role = None
            if role_id:
                for role in available_roles:
                    if role['id'] == role_id:
                        selected_role = role
                        break
            
                if not selected_role:
                    current_app.logger.error(f"Invalid role ID: {role_id}")
                    flash('Invalid role selected', 'error')
                    return redirect(url_for('admin.roles_view'))
        
            current_app.logger.info(f"Selected role: {selected_role}")
        
        # Update employee role
            old_role = employee.role
            old_role_name = 'No Role' if not old_role else old_role
        
            if selected_role:
                employee.role = selected_role['value']
                new_role_name = selected_role['name']
                message = f"Role assigned successfully! {employee.name} is now assigned as {new_role_name}."
            else:
                employee.role = None
                new_role_name = 'No Role'
                message = f"Role removed successfully! {employee.name} no longer has an assigned role."
        
            current_app.logger.info(f"About to commit changes: {employee.name} -> {new_role_name}")
            db.session.commit()
            current_app.logger.info(f"Changes committed successfully")
        
        # Log the role change
            current_app.logger.info(f"Role assignment: {employee.name} (ID: {employee.id}) - {old_role_name}  {new_role_name}")
            current_app.logger.info("=== ASSIGN ROLE DEBUG END ===")
        
            flash(message, 'success')
            return redirect(url_for('admin.roles_view'))
    
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error in assign_role: {str(e)}")
            current_app.logger.error(f"Exception type: {type(e)}")
            current_app.logger.error(f"Traceback: {traceback.format_exc()}")
            flash(f'Error assigning role: {str(e)}', 'error')
            return redirect(url_for('admin.roles_view'))

    @app.route('/admin/assign-employee-role', methods=['POST'], endpoint='admin.assign_employee_role')
    @role_required([Roles.SUPER_HQ])  
    def assign_employee_role():
    # Legacy endpoint - redirect to new assign_role endpoint
        return assign_role()

    @app.route('/admin/remove-employee-role', methods=['POST'], endpoint='admin.remove_employee_role')
    @role_required([Roles.SUPER_HQ])
    def remove_employee_role():
        try:
            data = request.get_json()
            employee_id = data.get('employee_id')
        
        # Get the employee
            employee = Employee.query.get(employee_id)
            if not employee:
                flash('Employee not found', 'error')
                return redirect(url_for('admin.roles_view'))
        
        # Remove employee role
            old_role = employee.role
            employee.role = None
            db.session.commit()
        
        # Send notification email if employee has email
            try:
                if employee.email:
                    subject = "Role Removal Notification"
                    body = f"""Dear {employee.name},

    Your role assignment has been removed from the Construction Management System.

    Previous Role: {old_role or 'No Role'}
    Current Status: No Role Assigned

    Please contact your administrator if you believe this is an error.

    Best regards,
    Construction Management Team"""
                
                    send_email(employee.email, subject, body)
            except Exception as email_error:
                current_app.logger.warning(f'Failed to send role removal email to {employee.email}: {str(email_error)}')
        
            flash(f'Role removed successfully for {employee.name}', 'success')
            return redirect(url_for('admin.roles_view'))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Error removing role: {str(e)}')
            flash(f'Error removing role: {str(e)}', 'error')
            return redirect(url_for('admin.roles_view'))

# Reporting Lines Management Views
    @app.route('/admin/reporting-lines-view', endpoint='admin.reporting_lines_view')
    @role_required([Roles.SUPER_HQ])
    def reporting_lines_view():
        try:
            lines = ReportingLine.query.all()
            employees = Employee.query.all()
        # Create a list with manager and staff names
            reporting_data = []
            for line in lines:
                manager = Employee.query.get(line.manager_id)
                staff = Employee.query.get(line.staff_id)
                reporting_data.append({
                    'id': line.id,
                    'manager_id': line.manager_id,
                    'staff_id': line.staff_id,
                    'manager_name': manager.name if manager else 'Unknown',
                    'staff_name': staff.name if staff else 'Unknown'
                })
            return render_template('admin/reporting_lines.html', 
                                 reporting_data=reporting_data, 
                                 employees=employees)
        except Exception as e:
            flash(f'Error loading reporting lines: {str(e)}', 'error')
            return render_template('error.html'), 500

# Approval Hierarchy Management Views
    @app.route('/admin/approval-hierarchy-view', endpoint='admin.approval_hierarchy_view')
    @role_required([Roles.SUPER_HQ])
    def approval_hierarchy_view():
        try:
            hierarchies = ApprovalHierarchy.query.all()
            roles = Role.query.all()
        # Create hierarchy data with role names
            hierarchy_data = []
            for h in hierarchies:
                role = Role.query.get(h.role_id)
                hierarchy_data.append({
                    'id': h.id,
                    'process': h.process,
                    'level': h.level,
                    'role_id': h.role_id,
                    'role_name': role.name if role else 'Unknown'
                })
            return render_template('admin/approval_hierarchy.html', 
                                 hierarchy_data=hierarchy_data, 
                                 roles=roles)
        except Exception as e:
            flash(f'Error loading approval hierarchy: {str(e)}', 'error')
            return render_template('error.html'), 500

# Permissions Management Views
    @app.route('/admin/permissions-view', endpoint='admin.permissions_view')
    @role_required([Roles.SUPER_HQ])
    def permissions_view():
        try:
            permissions = Permission.query.all()
            roles = Role.query.all()
        # Create permissions data with role names
            permission_data = []
            for p in permissions:
                role = Role.query.get(p.role_id)
                permission_data.append({
                    'id': p.id,
                    'role_id': p.role_id,
                    'resource': p.resource,
                    'action': p.action,
                    'role_name': role.name if role else 'Unknown'
                })
            return render_template('admin/permissions.html', 
                                 permission_data=permission_data, 
                                 roles=roles)
        except Exception as e:
            flash(f'Error loading permissions: {str(e)}', 'error')
            return render_template('error.html'), 500

# Oversight Reports View
    @app.route('/admin/oversight-reports-view', endpoint='admin.oversight_reports_view')
    @role_required([Roles.SUPER_HQ])
    def oversight_reports_view():
        try:
            # Get pending approvals from all modules
            pending_orders = PurchaseOrder.query.filter_by(status='Pending').all()
            pending_payrolls = PayrollApproval.query.filter_by(status='Pending').all()
            pending_expenses = Expense.query.filter_by(status='Pending').all()
            pending_procurements = ProcurementRequest.query.filter_by(status='Pending').all()
            
            # Budget doesn't have status field, so we'll get recent budgets instead
            recent_budgets = Budget.query.order_by(Budget.created_at.desc()).limit(10).all()
            pending_budgets_count = len([b for b in recent_budgets if b.usage_percentage < 100])
            
            # Count pending items
            pending_orders_count = len(pending_orders)
            pending_payrolls_count = len(pending_payrolls)
            pending_expenses_count = len(pending_expenses)
            pending_procurements_count = len(pending_procurements)
            
            # Total pending approvals
            total_pending = (pending_orders_count + pending_payrolls_count + 
                           pending_expenses_count + pending_budgets_count + 
                           pending_procurements_count)
            
            # Calculate total value of pending orders
            pending_orders_value = db.session.query(
                db.func.sum(PurchaseOrder.total_amount)
            ).filter_by(status='Pending').scalar() or 0
            
            # Get recent pending submissions with actual data
            recent_submissions = []
            
            # Add recent pending purchase orders with full details
            for order in pending_orders[:5]:
                recent_submissions.append({
                    'id': order.id,
                    'type': 'purchase_order',
                    'title': f"Purchase Order: {order.order_number}",
                    'department': 'Procurement',
                    'date': order.created_at.strftime('%Y-%m-%d') if order.created_at else 'N/A',
                    'status': 'Pending',
                    'details': {
                        'order_number': order.order_number,
                        'supplier': order.supplier_name,
                        'amount': float(order.total_amount) if order.total_amount else 0,
                        'description': order.description or 'No description',
                        'requested_by': order.created_by if hasattr(order, 'created_by') else 'Unknown'
                    }
                })
            
            # Add recent pending payrolls with full details
            for payroll in pending_payrolls[:3]:
                recent_submissions.append({
                    'id': payroll.id,
                    'type': 'payroll',
                    'title': f"Payroll: {payroll.month}/{payroll.year}",
                    'department': 'HR',
                    'date': payroll.created_at.strftime('%Y-%m-%d') if payroll.created_at else 'N/A',
                    'status': 'Pending',
                    'details': {
                        'month': payroll.month,
                        'year': payroll.year,
                        'total_amount': float(payroll.total_amount) if hasattr(payroll, 'total_amount') else 0,
                        'employee_count': payroll.employee_count if hasattr(payroll, 'employee_count') else 0,
                        'requested_by': payroll.created_by if hasattr(payroll, 'created_by') else 'HR Department'
                    }
                })
            
            # Add recent pending expenses with full details
            for expense in pending_expenses[:3]:
                employee_name = expense.employee.full_name if expense.employee else 'Unknown'
                recent_submissions.append({
                    'id': expense.id,
                    'type': 'expense',
                    'title': f"Expense: {expense.description[:50]}",
                    'department': 'Finance',
                    'date': expense.date.strftime('%Y-%m-%d') if expense.date else 'N/A',
                    'status': 'Pending',
                    'details': {
                        'description': expense.description,
                        'amount': float(expense.amount) if expense.amount else 0,
                        'category': expense.category if hasattr(expense, 'category') else 'General',
                        'requested_by': employee_name,
                        'requester_email': expense.employee.email if expense.employee and hasattr(expense.employee, 'email') else None
                    }
                })
            
            # Add recent pending procurements with full details
            for procurement in pending_procurements[:3]:
                recent_submissions.append({
                    'id': procurement.id,
                    'type': 'procurement',
                    'title': f"Procurement: {procurement.item_name}",
                    'department': 'Procurement',
                    'date': procurement.created_at.strftime('%Y-%m-%d') if procurement.created_at else 'N/A',
                    'status': 'Pending',
                    'details': {
                        'item_name': procurement.item_name,
                        'quantity': float(procurement.qty) if procurement.qty else 0,
                        'unit': procurement.unit,
                        'price': float(procurement.price) if procurement.price else 0,
                        'total_value': float(procurement.price * procurement.qty) if procurement.price and procurement.qty else 0,
                        'requested_by': procurement.current_approver or 'Procurement Team'
                    }
                })
            
            # Get recent approval activities with real data
            recent_activities = []
            
            # Add high-priority purchase orders
            for order in pending_orders[:3]:
                priority = 'High' if order.total_amount and order.total_amount > 500000 else 'Medium'
                recent_activities.append({
                    'id': order.id,
                    'type': 'purchase_order',
                    'description': f'Purchase order pending: {order.order_number}',
                    'department': f'Procurement - {order.supplier_name}' if order.supplier_name else 'Procurement',
                    'timestamp': order.created_at.strftime('%Y-%m-%d %H:%M') if order.created_at else 'N/A',
                    'priority': priority,
                    'details': {
                        'order_number': order.order_number,
                        'supplier': order.supplier_name,
                        'amount': float(order.total_amount) if order.total_amount else 0,
                        'description': order.description or 'No description'
                    }
                })
            
            # Add high-priority payroll requests
            for payroll in pending_payrolls[:2]:
                recent_activities.append({
                    'id': payroll.id,
                    'type': 'payroll',
                    'description': f'Payroll approval needed: {payroll.month}/{payroll.year}',
                    'department': 'HR - Payroll',
                    'timestamp': payroll.created_at.strftime('%Y-%m-%d %H:%M') if payroll.created_at else 'N/A',
                    'priority': 'High',
                    'details': {
                        'month': payroll.month,
                        'year': payroll.year,
                        'total_amount': float(payroll.total_amount) if hasattr(payroll, 'total_amount') else 0
                    }
                })
            
            # Add high-priority expense claims
            for expense in pending_expenses[:2]:
                employee_name = expense.employee.full_name if expense.employee else 'Unknown'
                priority = 'High' if expense.amount and expense.amount > 100000 else 'Medium'
                recent_activities.append({
                    'id': expense.id,
                    'type': 'expense',
                    'description': f'Expense claim: {expense.description[:40]}...',
                    'department': f'Finance - {employee_name}',
                    'timestamp': expense.date.strftime('%Y-%m-%d') if expense.date else 'N/A',
                    'priority': priority,
                    'details': {
                        'description': expense.description,
                        'amount': float(expense.amount) if expense.amount else 0,
                        'requested_by': employee_name,
                        'requester_email': expense.employee.email if expense.employee and hasattr(expense.employee, 'email') else None
                    }
                })
            
            # Generate comprehensive approval report
            report_data = {
                # Approval metrics
                'pending_reports': total_pending,
                'pending_orders': pending_orders_count,
                'pending_payrolls': pending_payrolls_count,
                'pending_expenses': pending_expenses_count,
                'pending_budgets': pending_budgets_count,
                'pending_procurements': pending_procurements_count,
                
                # Financial metrics
                'pending_orders_value': pending_orders_value,
                
                # Data lists with full details
                'recent_submissions': recent_submissions,
                'recent_activities': recent_activities
            }
            
            return render_template('admin/oversight_reports.html', report=report_data)
        except Exception as e:
            current_app.logger.error(f'Error in oversight_reports_view: {str(e)}')
            flash(f'Error loading approval management: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/process-approval', methods=['POST'], endpoint='admin.process_approval')
    @role_required([Roles.SUPER_HQ])
    def process_approval():
        try:
            data = request.get_json()
            action = data.get('action')  # 'approve' or 'reject'
            item_type = data.get('type')  # 'purchase_order', 'payroll', 'expense', 'procurement'
            item_id = data.get('id')  # The actual database ID
            comments = data.get('comments', '')
            forward = data.get('forward', False)
            forward_email = data.get('forwardEmail', '')
            forward_message = data.get('forwardMessage', '')
            
            current_app.logger.info(f'Processing approval: {action} for {item_type} #{item_id}')
            
            # Variables to store item details and requester email
            item_details = {}
            requester_email = None
            requester_name = 'User'
            
            # Process based on item type
            if item_type == 'purchase_order':
                item = PurchaseOrder.query.get(item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Purchase order not found'}), 404
                
                # Update status
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                if hasattr(item, 'approved_by'):
                    item.approved_by = current_user.id
                if hasattr(item, 'approval_date'):
                    item.approval_date = datetime.now()
                
                # Store details for email
                item_details = {
                    'type': 'Purchase Order',
                    'order_number': item.order_number,
                    'supplier': item.supplier_name,
                    'amount': f"{item.total_amount:,.2f}" if item.total_amount else 'N/A',
                    'description': item.description or 'No description'
                }
                
                # Get requester email (you may need to adjust based on your model)
                if hasattr(item, 'created_by_user') and item.created_by_user:
                    requester_email = item.created_by_user.email
                    requester_name = item.created_by_user.username
                
            elif item_type == 'payroll':
                item = PayrollApproval.query.get(item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Payroll not found'}), 404
                
                # Update status
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                if hasattr(item, 'approved_by'):
                    item.approved_by = current_user.id
                if hasattr(item, 'approval_date'):
                    item.approval_date = datetime.now()
                
                # Store details for email
                item_details = {
                    'type': 'Payroll Request',
                    'period': f"{item.month}/{item.year}",
                    'amount': f"{item.total_amount:,.2f}" if hasattr(item, 'total_amount') and item.total_amount else 'N/A',
                    'employees': item.employee_count if hasattr(item, 'employee_count') else 'N/A'
                }
                
                # Get requester from HR department
                if hasattr(item, 'created_by_user') and item.created_by_user:
                    requester_email = item.created_by_user.email
                    requester_name = item.created_by_user.username
                
            elif item_type == 'expense':
                item = Expense.query.get(item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Expense not found'}), 404
                
                # Update status
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                
                # Store details for email
                item_details = {
                    'type': 'Expense Claim',
                    'description': item.description,
                    'amount': f"{item.amount:,.2f}" if item.amount else 'N/A',
                    'category': item.category if hasattr(item, 'category') else 'General',
                    'date': item.expense_date.strftime('%Y-%m-%d') if item.expense_date else 'N/A'
                }
                
                # Get requester email from employee
                if item.employee and hasattr(item.employee, 'email'):
                    requester_email = item.employee.email
                    requester_name = item.employee.full_name
                
            elif item_type == 'procurement':
                item = ProcurementRequest.query.get(item_id)
                if not item:
                    return jsonify({'success': False, 'message': 'Procurement request not found'}), 404
                
                # Update status
                item.status = 'Approved' if action == 'approve' else 'Rejected'
                
                # Store details for email
                total_value = (item.price * item.qty) if item.price and item.qty else 0
                item_details = {
                    'type': 'Procurement Request',
                    'item': item.item_name,
                    'quantity': f"{item.qty} {item.unit}" if item.qty and item.unit else 'N/A',
                    'price': f"{item.price:,.2f}" if item.price else 'N/A',
                    'total_value': f"{total_value:,.2f}"
                }
                
                # Get requester email
                if hasattr(item, 'created_by_user') and item.created_by_user:
                    requester_email = item.created_by_user.email
                    requester_name = item.created_by_user.username
            
            else:
                return jsonify({'success': False, 'message': 'Invalid item type'}), 400
            
            # Commit changes to database
            db.session.commit()
            
            # Send email to requester
            if requester_email:
                status_text = 'Approved' if action == 'approve' else 'Rejected'
                status_color = '#10B981' if action == 'approve' else '#EF4444'
                
                email_body = f"""
                <html>
                <head>
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                        .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                        .header {{ background-color: {status_color}; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }}
                        .content {{ background-color: #f9fafb; padding: 30px; border: 1px solid #e5e7eb; }}
                        .details {{ background-color: white; padding: 15px; margin: 15px 0; border-radius: 6px; border-left: 4px solid {status_color}; }}
                        .detail-row {{ padding: 8px 0; border-bottom: 1px solid #e5e7eb; }}
                        .detail-label {{ font-weight: bold; color: #6b7280; }}
                        .footer {{ background-color: #1f2937; color: white; padding: 15px; text-align: center; border-radius: 0 0 8px 8px; font-size: 12px; }}
                        .status-badge {{ display: inline-block; padding: 8px 16px; background-color: {status_color}; color: white; border-radius: 20px; font-weight: bold; }}
                    </style>
                </head>
                <body>
                    <div class="container">
                        <div class="header">
                            <h1>Request {status_text}</h1>
                        </div>
                        <div class="content">
                            <p>Dear {requester_name},</p>
                            <p>Your request has been <strong>{status_text.lower()}</strong> by {current_user.name}.</p>
                            
                            <div class="details">
                                <h3 style="margin-top: 0;">Request Details</h3>
                                {''.join([f'<div class="detail-row"><span class="detail-label">{key}:</span> {value}</div>' for key, value in item_details.items()])}
                            </div>
                            
                            {'<div class="details"><h3 style="margin-top: 0;">Comments from Approver</h3><p>' + comments + '</p></div>' if comments else ''}
                            
                            <p style="margin-top: 20px;">
                                <span class="status-badge">Status: {status_text}</span>
                            </p>
                            
                            <p style="margin-top: 20px; font-size: 14px; color: #6b7280;">
                                If you have any questions about this decision, please contact the approver or your department head.
                            </p>
                        </div>
                        <div class="footer">
                            <p>Construction Management System | Automated Approval Notification</p>
                            <p> 2025 All Rights Reserved</p>
                        </div>
                    </div>
                </body>
                </html>
                """
                
                try:
                    send_email(
                        to=requester_email,
                        subject=f'Request {status_text}: {item_details.get("type", "Your Request")}',
                        body=email_body
                    )
                    current_app.logger.info(f'Email sent to {requester_email}')
                except Exception as email_error:
                    current_app.logger.error(f'Failed to send email: {str(email_error)}')
            
            # If forwarding to another approver
            if forward and forward_email:
                forward_email_body = f"""
                <html>
                <head>
                    <style>
                        body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                        .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                        .header {{ background-color: #3B82F6; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }}
                        .content {{ background-color: #f9fafb; padding: 30px; border: 1px solid #e5e7eb; }}
                        .details {{ background-color: white; padding: 15px; margin: 15px 0; border-radius: 6px; border-left: 4px solid #3B82F6; }}
                        .detail-row {{ padding: 8px 0; border-bottom: 1px solid #e5e7eb; }}
                        .detail-label {{ font-weight: bold; color: #6b7280; }}
                        .footer {{ background-color: #1f2937; color: white; padding: 15px; text-align: center; border-radius: 0 0 8px 8px; font-size: 12px; }}
                        .action-button {{ display: inline-block; padding: 12px 24px; background-color: #3B82F6; color: white; text-decoration: none; border-radius: 6px; margin-top: 15px; }}
                    </style>
                </head>
                <body>
                    <div class="container">
                        <div class="header">
                            <h1>Approval Request Forwarded</h1>
                        </div>
                        <div class="content">
                            <p>Dear Approver,</p>
                            <p>A request has been forwarded to you for approval by <strong>{current_user.name}</strong>.</p>
                            
                            <div class="details">
                                <h3 style="margin-top: 0;">Request Details</h3>
                                {''.join([f'<div class="detail-row"><span class="detail-label">{key}:</span> {value}</div>' for key, value in item_details.items()])}
                            </div>
                            
                            {'<div class="details"><h3 style="margin-top: 0;">Message from Forwarder</h3><p>' + forward_message + '</p></div>' if forward_message else ''}
                            
                            <p style="margin-top: 20px;">
                                Please review this request at your earliest convenience and take appropriate action.
                            </p>
                            
                            <p style="font-size: 14px; color: #6b7280; margin-top: 20px;">
                                Login to the system to review and approve/reject this request.
                            </p>
                        </div>
                        <div class="footer">
                            <p>Construction Management System | Automated Approval Notification</p>
                            <p> 2025 All Rights Reserved</p>
                        </div>
                    </div>
                </body>
                </html>
                """
                
                try:
                    send_email(
                        to=forward_email,
                        subject=f'Approval Request Forwarded: {item_details.get("type", "Request")}',
                        body=forward_email_body
                    )
                    current_app.logger.info(f'Forward email sent to {forward_email}')
                except Exception as email_error:
                    current_app.logger.error(f'Failed to send forward email: {str(email_error)}')
            
            return jsonify({
                'success': True,
                'message': f'Request {action}d successfully',
                'status': 'Approved' if action == 'approve' else 'Rejected'
            })
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f'Error processing approval: {str(e)}')
            return jsonify({'success': False, 'message': str(e)}), 500

# POST/GET /admin/roles
    @app.route('/admin/roles', methods=['POST', 'GET'], endpoint='admin.manage_roles')
    def manage_roles():
        if request.method == 'POST':
            data = request.get_json() if request.is_json else request.form
            role_name = data.get('name')
            if role_name:
                role = Role(name=role_name)
                db.session.add(role)
                db.session.commit()
                flash(f'Role "{role_name}" created successfully', 'success')
            else:
                flash('Role name is required', 'error')
            return redirect(url_for('admin.roles_view'))
    
    # For GET requests, redirect to the roles view page
        return redirect(url_for('admin.roles_view'))

# POST/GET /admin/reporting-lines
    @app.route('/admin/reporting-lines', methods=['POST', 'GET'], endpoint='admin.manage_reporting_lines')
    def manage_reporting_lines():
        if request.method == 'POST':
            try:
                data = request.get_json()
                manager_id = data.get('manager_id')
                staff_id = data.get('staff_id')
            
            # Validation
                if not manager_id or not staff_id:
                    flash('Both manager and staff must be selected', 'error')
                    return redirect(url_for('admin.reporting_lines_view'))
                
                if manager_id == staff_id:
                    flash('An employee cannot report to themselves', 'error')
                    return redirect(url_for('admin.reporting_lines_view'))
                
            # Check if reporting line already exists
                existing = ReportingLine.query.filter_by(manager_id=manager_id, staff_id=staff_id).first()
                if existing:
                    flash('This reporting relationship already exists', 'error')
                    return redirect(url_for('admin.reporting_lines_view'))
            
                rl = ReportingLine(manager_id=manager_id, staff_id=staff_id)
                db.session.add(rl)
                db.session.commit()
            
            # Notify manager and staff
                manager = Employee.query.get(manager_id)
                staff = Employee.query.get(staff_id)
                if manager and hasattr(manager, 'email') and manager.email:
                    subject = "Reporting Line Assigned"
                    body = f"Dear {manager.name},\nYou are now the manager for {staff.name if staff else 'staff member'}."
                    send_email(manager.email, subject, body)
                if staff and hasattr(staff, 'email') and staff.email:
                    subject = "Reporting Line Assigned"
                    body = f"Dear {staff.name},\nYou now report to {manager.name if manager else 'your manager'}."
                    send_email(staff.email, subject, body)
                
                current_app.logger.info(f"Reporting line created: {staff.name if staff else staff_id} reports to {manager.name if manager else manager_id}")
                flash('Reporting line created successfully', 'success')
                return redirect(url_for('admin.reporting_lines_view'))
            
            except Exception as e:
                db.session.rollback()
                current_app.logger.error(f"Error creating reporting line: {str(e)}")
                flash(f'Error creating reporting line: {str(e)}', 'error')
                return redirect(url_for('admin.reporting_lines_view'))
            
    # For GET requests, redirect to the reporting lines view page
        return redirect(url_for('admin.reporting_lines_view'))

# DELETE /admin/reporting-lines/<id>
    @app.route('/admin/reporting-lines/<int:line_id>', methods=['DELETE'], endpoint='admin.delete_reporting_line')
    def delete_reporting_line(line_id):
        try:
            reporting_line = ReportingLine.query.get_or_404(line_id)
        
        # Get employee details for logging before deletion
            manager = Employee.query.get(reporting_line.manager_id)
            staff = Employee.query.get(reporting_line.staff_id)
        
            db.session.delete(reporting_line)
            db.session.commit()
        
            current_app.logger.info(f"Reporting line deleted: {staff.name if staff else reporting_line.staff_id} no longer reports to {manager.name if manager else reporting_line.manager_id}")
        
            flash('Reporting line removed successfully', 'success')
            return redirect(url_for('admin.manage_reporting_lines'))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting reporting line {line_id}: {str(e)}")
            flash(f'Error removing reporting line: {str(e)}', 'error')
            return redirect(url_for('admin.manage_reporting_lines'))

# POST/GET /admin/approval-hierarchy
    @app.route('/admin/approval-hierarchy', methods=['POST', 'GET'], endpoint='admin.manage_approval_hierarchy')
    def manage_approval_hierarchy():
        if request.method == 'POST':
            data = request.get_json()
            ah = ApprovalHierarchy(process=data.get('process'), level=data.get('level'), role_id=data.get('role_id'))
            db.session.add(ah)
            db.session.commit()
        # Notify the user(s) in this role
            role = Role.query.get(data.get('role_id'))
            if role:
            # Find all employees with this role
                employees = Employee.query.filter_by(role=role.name).all() if hasattr(Employee, 'role') else []
                for emp in employees:
                    if hasattr(emp, 'email') and emp.email:
                        subject = f"Approval Level Assigned: {ah.process}"
                        body = f"Dear {emp.name},\nYou have been assigned as an approver for {ah.process} at level {ah.level}."
                        send_email(emp.email, subject, body)
            return jsonify({'status': 'success', 'id': ah.id})
        hierarchy = ApprovalHierarchy.query.all()
        return jsonify([{'id': h.id, 'process': h.process, 'level': h.level, 'role_id': h.role_id} for h in hierarchy])

# POST/GET /admin/permissions
    @app.route('/admin/permissions', methods=['POST', 'GET'], endpoint='admin.manage_permissions')
    def manage_permissions():
        if request.method == 'POST':
            data = request.get_json()
            perm = Permission(role_id=data.get('role_id'), resource=data.get('resource'), action=data.get('action'))
            db.session.add(perm)
            db.session.commit()
        # Notify users in this role
            role = Role.query.get(data.get('role_id'))
            if role:
                employees = Employee.query.filter_by(role=role.name).all() if hasattr(Employee, 'role') else []
                for emp in employees:
                    if hasattr(emp, 'email') and emp.email:
                        subject = f"Permission Assigned: {perm.resource}"
                        body = f"Dear {emp.name},\nYou have been granted {perm.action} permission for {perm.resource}."
                        send_email(emp.email, subject, body)
            return jsonify({'status': 'success', 'id': perm.id})
        perms = Permission.query.all()
        return jsonify([{'id': p.id, 'role_id': p.role_id, 'resource': p.resource, 'action': p.action} for p in perms])

# GET /admin/oversight-reports
    @app.route('/admin/oversight-reports', methods=['GET'], endpoint='admin.oversight_reports')
    def oversight_reports():
    # Example: count of roles, reporting lines, approval levels, permissions
        report = {
            'role_count': Role.query.count(),
            'reporting_line_count': ReportingLine.query.count(),
            'approval_hierarchy_count': ApprovalHierarchy.query.count(),
            'permission_count': Permission.query.count()
        }
        return jsonify({'status': 'success', 'report': report})

# ==================== PROJECT MANAGEMENT ENDPOINTS ====================

    @app.route('/admin/projects', endpoint='admin.projects')
    @role_required([Roles.SUPER_HQ])
    def projects():
        """Display all projects with comprehensive project management dashboard"""
        try:
            projects = Project.query.order_by(Project.created_at.desc()).all()
            
            # Calculate project statistics
            total_projects = len(projects)
            active_projects = len([p for p in projects if p.status in ['Active', 'In Progress']])
            completed_projects = len([p for p in projects if p.status == 'Completed'])
            total_budget = sum([p.budget or 0 for p in projects])
            
            project_stats = {
                'total_projects': total_projects,
                'active_projects': active_projects,
                'completed_projects': completed_projects,
                'total_budget': total_budget
            }
            
            # Pass current date for template calculations
            current_date_obj = date.today()
            
            return render_template('admin/projects.html', 
                                 projects=projects, 
                                 project_stats=project_stats,
                                 current_date_obj=current_date_obj)
        except Exception as e:
            flash(f'Error loading projects: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-project', methods=['GET', 'POST'], endpoint='admin.add_project')
    @role_required([Roles.SUPER_HQ])
    def add_project():
        """Add new construction project"""
        form_data = {}  # Initialize empty form data
    
        if request.method == 'POST':
            try:
                data = request.form
                form_data = data.to_dict()  # Store form data for repopulation
            
            # Validate required fields
                if not data.get('name'):
                    flash('Project name is required', 'error')
                    employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                    return render_template('admin/create_project.html', employees=employees, form_data=form_data)
            
            # Handle date parsing with validation
                start_date = None
                end_date = None
            
                if data.get('start_date'):
                    try:
                        start_date = datetime.strptime(data.get('start_date'), '%Y-%m-%d').date()
                    except ValueError:
                        flash('Invalid start date format', 'error')
                        employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                        return render_template('admin/create_project.html', employees=employees, form_data=form_data)
            
                if data.get('end_date'):
                    try:
                        end_date = datetime.strptime(data.get('end_date'), '%Y-%m-%d').date()
                    except ValueError:
                        flash('Invalid end date format', 'error')
                        employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                        return render_template('admin/create_project.html', employees=employees, form_data=form_data)
            
            # Validate date logic
                if start_date and end_date and end_date < start_date:
                    flash('End date cannot be before start date', 'error')
                    employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                    return render_template('admin/create_project.html', employees=employees, form_data=form_data)
            
            # Handle budget parsing
                budget = 0.0
                if data.get('budget'):
                    try:
                        budget = float(data.get('budget'))
                        if budget < 0:
                            flash('Budget cannot be negative', 'error')
                            employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                            return render_template('admin/create_project.html', employees=employees, form_data=form_data)
                    except ValueError:
                        flash('Invalid budget amount', 'error')
                        employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                        return render_template('admin/create_project.html', employees=employees, form_data=form_data)
            
            # Handle contingency budget
                contingency_budget = 0.0
                if data.get('contingency_budget'):
                    try:
                        contingency_budget = float(data.get('contingency_budget'))
                    except ValueError:
                        contingency_budget = 0.0
            
            # Create new project with enhanced fields
                project = Project(
                    name=data.get('name').strip(),
                    description=data.get('description', '').strip(),
                    start_date=start_date,
                    end_date=end_date,
                    status=data.get('status', 'Planning'),
                    project_manager=data.get('project_manager', '').strip(),
                    budget=budget,
                    created_at=datetime.now(timezone.utc),
                    updated_at=datetime.now(timezone.utc),
                # Enhanced fields
                    project_type=data.get('project_type', '').strip(),
                    priority=data.get('priority', 'Medium'),
                    client_name=data.get('client_name', '').strip(),
                    site_location=data.get('site_location', '').strip(),
                    funding_source=data.get('funding_source', '').strip(),
                    risk_level=data.get('risk_level', 'Low'),
                    safety_requirements=data.get('safety_requirements', 'Standard'),
                    regulatory_requirements=data.get('regulatory_requirements', '').strip()
                )
            
                db.session.add(project)
                db.session.commit()
            
            # Create initial budget entries
                if budget > 0:
                # Main project budget
                    budget_entry = Budget(
                        project_id=project.id,
                        category='Total Project Budget',
                        allocated_amount=budget,
                        spent_amount=0.0,
                        created_at=datetime.now(timezone.utc)
                    )
                    db.session.add(budget_entry)
                
                # Contingency budget if specified
                    if contingency_budget > 0:
                        contingency_entry = Budget(
                            project_id=project.id,
                            category='Contingency Fund',
                            allocated_amount=contingency_budget,
                            spent_amount=0.0,
                            created_at=datetime.now(timezone.utc)
                        )
                        db.session.add(contingency_entry)
                
                    db.session.commit()
            
                flash(f'Project "{project.name}" created successfully!', 'success')
                return redirect(url_for('admin.projects'))
            
            except Exception as e:
                db.session.rollback()
                current_app.logger.error(f'Error creating project: {str(e)}')
                flash(f'Error creating project: {str(e)}', 'error')
                employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
                return render_template('admin/create_project.html', employees=employees, form_data=form_data)
    
    # GET request - show form
        try:
            employees = Employee.query.filter_by(status='Active').order_by(Employee.name).all()
            return render_template('admin/create_project.html', employees=employees, form_data=form_data)
        except Exception as e:
            current_app.logger.error(f'Error loading project form: {str(e)}')
            flash(f'Error loading form: {str(e)}', 'error')
            return redirect(url_for('admin.projects'))


    @app.route('/admin/milestones/<int:project_id>', endpoint='admin.milestones')
    @role_required([Roles.SUPER_HQ])
    def milestones(project_id):
        """Display milestones for a specific project"""
        try:
            project = Project.query.get_or_404(project_id)
            milestones = Milestone.query.filter_by(project_id=project_id).order_by(Milestone.due_date).all()
        
        # Calculate milestone statistics
            total_milestones = len(milestones)
            completed_milestones = len([m for m in milestones if m.status == 'Completed'])
            overdue_milestones = len([m for m in milestones if m.due_date < datetime.now().date() and m.status != 'Completed'])
        
            milestone_stats = {
                'total_milestones': total_milestones,
                'completed_milestones': completed_milestones,
                'overdue_milestones': overdue_milestones,
                'completion_rate': (completed_milestones / total_milestones * 100) if total_milestones > 0 else 0
            }
        
        # Pass current date for template calculations
            current_date_obj = date.today()
        
            return render_template('admin/projects/milestones.html', 
                                 project=project, 
                                 milestones=milestones, 
                                 milestone_stats=milestone_stats,
                                 current_date_obj=current_date_obj)
        except Exception as e:
            flash(f'Error loading milestones: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-milestone/<int:project_id>', methods=['GET', 'POST'], endpoint='admin.add_milestone')
    @role_required([Roles.SUPER_HQ])
    def add_milestone(project_id):
        """Add milestone to specific project"""
        project = Project.query.get_or_404(project_id)
    
        if request.method == 'POST':
            try:
                data = request.form
            
                milestone = Milestone(
                    project_id=project_id,
                    title=data.get('title'),
                    due_date=datetime.strptime(data.get('due_date'), '%Y-%m-%d').date(),
                    status=data.get('status', 'Pending')
                )
            
                db.session.add(milestone)
                db.session.commit()
            
                flash(f'Milestone "{milestone.title}" added successfully!', 'success')
                return redirect(url_for('admin.milestones', project_id=project_id))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating milestone: {str(e)}', 'error')
    
        return render_template('admin/add_milestone.html', project=project)

    @app.route('/admin/all-milestones', endpoint='admin.all_milestones')
    @role_required([Roles.SUPER_HQ])
    def all_milestones():
        """Display all milestones across all projects"""
        try:
        # Get all milestones with their associated projects
            milestones = Milestone.query.join(Project).order_by(Milestone.due_date.asc()).all()
        
        # Calculate comprehensive milestone statistics
            total_milestones = len(milestones)
            completed_milestones = len([m for m in milestones if m.status == 'Completed'])
            pending_milestones = len([m for m in milestones if m.status == 'Pending' or m.status is None])
            overdue_milestones = len([m for m in milestones if m.due_date and m.due_date < datetime.now().date() and m.status != 'Completed'])
        
        # Calculate milestones by project
            project_milestones = {}
            for milestone in milestones:
                project_name = milestone.project.name if milestone.project else 'Unknown Project'
                if project_name not in project_milestones:
                    project_milestones[project_name] = {
                        'total': 0,
                        'completed': 0,
                        'pending': 0,
                        'overdue': 0,
                        'project_id': milestone.project.id if milestone.project else None
                    }
            
                project_milestones[project_name]['total'] += 1
            
                if milestone.status == 'Completed':
                    project_milestones[project_name]['completed'] += 1
                elif milestone.due_date and milestone.due_date < datetime.now().date() and milestone.status != 'Completed':
                    project_milestones[project_name]['overdue'] += 1
                else:
                    project_milestones[project_name]['pending'] += 1
        
        # Calculate upcoming milestones (next 30 days)
            next_month = datetime.now().date() + timedelta(days=30)
            upcoming_milestones = [m for m in milestones if m.due_date and m.due_date <= next_month and m.status != 'Completed']
        
            milestone_stats = {
                'total_milestones': total_milestones,
                'completed_milestones': completed_milestones,
                'pending_milestones': pending_milestones,
                'overdue_milestones': overdue_milestones,
                'completion_rate': (completed_milestones / total_milestones * 100) if total_milestones > 0 else 0,
                'upcoming_count': len(upcoming_milestones),
                'project_count': len(project_milestones)
            }
        
            return render_template('admin/all_milestones.html', 
                                 milestones=milestones,
                                 milestone_stats=milestone_stats,
                                 project_milestones=project_milestones,
                                 upcoming_milestones=upcoming_milestones,
                                 today=datetime.now().date())
        except Exception as e:
            flash(f'Error loading milestones: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/edit-milestone/<int:milestone_id>', methods=['GET', 'POST'], endpoint='admin.edit_milestone')
    @role_required([Roles.SUPER_HQ])
    def edit_milestone(milestone_id):
        """Edit milestone details"""
        milestone = Milestone.query.get_or_404(milestone_id)
        project = milestone.project
    
        if request.method == 'POST':
            try:
                data = request.form
            
                milestone.title = data.get('title')
                milestone.due_date = datetime.strptime(data.get('due_date'), '%Y-%m-%d').date()
                milestone.status = data.get('status', 'Pending')
            
                db.session.commit()
            
                flash(f'Milestone "{milestone.title}" updated successfully!', 'success')
                return redirect(url_for('admin.milestones', project_id=project.id))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating milestone: {str(e)}', 'error')
    
        return render_template('admin/edit_milestone.html', milestone=milestone, project=project)

    @app.route('/admin/delete-milestone/<int:milestone_id>', methods=['POST'], endpoint='admin.delete_milestone')
    @role_required([Roles.SUPER_HQ])
    def delete_milestone(milestone_id):
        """Delete milestone"""
        try:
            milestone = Milestone.query.get_or_404(milestone_id)
            project_id = milestone.project_id
            title = milestone.title
        
            db.session.delete(milestone)
            db.session.commit()
        
            flash(f'Milestone "{title}" deleted successfully!', 'success')
            return redirect(url_for('admin.milestones', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting milestone: {str(e)}', 'error')
            return redirect(url_for('admin.projects'))

# ==================== ASSET AND INVENTORY MANAGEMENT ====================

    @app.route('/admin/assets', endpoint='admin.assets')
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT])
    def assets():
        """Display all construction assets"""
        try:
            assets = Asset.query.order_by(Asset.created_at.desc()).all()
        
        # Calculate asset statistics
            total_assets = len(assets)
            active_assets = len([a for a in assets if a.status == 'Active'])
            retired_assets = len([a for a in assets if a.status == 'Retired'])
        
            asset_stats = {
                'total_assets': total_assets,
                'active_assets': active_assets,
                'retired_assets': retired_assets,
                'asset_types': {}
            }
        
        # Group by asset type
            for asset in assets:
                asset_type = asset.type or 'Unknown'
                if asset_type not in asset_stats['asset_types']:
                    asset_stats['asset_types'][asset_type] = 0
                asset_stats['asset_types'][asset_type] += 1
        
            return render_template('admin/assets.html', 
                                 assets=assets, 
                                 asset_stats=asset_stats)
        except Exception as e:
            flash(f'Error loading assets: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-asset', methods=['GET', 'POST'], endpoint='admin.add_asset')
    @role_required([Roles.SUPER_HQ])
    def add_asset():
        """Add new construction asset"""
        if request.method == 'POST':
            try:
                data = request.form
            
                asset = Asset(
                    name=data.get('name'),
                    type=data.get('type'),
                    status=data.get('status', 'Active'),
                    location=data.get('location'),
                    purchase_date=datetime.strptime(data.get('purchase_date'), '%Y-%m-%d').date() if data.get('purchase_date') else None
                )
            
                db.session.add(asset)
                db.session.commit()
            
                flash(f'Asset "{asset.name}" added successfully!', 'success')
                return redirect(url_for('admin.assets'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating asset: {str(e)}', 'error')
    
        return render_template('admin/add_asset.html')

    @app.route('/admin/asset/<int:asset_id>', endpoint='admin.view_asset')
    @role_required([Roles.SUPER_HQ])
    def view_asset(asset_id):
        """API endpoint to fetch individual asset data"""
        try:
            asset = Asset.query.get_or_404(asset_id)
        
            asset_data = {
                'id': asset.id,
                'name': asset.name,
                'type': asset.type,
                'status': asset.status,
                'location': asset.location,
                'purchase_date': asset.purchase_date.strftime('%Y-%m-%d') if asset.purchase_date else None,
                'retired_date': asset.retired_date.strftime('%Y-%m-%d') if asset.retired_date else None,
                'created_at': asset.created_at.strftime('%Y-%m-%d %H:%M') if asset.created_at else None
            }
        
            return jsonify({
                'success': True,
                'asset': asset_data
            })
        except Exception as e:
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500

    @app.route('/admin/edit-asset/<int:asset_id>', methods=['GET', 'POST'], endpoint='admin.edit_asset')
    @role_required([Roles.SUPER_HQ])
    def edit_asset(asset_id):
        """Edit existing asset"""
        asset = Asset.query.get_or_404(asset_id)
    
        if request.method == 'POST':
            try:
                data = request.form
            
            # Update asset fields
                asset.name = data.get('name')
                asset.type = data.get('type')
                asset.status = data.get('status', 'Active')
                asset.location = data.get('location')
            
            # Handle purchase date
                purchase_date = data.get('purchase_date')
                if purchase_date:
                    asset.purchase_date = datetime.strptime(purchase_date, '%Y-%m-%d').date()
                else:
                    asset.purchase_date = None
            
                db.session.commit()
            
                flash(f'Asset "{asset.name}" updated successfully!', 'success')
                return redirect(url_for('admin.assets'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating asset: {str(e)}', 'error')
    
        return render_template('admin/edit_asset.html', asset=asset)

    @app.route('/admin/retire-asset/<int:asset_id>', methods=['POST'], endpoint='admin.retire_asset')
    @role_required([Roles.SUPER_HQ])
    def retire_asset(asset_id):
        """Retire an asset"""
        try:
            asset = Asset.query.get_or_404(asset_id)
            asset_name = asset.name
        
            asset.status = 'Retired'
            asset.retired_date = datetime.now(timezone.utc).date()
        
            db.session.commit()
        
            flash(f'Asset "{asset_name}" retired successfully!', 'success')
            return redirect(url_for('admin.assets'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error retiring asset: {str(e)}', 'error')
            return redirect(url_for('admin.assets'))

    @app.route('/admin/delete-asset/<int:asset_id>', methods=['POST'], endpoint='admin.delete_asset')
    @role_required([Roles.SUPER_HQ])
    def delete_asset(asset_id):
        """Delete asset"""
        try:
            asset = Asset.query.get_or_404(asset_id)
            asset_name = asset.name
        
            db.session.delete(asset)
            db.session.commit()
        
            flash(f'Asset "{asset_name}" deleted successfully!', 'success')
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting asset: {str(e)}', 'error')
    
        return redirect(url_for('admin.assets'))

    @app.route('/admin/stock', endpoint='admin.stock')
    @role_required([Roles.SUPER_HQ])
    def stock():
        """Display stock/inventory management"""
        try:
            stock_items = Stock.query.order_by(Stock.created_at.desc()).all()
        
        # Calculate stock statistics
            total_items = len(stock_items)
            low_stock_items = len([s for s in stock_items if s.quantity <= s.low_stock_threshold])
            out_of_stock = len([s for s in stock_items if s.quantity == 0])
            available_items = len([s for s in stock_items if s.status == 'Available'])
        
            stock_stats = {
                'total_items': total_items,
                'low_stock_items': low_stock_items,
                'out_of_stock': out_of_stock,
                'available_items': available_items
            }
        
            return render_template('admin/stock.html', 
                                 stock_items=stock_items, 
                                 stock_stats=stock_stats)
        except Exception as e:
            flash(f'Error loading stock: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-stock', methods=['GET', 'POST'], endpoint='admin.add_stock')
    @role_required([Roles.SUPER_HQ])
    def add_stock():
        """Add new stock item"""
        if request.method == 'POST':
            try:
                data = request.form
            
                stock_item = Stock(
                    name=data.get('name'),
                    quantity=int(data.get('quantity', 0)),
                    unit=data.get('unit'),
                    status=data.get('status', 'Available'),
                    low_stock_threshold=int(data.get('low_stock_threshold', 10))
                )
            
                db.session.add(stock_item)
                db.session.commit()
            
                flash(f'Stock item "{stock_item.name}" added successfully!', 'success')
                return redirect(url_for('admin.stock'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating stock item: {str(e)}', 'error')
    
        return render_template('admin/add_stock.html')

    @app.route('/admin/stock/<int:stock_id>', endpoint='admin.view_stock_item')
    @role_required([Roles.SUPER_HQ])
    def view_stock_item(stock_id):
        """API endpoint to fetch individual stock item data"""
        try:
            stock_item = Stock.query.get_or_404(stock_id)
        
            stock_data = {
                'id': stock_item.id,
                'name': stock_item.name,
                'quantity': stock_item.quantity,
                'unit': stock_item.unit,
                'status': stock_item.status,
                'low_stock_threshold': stock_item.low_stock_threshold,
                'created_at': stock_item.created_at.strftime('%Y-%m-%d %H:%M') if stock_item.created_at else None
            }
        
            return jsonify({
                'success': True,
                'stock_item': stock_data
            })
        except Exception as e:
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500

    @app.route('/admin/edit-stock/<int:stock_id>', methods=['GET', 'POST'], endpoint='admin.edit_stock_item')
    @role_required([Roles.SUPER_HQ])
    def edit_stock_item(stock_id):
        """Edit existing stock item"""
        stock_item = Stock.query.get_or_404(stock_id)
    
        if request.method == 'POST':
            try:
                data = request.form
            
            # Update stock item fields
                stock_item.name = data.get('name')
                stock_item.quantity = int(data.get('quantity', 0))
                stock_item.unit = data.get('unit')
                stock_item.status = data.get('status', 'Available')
                stock_item.low_stock_threshold = int(data.get('low_stock_threshold', 10))
            
                db.session.commit()
            
                flash(f'Stock item "{stock_item.name}" updated successfully!', 'success')
                return redirect(url_for('admin.stock'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating stock item: {str(e)}', 'error')
    
        return render_template('admin/edit_stock.html', stock_item=stock_item)

    @app.route('/admin/adjust-stock/<int:stock_id>', methods=['POST'], endpoint='admin.adjust_stock_quantity')
    @role_required([Roles.SUPER_HQ])
    def adjust_stock_quantity(stock_id):
        """Adjust stock quantity"""
        try:
            stock_item = Stock.query.get_or_404(stock_id)
        
        # Try JSON first, then form data
            data = request.get_json() or request.form
        
            adjustment_type = data.get('adjustment_type')
            quantity = int(data.get('quantity', 0))
            reason = data.get('reason', '')
        
            old_quantity = stock_item.quantity
        
            if adjustment_type == 'add':
                stock_item.quantity += quantity
            elif adjustment_type == 'remove':
                stock_item.quantity = max(0, stock_item.quantity - quantity)
            elif adjustment_type == 'set':
                stock_item.quantity = quantity
        
            db.session.commit()
        
        # Log the adjustment (you could create an audit table for this)
            flash_message = f'Stock adjusted from {old_quantity} to {stock_item.quantity}'
            if reason:
                flash_message += f' (Reason: {reason})'
        
            flash(flash_message, 'success')
            return redirect(url_for('admin.stock'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error adjusting stock: {str(e)}', 'error')
            return redirect(url_for('admin.stock'))

    @app.route('/admin/delete-stock/<int:stock_id>', methods=['POST'], endpoint='admin.delete_stock_item')
    @role_required([Roles.SUPER_HQ])
    def delete_stock_item(stock_id):
        """Delete stock item"""
        try:
            stock_item = Stock.query.get_or_404(stock_id)
            stock_name = stock_item.name
        
            db.session.delete(stock_item)
            db.session.commit()
        
            flash(f'Stock item "{stock_name}" deleted successfully!', 'success')
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting stock item: {str(e)}', 'error')
    
        return redirect(url_for('admin.stock'))

# ==================== EQUIPMENT MANAGEMENT ====================

    @app.route('/admin/equipment', endpoint='admin.equipment')
    @role_required([Roles.SUPER_HQ])
    def equipment():
        """Display all construction equipment"""
        try:
            equipment = Equipment.query.order_by(Equipment.id.desc()).all()
        
        # Calculate equipment statistics
            total_equipment = len(equipment)
            active_equipment = len([e for e in equipment if e.status == 'Active'])
            maintenance_equipment = len([e for e in equipment if e.status in ['Maintenance', 'Under Maintenance']])
            inactive_equipment = len([e for e in equipment if e.status in ['Retired', 'Inactive', 'Out of Service']])
        
            equipment_stats = {
                'total_equipment': total_equipment,
                'active_equipment': active_equipment,
                'maintenance_equipment': maintenance_equipment,
                'inactive_equipment': inactive_equipment,
                'utilization_rate': (active_equipment / total_equipment * 100) if total_equipment > 0 else 0,
                'equipment_by_status': {}
            }
        
        # Group by equipment status
            for equip in equipment:
                equipment_status = equip.status or 'Unknown'
                if equipment_status not in equipment_stats['equipment_by_status']:
                    equipment_stats['equipment_by_status'][equipment_status] = 0
                equipment_stats['equipment_by_status'][equipment_status] += 1
        
            return render_template('admin/equipment.html', 
                                 equipment=equipment, 
                                 equipment_stats=equipment_stats)
        except Exception as e:
            flash(f'Error loading equipment: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/equipment/<int:equipment_id>', endpoint='admin.view_equipment')
    @role_required([Roles.SUPER_HQ])
    def view_equipment(equipment_id):
        """API endpoint to fetch individual equipment data"""
        try:
            equipment = Equipment.query.get_or_404(equipment_id)
        
            equipment_data = {
                'id': equipment.id,
                'name': equipment.name,
                'status': equipment.status,
                'machine_hours': equipment.machine_hours,
                'diesel_consumption': equipment.diesel_consumption,
                'maintenance_due': equipment.maintenance_due.strftime('%Y-%m-%d') if equipment.maintenance_due else None,
                'remarks': equipment.remarks,
                'created_at': equipment.id  # Using id as a placeholder since there's no created_at field
            }
        
            return jsonify({
                'success': True,
                'equipment': equipment_data
            })
        except Exception as e:
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500

    @app.route('/admin/add-equipment', methods=['GET', 'POST'], endpoint='admin.add_equipment')
    @role_required([Roles.SUPER_HQ])
    def add_equipment():
        """Add new construction equipment"""
        if request.method == 'POST':
            try:
                data = request.form
            
                equipment = Equipment(
                    name=data.get('name'),
                    status=data.get('status', 'Active'),
                    remarks=data.get('description'),  # Map description to remarks
                    machine_hours=float(data.get('machine_hours', 0)) if data.get('machine_hours') else 0,
                    diesel_consumption=float(data.get('diesel_consumption', 0)) if data.get('diesel_consumption') else 0,
                    maintenance_due=datetime.strptime(data.get('last_maintenance_date'), '%Y-%m-%d').date() if data.get('last_maintenance_date') else None
                )
            
                db.session.add(equipment)
                db.session.commit()
            
                flash(f'Equipment "{equipment.name}" added successfully!', 'success')
                return redirect(url_for('admin.equipment'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating equipment: {str(e)}', 'error')
    
        return render_template('admin/add_equipment.html')

    @app.route('/admin/edit-equipment/<int:equipment_id>', methods=['GET', 'POST'], endpoint='admin.edit_equipment')
    @role_required([Roles.SUPER_HQ])
    def edit_equipment(equipment_id):
        """Edit existing equipment"""
        equipment = Equipment.query.get_or_404(equipment_id)
    
        if request.method == 'POST':
            try:
                data = request.form
            
            # Update equipment fields
                equipment.name = data.get('name')
                equipment.status = data.get('status', 'Active')
                equipment.remarks = data.get('remarks')
                equipment.machine_hours = float(data.get('machine_hours', 0)) if data.get('machine_hours') else 0
                equipment.diesel_consumption = float(data.get('diesel_consumption', 0)) if data.get('diesel_consumption') else 0
            
            # Handle maintenance due date
                maintenance_due = data.get('maintenance_due')
                if maintenance_due:
                    equipment.maintenance_due = datetime.strptime(maintenance_due, '%Y-%m-%d').date()
                else:
                    equipment.maintenance_due = None
            
                db.session.commit()
            
                flash(f'Equipment "{equipment.name}" updated successfully!', 'success')
                return redirect(url_for('admin.equipment'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating equipment: {str(e)}', 'error')
    
        return render_template('admin/edit_equipment.html', equipment=equipment)

    @app.route('/admin/delete-equipment/<int:equipment_id>', methods=['POST'], endpoint='admin.delete_equipment')
    @role_required([Roles.SUPER_HQ])
    def delete_equipment(equipment_id):
        """Delete equipment"""
        try:
            equipment = Equipment.query.get_or_404(equipment_id)
            equipment_name = equipment.name
        
            db.session.delete(equipment)
            db.session.commit()
        
            flash(f'Equipment "{equipment_name}" deleted successfully!', 'success')
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting equipment: {str(e)}', 'error')
    
        return redirect(url_for('admin.equipment'))

# ==================== MONITORING ENDPOINTS ====================

    @app.route('/admin/incidents', endpoint='admin.incidents')
    @role_required([Roles.SUPER_HQ])
    def incidents():
        """Display all site incidents"""
        try:
            incidents = Incident.query.order_by(Incident.date_reported.desc()).all()
        
        # Calculate incident statistics
            total_incidents = len(incidents)
            open_incidents = len([i for i in incidents if i.status == 'Open'])
            resolved_incidents = len([i for i in incidents if i.status == 'Resolved'])
            critical_incidents = len([i for i in incidents if i.severity == 'Critical'])
        
            incident_stats = {
                'total_incidents': total_incidents,
                'open_incidents': open_incidents,
                'resolved_incidents': resolved_incidents,
                'critical_incidents': critical_incidents
            }
        
            return render_template('admin/incidents.html', 
                                 incidents=incidents, 
                                 incident_stats=incident_stats)
        except Exception as e:
            flash(f'Error loading incidents: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-incident', methods=['GET', 'POST'], endpoint='admin.add_incident')
    @role_required([Roles.SUPER_HQ])
    def add_incident():
        """Report new safety incident"""
        if request.method == 'POST':
            try:
                data = request.form
            
                incident = Incident(
                    title=data.get('title'),
                    description=data.get('description'),
                    status=data.get('status', 'Open'),
                    reported_by=data.get('reported_by'),
                    severity=data.get('severity', 'Medium')
                )
            
                db.session.add(incident)
                db.session.commit()
            
                flash(f'Incident "{incident.title}" reported successfully!', 'success')
                return redirect(url_for('admin.incidents'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error reporting incident: {str(e)}', 'error')
    
        employees = Employee.query.all()
        return render_template('admin/add_incident.html', employees=employees)

    @app.route('/admin/alerts', endpoint='admin.alerts')
    @role_required([Roles.SUPER_HQ])
    def alerts():
        """Display all system alerts"""
        try:
            alerts = Alert.query.order_by(Alert.created_at.desc()).all()
        
        # Calculate alert statistics
            total_alerts = len(alerts)
            active_alerts = len([a for a in alerts if a.status == 'Active'])
            critical_alerts = len([a for a in alerts if a.severity == 'Critical'])
        
            alert_stats = {
                'total_alerts': total_alerts,
                'active_alerts': active_alerts,
                'critical_alerts': critical_alerts
            }
        
            return render_template('admin/alerts.html', 
                                 alerts=alerts, 
                                 alert_stats=alert_stats)
        except Exception as e:
            flash(f'Error loading alerts: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-alert', methods=['GET', 'POST'], endpoint='admin.add_alert')
    @role_required([Roles.SUPER_HQ])
    def add_alert():
        """Create new system alert"""
        if request.method == 'POST':
            try:
                data = request.form
            
                alert = Alert(
                    title=data.get('title'),
                    type=data.get('type'),
                    description=data.get('description'),
                    status=data.get('status', 'Active'),
                    severity=data.get('severity', 'Medium')
                )
            
                db.session.add(alert)
                db.session.commit()
            
                flash(f'Alert "{alert.title}" created successfully!', 'success')
                return redirect(url_for('admin.alerts'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating alert: {str(e)}', 'error')
    
        return render_template('admin/add_alert.html')

# ==================== SCHEDULING ENDPOINTS ====================

    @app.route('/admin/schedules', endpoint='admin.schedules')
    @role_required([Roles.SUPER_HQ])
    def schedules():
        """Display all project schedules with filtering and enhanced business logic"""
        try:
        # Get filter parameters
            project_filter = request.args.get('project', '')
            status_filter = request.args.get('status', '')
            type_filter = request.args.get('type', '')
            view_schedule_id = request.args.get('view_schedule', '')
        
        # Base query with project relationship
            schedules_query = Schedule.query.join(Project)
        
        # Apply filters
            if project_filter:
                schedules_query = schedules_query.filter(Schedule.project_id == project_filter)
            if status_filter:
                schedules_query = schedules_query.filter(Schedule.status == status_filter)
            if type_filter:
                schedules_query = schedules_query.filter(Schedule.type == type_filter)
        
        # Get schedules ordered by start time
            schedules = schedules_query.order_by(Schedule.start_time.asc()).all()
        
        # Get all projects for filters
            projects = Project.query.filter_by(status='Active').order_by(Project.name).all()
        
        # Get specific schedule for viewing if requested
            view_schedule = None
            if view_schedule_id:
                try:
                    view_schedule = Schedule.query.get(int(view_schedule_id))
                except (ValueError, TypeError):
                    pass
        
        # Enhanced schedule statistics with business logic
            now = datetime.now()
            today = now.date()
        
        # Categorize schedules
            upcoming_schedules = [s for s in schedules if s.start_time.date() > today]
            ongoing_schedules = [s for s in schedules if s.start_time.date() <= today <= s.end_time.date() and s.status not in ['Completed', 'Cancelled']]
            overdue_schedules = [s for s in schedules if s.end_time.date() < today and s.status not in ['Completed', 'Cancelled']]
            completed_schedules = [s for s in schedules if s.status == 'Completed']
        
        # This week's schedules
            week_start = today - timedelta(days=today.weekday())
            week_end = week_start + timedelta(days=6)
            this_week_schedules = [s for s in schedules if week_start <= s.start_time.date() <= week_end]
        
        # Calculate project schedule health
            project_schedule_health = {}
            for project in projects:
                project_schedules = [s for s in schedules if s.project_id == project.id]
                if project_schedules:
                    total = len(project_schedules)
                    completed = len([s for s in project_schedules if s.status == 'Completed'])
                    overdue = len([s for s in project_schedules if s.end_time.date() < today and s.status not in ['Completed', 'Cancelled']])
                
                    health_score = 100
                    if total > 0:
                        completion_rate = (completed / total) * 100
                        overdue_penalty = (overdue / total) * 50  # 50% penalty for overdue
                        health_score = max(0, completion_rate - overdue_penalty)
                
                    project_schedule_health[project.id] = {
                        'health_score': round(health_score, 1),
                        'total': total,
                        'completed': completed,
                        'overdue': overdue
                    }
        
            schedule_stats = {
                'total_schedules': len(schedules),
                'upcoming_schedules': len(upcoming_schedules),
                'ongoing_schedules': len(ongoing_schedules),
                'overdue_schedules': len(overdue_schedules),
                'completed_schedules': len(completed_schedules),
                'this_week_schedules': len(this_week_schedules),
                'project_health': project_schedule_health
            }
        
        # Schedule types for filtering
            schedule_types = ['Planning', 'Construction', 'Inspection', 'Meeting', 'Delivery', 'Maintenance', 'Other']
            schedule_statuses = ['Scheduled', 'In Progress', 'Completed', 'Cancelled', 'Postponed']
        
            return render_template('admin/schedules.html', 
                                 schedules=schedules, 
                                 projects=projects,
                                 schedule_stats=schedule_stats,
                                 project_health=project_schedule_health,
                                 schedule_types=schedule_types,
                                 schedule_statuses=schedule_statuses,
                                 project_filter=project_filter,
                                 status_filter=status_filter,
                                 type_filter=type_filter,
                                 view_schedule=view_schedule,
                                 upcoming_schedules=upcoming_schedules,
                                 ongoing_schedules=ongoing_schedules,
                                 overdue_schedules=overdue_schedules,
                                 this_week_schedules=this_week_schedules)
        except Exception as e:
            flash(f'Error loading schedules: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-general-schedule', methods=['GET', 'POST'], endpoint='admin.add_general_schedule')
    @role_required([Roles.SUPER_HQ])
    def add_general_schedule():
        """Create new project schedule"""
        if request.method == 'POST':
            try:
                data = request.form
            
                schedule = Schedule(
                    project_id=int(data.get('project_id')),
                    title=data.get('title'),
                    type=data.get('type'),
                    description=data.get('description'),
                    start_time=datetime.strptime(data.get('start_time'), '%Y-%m-%dT%H:%M'),
                    end_time=datetime.strptime(data.get('end_time'), '%Y-%m-%dT%H:%M'),
                    status=data.get('status', 'Scheduled')
                )
            
                db.session.add(schedule)
                db.session.commit()
            
                flash(f'Schedule "{schedule.title}" created successfully!', 'success')
                return redirect(url_for('admin.schedules'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating schedule: {str(e)}', 'error')
    
        projects = Project.query.all()
        return render_template('admin/add_schedule.html', projects=projects)

    @app.route('/admin/edit-schedule/<int:schedule_id>', methods=['GET', 'POST'], endpoint='admin.edit_schedule')
    @role_required([Roles.SUPER_HQ])
    def edit_schedule(schedule_id):
        """Edit existing schedule"""
        try:
            schedule = Schedule.query.get_or_404(schedule_id)
        
            if request.method == 'POST':
                try:
                    data = request.form
                
                # Update schedule fields
                    schedule.project_id = int(data.get('project_id'))
                    schedule.title = data.get('title')
                    schedule.type = data.get('type')
                    schedule.description = data.get('description')
                    schedule.start_time = datetime.strptime(data.get('start_time'), '%Y-%m-%dT%H:%M')
                    schedule.end_time = datetime.strptime(data.get('end_time'), '%Y-%m-%dT%H:%M')
                    schedule.status = data.get('status', 'Scheduled')
                
                    db.session.commit()
                
                    flash(f'Schedule "{schedule.title}" updated successfully!', 'success')
                    return redirect(url_for('admin.schedules'))
                
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating schedule: {str(e)}', 'error')
        
            projects = Project.query.all()
            schedule_types = ['Planning', 'Construction', 'Inspection', 'Meeting', 'Delivery', 'Maintenance', 'Other']
            schedule_statuses = ['Scheduled', 'In Progress', 'Completed', 'Cancelled', 'Postponed']
        
            return render_template('admin/edit_schedule.html', 
                                 schedule=schedule, 
                                 projects=projects,
                                 schedule_types=schedule_types,
                                 schedule_statuses=schedule_statuses)
        
        except Exception as e:
            flash(f'Error loading schedule: {str(e)}', 'error')
            return redirect(url_for('admin.schedules'))

    @app.route('/admin/delete-schedule/<int:schedule_id>', methods=['POST'], endpoint='admin.delete_schedule')
    @role_required([Roles.SUPER_HQ])
    def delete_schedule(schedule_id):
        """Delete a schedule"""
        try:
            schedule = Schedule.query.get_or_404(schedule_id)
            schedule_title = schedule.title
        
            db.session.delete(schedule)
            db.session.commit()
        
            flash(f'Schedule "{schedule_title}" deleted successfully!', 'success')
            return redirect(url_for('admin.schedules'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting schedule: {str(e)}', 'error')
            return redirect(url_for('admin.schedules'))

# ==================== ANALYTICS ENDPOINTS ====================

    @app.route('/admin/analytics', endpoint='admin.analytics')
    @role_required([Roles.SUPER_HQ])
    def analytics():
        """Analytics dashboard - redirect to comprehensive analytics"""
        return redirect(url_for('admin.analytics_custom'))


    @app.route('/admin/analytics-custom', endpoint='admin.analytics_custom')
    @role_required([Roles.SUPER_HQ])
    def analytics_custom():
        """Comprehensive analytics dashboard for all modules"""
        try:
            from sqlalchemy import func, extract
        
            current_date = datetime.now()
            current_month = current_date.replace(day=1)
            last_month = (current_month - timedelta(days=1)).replace(day=1)
            current_year = current_date.year
        
        # Comprehensive analytics data from all modules
            analytics_data = {
            # PROJECT ANALYTICS
                'project_analytics': {
                    'total_projects': Project.query.count(),
                    'active_projects': Project.query.filter_by(status='Active').count(),
                    'completed_projects': Project.query.filter_by(status='Completed').count(),
                    'planning_projects': Project.query.filter_by(status='Planning').count(),
                    'on_hold_projects': Project.query.filter_by(status='On Hold').count(),
                    'total_budget': db.session.query(func.sum(Project.budget)).scalar() or 0,
                    'avg_budget': db.session.query(func.avg(Project.budget)).scalar() or 0,
                    'projects_this_month': Project.query.filter(Project.created_at >= current_month).count(),
                    'projects_last_month': Project.query.filter(
                        Project.created_at >= last_month,
                        Project.created_at < current_month
                    ).count()
                },
            
            # FINANCIAL ANALYTICS
                'financial_analytics': {
                    'total_orders': PurchaseOrder.query.count(),
                    'pending_orders': PurchaseOrder.query.filter_by(status='Pending').count(),
                    'approved_orders': PurchaseOrder.query.filter_by(status='Approved').count(),
                    'rejected_orders': PurchaseOrder.query.filter_by(status='Rejected').count(),
                    'total_order_value': db.session.query(func.sum(PurchaseOrder.total_amount)).scalar() or 0,
                    'pending_order_value': db.session.query(func.sum(PurchaseOrder.total_amount)).filter(
                        PurchaseOrder.status == 'Pending'
                    ).scalar() or 0,
                    'approved_order_value': db.session.query(func.sum(PurchaseOrder.total_amount)).filter(
                        PurchaseOrder.status == 'Approved'
                    ).scalar() or 0,
                    'orders_this_month': PurchaseOrder.query.filter(PurchaseOrder.created_at >= current_month).count(),
                    'total_expenses': db.session.query(func.sum(Expense.amount)).scalar() or 0,
                    'expenses_this_month': db.session.query(func.sum(Expense.amount)).filter(
                        Expense.date >= current_month.date()
                    ).scalar() or 0,
                    'avg_order_value': db.session.query(func.avg(PurchaseOrder.total_amount)).scalar() or 0
                },
            
            # PROCUREMENT ANALYTICS
                'procurement_analytics': {
                    'total_suppliers': Supplier.query.count(),
                    'active_suppliers': Supplier.query.filter_by(status='Active').count(),
                    'inactive_suppliers': Supplier.query.filter_by(status='Inactive').count(),
                    'total_stock_items': Stock.query.count(),
                    'low_stock_items': Stock.query.filter(Stock.quantity <= 10).count(),
                    'out_of_stock_items': Stock.query.filter(Stock.quantity <= 0).count(),
                    'total_stock_quantity': db.session.query(func.sum(Stock.quantity)).scalar() or 0,
                    'suppliers_this_month': Supplier.query.filter(Supplier.created_at >= current_month).count()
                },
            
            # HR ANALYTICS
                'hr_analytics': {
                    'total_employees': Employee.query.count(),
                    'active_employees': Employee.query.filter_by(status='Active').count(),
                    'inactive_employees': Employee.query.filter_by(status='Inactive').count(),
                    'departments': db.session.query(func.count(func.distinct(Employee.department))).scalar() or 0,
                    'positions': db.session.query(func.count(func.distinct(Employee.position))).scalar() or 0,
                    'new_hires_this_month': Employee.query.filter(Employee.date_of_employment >= current_month.date()).count(),
                    'avg_salary': db.session.query(func.avg(Payroll.amount)).scalar() or 0,
                    'total_payroll': db.session.query(func.sum(Payroll.amount)).scalar() or 0
                },
            
            # ASSET ANALYTICS
                'asset_analytics': {
                    'total_assets': Asset.query.count(),
                    'active_assets': Asset.query.filter_by(status='Active').count(),
                    'retired_assets': Asset.query.filter_by(status='Retired').count(),
                    'maintenance_assets': Asset.query.filter_by(status='Under Maintenance').count(),
                    'assets_this_month': Asset.query.filter(Asset.created_at >= current_month).count()
                },
            
            # EQUIPMENT ANALYTICS
                'equipment_analytics': {
                    'total_equipment': Equipment.query.count(),
                    'active_equipment': Equipment.query.filter_by(status='Active').count(),
                    'maintenance_equipment': Equipment.query.filter_by(status='Under Maintenance').count(),
                    'retired_equipment': Equipment.query.filter_by(status='Retired').count(),
                    'avg_machine_hours': db.session.query(func.avg(Equipment.machine_hours)).scalar() or 0,
                    'total_diesel_consumption': db.session.query(func.sum(Equipment.diesel_consumption)).scalar() or 0
                },
            
            # INCIDENT ANALYTICS
                'incident_analytics': {
                    'total_incidents': Incident.query.count(),
                    'open_incidents': Incident.query.filter_by(status='Open').count(),
                    'closed_incidents': Incident.query.filter_by(status='Closed').count(),
                    'critical_incidents': Incident.query.filter_by(severity='Critical').count(),
                    'high_incidents': Incident.query.filter_by(severity='High').count(),
                    'medium_incidents': Incident.query.filter_by(severity='Medium').count(),
                    'low_incidents': Incident.query.filter_by(severity='Low').count(),
                    'incidents_this_month': Incident.query.filter(Incident.date_reported >= current_month.date()).count()
                },
            
            # SCHEDULE ANALYTICS
                'schedule_analytics': {
                    'total_schedules': Schedule.query.count(),
                    'active_schedules': Schedule.query.filter_by(status='active').count(),
                    'pending_schedules': Schedule.query.filter_by(status='pending').count(),
                    'completed_schedules': Schedule.query.filter_by(status='completed').count(),
                    'schedules_this_month': Schedule.query.filter(Schedule.created_at >= current_month).count(),
                    'overdue_schedules': Schedule.query.filter(
                        Schedule.end_time < current_date,
                        Schedule.status.notin_(['completed', 'cancelled'])
                    ).count()
                },
            
            # DOCUMENT ANALYTICS
                'document_analytics': {
                    'total_documents': Document.query.count(),
                    'documents_this_month': Document.query.filter(Document.uploaded_at >= current_month).count(),
                    'total_file_size': db.session.query(func.sum(Document.size)).scalar() or 0,
                    'avg_file_size': db.session.query(func.avg(Document.size)).scalar() or 0
                }
            }
        
        # Monthly trend data for charts (last 12 months)
            monthly_data = []
            for i in range(12):
                month_start = datetime.now().replace(day=1) - timedelta(days=30*i)
                month_end = month_start + timedelta(days=30)
            
                monthly_stats = {
                    'month': month_start.strftime('%Y-%m'),
                    'month_name': month_start.strftime('%B %Y'),
                    'projects': Project.query.filter(
                        Project.created_at >= month_start,
                        Project.created_at < month_end
                    ).count(),
                    'orders': PurchaseOrder.query.filter(
                        PurchaseOrder.created_at >= month_start,
                        PurchaseOrder.created_at < month_end
                    ).count(),
                    'order_value': db.session.query(func.sum(PurchaseOrder.total_amount)).filter(
                        PurchaseOrder.created_at >= month_start,
                        PurchaseOrder.created_at < month_end
                    ).scalar() or 0,
                    'expenses': db.session.query(func.sum(Expense.amount)).filter(
                        Expense.date >= month_start.date(),
                        Expense.date < month_end.date()
                    ).scalar() or 0,
                    'incidents': Incident.query.filter(
                        Incident.date_reported >= month_start.date(),
                        Incident.date_reported < month_end.date()
                    ).count(),
                    'new_employees': Employee.query.filter(
                        Employee.date_of_employment >= month_start.date(),
                        Employee.date_of_employment < month_end.date()
                    ).count(),
                    'schedules': Schedule.query.filter(
                        Schedule.created_at >= month_start,
                        Schedule.created_at < month_end
                    ).count()
                }
                monthly_data.append(monthly_stats)
        
            analytics_data['monthly_trends'] = list(reversed(monthly_data))
        
        # Calculate growth rates
            analytics_data['growth_rates'] = {
                'projects': calculate_growth_rate(
                    analytics_data['project_analytics']['projects_this_month'],
                    analytics_data['project_analytics']['projects_last_month']
                ),
                'orders': calculate_growth_rate(
                    analytics_data['financial_analytics']['orders_this_month'],
                    PurchaseOrder.query.filter(
                        PurchaseOrder.created_at >= last_month,
                        PurchaseOrder.created_at < current_month
                    ).count()
                ),
                'employees': calculate_growth_rate(
                    analytics_data['hr_analytics']['new_hires_this_month'],
                    Employee.query.filter(
                        Employee.date_of_employment >= last_month.date(),
                        Employee.date_of_employment < current_month.date()
                    ).count()
                )
            }
        
            return render_template('admin/analytics.html', analytics=analytics_data)
        except Exception as e:
            flash(f'Error loading analytics: {str(e)}', 'error')
            return render_template('error.html'), 500


    def calculate_growth_rate(current, previous):
        """Calculate growth rate percentage"""
        if previous == 0:
            return 100 if current > 0 else 0
        return round(((current - previous) / previous) * 100, 1)

    @app.route('/admin/analytics-export-csv', endpoint='admin.analytics_export_csv')
    @role_required([Roles.SUPER_HQ])
    def analytics_export_csv():
        """Export analytics data as CSV"""
        try:
        # Create CSV data
            output = io.StringIO()
            writer = csv.writer(output)
        
        # Write headers
            writer.writerow(['Report Type', 'Metric', 'Value', 'Generated At'])
        
        # Project metrics
            writer.writerow(['Projects', 'Total Projects', Project.query.count(), datetime.now()])
            writer.writerow(['Projects', 'Active Projects', Project.query.filter_by(status='Active').count(), datetime.now()])
            writer.writerow(['Projects', 'Completed Projects', Project.query.filter_by(status='Completed').count(), datetime.now()])
        
        # Asset metrics
            writer.writerow(['Assets', 'Total Assets', Asset.query.count(), datetime.now()])
            writer.writerow(['Assets', 'Active Assets', Asset.query.filter_by(status='Active').count(), datetime.now()])
        
        # Employee metrics
            writer.writerow(['Employees', 'Total Employees', Employee.query.count(), datetime.now()])
            writer.writerow(['Employees', 'Active Employees', Employee.query.filter_by(status='Active').count(), datetime.now()])
        
        # Incident metrics
            writer.writerow(['Incidents', 'Total Incidents', Incident.query.count(), datetime.now()])
            writer.writerow(['Incidents', 'Open Incidents', Incident.query.filter_by(status='Open').count(), datetime.now()])
        
        # Create response
            output.seek(0)
        
        # Create a bytes buffer
            mem = io.BytesIO()
            mem.write(output.getvalue().encode('utf-8'))
            mem.seek(0)
        
            filename = f"construction_analytics_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        
            return send_file(
                mem,
                as_attachment=True,
                download_name=filename,
                mimetype='text/csv'
            )
        
        except Exception as e:
            flash(f'Error exporting analytics: {str(e)}', 'error')
            return redirect(url_for('admin.analytics_custom'))

# ==================== USER MANAGEMENT ENDPOINTS ====================

    @app.route('/admin/profile', endpoint='admin.profile')
    @role_required([Roles.SUPER_HQ])
    def profile():
        """Admin user profile management"""
        try:
        # Use Flask-Login current_user

        
            if not current_user.is_authenticated:
                flash('Please log in to view profile', 'error')
                return redirect(url_for('login'))
        
            user = current_user
        
        # Get user activity statistics
            user_stats = {
                'projects_managed': Project.query.filter_by(project_manager=user.name or user.username).count(),
                'incidents_reported': Incident.query.filter_by(reported_by=user.name or user.username).count(),
                'last_login': user.updated_at if hasattr(user, 'updated_at') else None,
                'account_created': user.created_at if hasattr(user, 'created_at') else None
            }
        
            return render_template('admin/profile.html', user=user, user_stats=user_stats)
        except Exception as e:
            flash(f'Error loading profile: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/logout', endpoint='admin.logout')
    def logout():
        """Admin logout functionality"""
        try:
        # Clear session
            session.clear()
            flash('You have been logged out successfully', 'success')
            return redirect(url_for('login'))
        except Exception as e:
            flash(f'Error during logout: {str(e)}', 'error')
            return redirect(url_for('admin.dashboard'))

# Purchase Order Management Routes

    @app.route('/admin/orders', endpoint='admin.orders')
    @role_required([Roles.SUPER_HQ])
    def orders():
        """Display purchase orders management"""
        try:
        # Get filter parameters
            status_filter = request.args.get('status', '')
            priority_filter = request.args.get('priority', '')
            supplier_filter = request.args.get('supplier', '')
            project_filter = request.args.get('project', '')
            view_order_id = request.args.get('view_order', '')
        
        # Base query
            orders_query = PurchaseOrder.query
        
        # Apply filters
            if status_filter:
                orders_query = orders_query.filter(PurchaseOrder.status == status_filter)
            if priority_filter:
                orders_query = orders_query.filter(PurchaseOrder.priority == priority_filter)
            if supplier_filter:
                orders_query = orders_query.filter(PurchaseOrder.supplier_name.ilike(f'%{supplier_filter}%'))
            if project_filter:
                orders_query = orders_query.filter(PurchaseOrder.project_id == project_filter)
        
        # Get orders with relationships
            purchase_orders = orders_query.order_by(PurchaseOrder.created_at.desc()).all()
        
        # Get filter data
            projects = Project.query.all()
            suppliers = Supplier.query.filter_by(status='Active').all()
        
        # Calculate statistics
            total_orders = PurchaseOrder.query.count()
            pending_orders = PurchaseOrder.query.filter_by(status='Pending').count()
            approved_orders = PurchaseOrder.query.filter_by(status='Approved').count()
            total_value = db.session.query(func.sum(PurchaseOrder.total_amount)).filter_by(status='Approved').scalar() or 0
        
            order_stats = {
                'total_orders': total_orders,
                'pending_orders': pending_orders,
                'approved_orders': approved_orders,
                'total_value': total_value
            }
        
        # Get specific order for viewing if requested
            view_order = None
            if view_order_id:
                try:
                    view_order = PurchaseOrder.query.get(int(view_order_id))
                except (ValueError, TypeError):
                    pass
        
            return render_template('admin/orders.html', 
                                 purchase_orders=purchase_orders,
                                 order_stats=order_stats,
                                 projects=projects,
                                 suppliers=suppliers,
                                 status_filter=status_filter,
                                 priority_filter=priority_filter,
                                 supplier_filter=supplier_filter,
                                 project_filter=project_filter,
                                 view_order=view_order)
        except Exception as e:
            flash(f'Error loading purchase orders: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-order', methods=['GET', 'POST'], endpoint='admin.add_order')
    @role_required([Roles.SUPER_HQ])
    def add_order():
        """Add new purchase order"""
        if request.method == 'POST':
            try:
                data = request.form
            
            # Generate order number
                order_number = f"PO-{datetime.now().strftime('%Y%m%d')}-{random.randint(1000, 9999)}"
            
            # Create purchase order
                purchase_order = PurchaseOrder(
                    order_number=order_number,
                    supplier_name=data.get('supplier_name'),
                    supplier_contact=data.get('supplier_contact'),
                    supplier_email=data.get('supplier_email'),
                    supplier_phone=data.get('supplier_phone'),
                    project_id=int(data.get('project_id')) if data.get('project_id') else None,
                    priority=data.get('priority', 'Normal'),
                    description=data.get('description'),
                    expected_delivery=datetime.strptime(data.get('expected_delivery'), '%Y-%m-%d').date() if data.get('expected_delivery') else None,
                    delivery_address=data.get('delivery_address'),
                    notes=data.get('notes'),
                    status=data.get('status', 'Pending'),  # Handle status from form
                    requested_by=current_user.id  # Use current_user instead of session
                )
            
                db.session.add(purchase_order)
                db.session.flush()  # Get the ID
            
            # Process line items
                item_names = request.form.getlist('item_name[]')
                item_descriptions = request.form.getlist('item_description[]')
                item_quantities = request.form.getlist('item_quantity[]')
                item_units = request.form.getlist('item_unit[]')
                item_prices = request.form.getlist('item_price[]')
            
                subtotal = 0
                has_items = False
            
                for i in range(len(item_names)):
                    if item_names[i] and item_names[i].strip():  # Check for non-empty item name
                        try:
                            quantity = float(item_quantities[i]) if item_quantities[i] else 0
                            unit_price = float(item_prices[i]) if item_prices[i] else 0
                        
                            if quantity > 0 and unit_price > 0:  # Only add items with valid quantity and price
                                line_total = quantity * unit_price
                            
                                line_item = PurchaseOrderLineItem(
                                    purchase_order_id=purchase_order.id,
                                    item_name=item_names[i].strip(),
                                    description=item_descriptions[i].strip() if item_descriptions[i] else '',
                                    quantity=quantity,
                                    unit=item_units[i].strip() if item_units[i] else '',
                                    unit_price=unit_price,
                                    line_total=line_total
                                )
                                db.session.add(line_item)
                                subtotal += line_total
                                has_items = True
                        except (ValueError, TypeError):
                        # Skip invalid items
                            continue
            
                if not has_items:
                    raise ValueError("At least one valid item with quantity and price is required")
            
            # Calculate totals
                tax_rate = float(data.get('tax_rate', 0)) / 100
                tax_amount = subtotal * tax_rate
                total_amount = subtotal + tax_amount
            
            # Update purchase order totals
                purchase_order.subtotal = subtotal
                purchase_order.tax_rate = tax_rate * 100
                purchase_order.tax_amount = tax_amount
                purchase_order.total_amount = total_amount
            
                db.session.commit()
            
                flash(f'Purchase order {order_number} created successfully!', 'success')
                return redirect(url_for('admin.orders'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating purchase order: {str(e)}', 'error')
    
    # GET request - show form
        try:
            projects = Project.query.all()
            suppliers = Supplier.query.filter_by(status='Active').all()
            stock_items = Stock.query.all()
        
            return render_template('admin/add_order_simple.html', 
                                 projects=projects,
                                 suppliers=suppliers,
                                 stock_items=stock_items)
        except Exception as e:
            flash(f'Error loading form data: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/order/<int:order_id>', endpoint='admin.view_order')
    @role_required([Roles.SUPER_HQ])
    def view_order(order_id):
        """View purchase order details"""
        try:
            purchase_order = PurchaseOrder.query.get_or_404(order_id)
        
            order_data = {
                'id': purchase_order.id,
                'order_number': purchase_order.order_number,
                'supplier_name': purchase_order.supplier_name,
                'supplier_contact': purchase_order.supplier_contact,
                'supplier_email': purchase_order.supplier_email,
                'supplier_phone': purchase_order.supplier_phone,
                'project_name': purchase_order.project.name if purchase_order.project else None,
                'status': purchase_order.status,
                'priority': purchase_order.priority,
                'description': purchase_order.description,
                'subtotal': purchase_order.subtotal,
                'tax_rate': purchase_order.tax_rate,
                'tax_amount': purchase_order.tax_amount,
                'total_amount': purchase_order.total_amount,
                'expected_delivery': purchase_order.expected_delivery.strftime('%Y-%m-%d') if purchase_order.expected_delivery else None,
                'delivery_address': purchase_order.delivery_address,
                'notes': purchase_order.notes,
                'requested_by': purchase_order.requested_by_employee.name if purchase_order.requested_by_employee else None,
                'approved_by': purchase_order.approved_by_employee.name if purchase_order.approved_by_employee else None,
                'approval_date': purchase_order.approval_date.strftime('%Y-%m-%d %H:%M') if purchase_order.approval_date else None,
                'created_at': purchase_order.created_at.strftime('%Y-%m-%d %H:%M'),
                'line_items': [{
                    'item_name': item.item_name,
                    'description': item.description,
                    'quantity': item.quantity,
                    'unit': item.unit,
                    'unit_price': item.unit_price,
                    'line_total': item.line_total
                } for item in purchase_order.line_items]
            }
        
            return jsonify({
                'success': True,
                'order': order_data
            })
        except Exception as e:
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500

    @app.route('/admin/order/<int:order_id>/approve', methods=['POST'], endpoint='admin.approve_order')
    @role_required([Roles.SUPER_HQ])
    def approve_order(order_id):
        """Approve purchase order"""
        try:
            purchase_order = PurchaseOrder.query.get_or_404(order_id)
        
            if purchase_order.status not in ['Draft', 'Pending']:
                flash('Order cannot be approved in current status', 'error')
                return redirect(url_for('admin.orders'))
        
            purchase_order.status = 'Approved'
            purchase_order.approved_by = session.get('user_id')
            purchase_order.approval_date = datetime.now(timezone.utc)
        
            db.session.commit()
        
        # Send notification to the user who requested the order
            if purchase_order.requested_by:
            # Try to get user email from User model first
                user = User.query.filter_by(id=purchase_order.requested_by).first()
                if user and user.email:
                    send_order_notification(user.email, purchase_order.order_number, 'Approved')
                else:
                # Fallback to Employee model
                    employee = Employee.query.filter_by(id=purchase_order.requested_by).first()
                    if employee and employee.email:
                        send_order_notification(employee.email, purchase_order.order_number, 'Approved')
        
            flash(f'Purchase order {purchase_order.order_number} approved successfully!', 'success')
            return redirect(url_for('admin.orders'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error approving purchase order: {str(e)}', 'error')
            return redirect(url_for('admin.orders'))

    @app.route('/admin/order/<int:order_id>/reject', methods=['POST'], endpoint='admin.reject_order')
    @role_required([Roles.SUPER_HQ])
    def reject_order(order_id):
        """Reject purchase order"""
        try:
            purchase_order = PurchaseOrder.query.get_or_404(order_id)
        # Try JSON first, then form data
            data = request.get_json() or request.form
            rejection_reason = data.get('reason', 'No reason provided')
        
            if purchase_order.status not in ['Draft', 'Pending']:
                flash('Order cannot be rejected in current status', 'error')
                return redirect(url_for('admin.orders'))
        
            purchase_order.status = 'Rejected'
            purchase_order.notes = f"{purchase_order.notes or ''}\n\nRejection reason: {rejection_reason}"
        
            db.session.commit()
        
        # Send notification to the user who requested the order
            if purchase_order.requested_by:
            # Try to get user email from User model first
                user = User.query.filter_by(id=purchase_order.requested_by).first()
                if user and user.email:
                    send_order_notification(user.email, purchase_order.order_number, 'Rejected', rejection_reason)
                else:
                # Fallback to Employee model
                    employee = Employee.query.filter_by(id=purchase_order.requested_by).first()
                    if employee and employee.email:
                        send_order_notification(employee.email, purchase_order.order_number, 'Rejected', rejection_reason)
        
            flash(f'Purchase order {purchase_order.order_number} rejected.', 'warning')
            return redirect(url_for('admin.orders'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error rejecting purchase order: {str(e)}', 'error')
            return redirect(url_for('admin.orders'))

    @app.route('/admin/order/<int:order_id>/reject-form', methods=['GET', 'POST'], endpoint='admin.reject_order_form')
    @role_required([Roles.SUPER_HQ])
    def reject_order_form(order_id):
        """Handle reject order form submission"""
        purchase_order = PurchaseOrder.query.get_or_404(order_id)
    
        if request.method == 'GET':
        # Show reject form
            return render_template('admin/reject_order.html', order=purchase_order)
    
        try:
            if purchase_order.status not in ['Draft', 'Pending']:
                flash('Order cannot be rejected in current status', 'error')
                return redirect(url_for('admin.orders'))
        
            rejection_reason = request.form.get('reason', 'No reason provided')
        
            purchase_order.status = 'Rejected'
            purchase_order.notes = f"{purchase_order.notes or ''}\n\nRejection reason: {rejection_reason}"
        
            db.session.commit()
        
        # Send notification to the user who requested the order
            if purchase_order.requested_by:
            # Try to get user email from User model first
                user = User.query.filter_by(id=purchase_order.requested_by).first()
                if user and user.email:
                    send_order_notification(user.email, purchase_order.order_number, 'Rejected', rejection_reason)
                else:
                # Fallback to Employee model
                    employee = Employee.query.filter_by(id=purchase_order.requested_by).first()
                    if employee and employee.email:
                        send_order_notification(employee.email, purchase_order.order_number, 'Rejected', rejection_reason)
        
            flash(f'Purchase order {purchase_order.order_number} rejected successfully. Notification sent to requestor.', 'success')
            return redirect(url_for('admin.orders'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error rejecting order: {str(e)}', 'error')
            return redirect(url_for('admin.orders'))

    @app.route('/admin/order/<int:order_id>/delete-form', methods=['POST'], endpoint='admin.delete_order_form')
    @role_required([Roles.SUPER_HQ])
    def delete_order_form(order_id):
        """Handle delete order form submission"""
        try:
            purchase_order = PurchaseOrder.query.get_or_404(order_id)
        
            if purchase_order.status in ['Approved', 'Ordered', 'Delivered']:
                flash('Cannot delete order in current status', 'error')
                return redirect(url_for('admin.orders'))
        
            order_number = purchase_order.order_number
            db.session.delete(purchase_order)
            db.session.commit()
        
            flash(f'Purchase order {order_number} deleted successfully.', 'success')
            return redirect(url_for('admin.orders'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting order: {str(e)}', 'error')
            return redirect(url_for('admin.orders'))

    @app.route('/admin/order/<int:order_id>/delete', methods=['POST', 'DELETE'], endpoint='admin.delete_order')
    @role_required([Roles.SUPER_HQ])
    def delete_order(order_id):
        """Delete purchase order"""
        try:
            purchase_order = PurchaseOrder.query.get_or_404(order_id)
        
            if purchase_order.status in ['Approved', 'Ordered', 'Delivered']:
                flash('Cannot delete order in current status', 'error')
                return redirect(url_for('admin.orders'))
        
            order_number = purchase_order.order_number
            db.session.delete(purchase_order)
            db.session.commit()
        
            flash(f'Purchase order {order_number} deleted successfully.', 'success')
            return redirect(url_for('admin.orders'))
        
        except Exception as e:
            db.session.rollback()
            flash(f'Error deleting purchase order: {str(e)}', 'error')
            return redirect(url_for('admin.orders'))

# Supplier Management Routes

    @app.route('/admin/suppliers', endpoint='admin.suppliers')
    @role_required([Roles.SUPER_HQ])
    def suppliers():
        """Display suppliers management"""
        try:
            view_supplier_id = request.args.get('view_supplier', '')
        
            suppliers = Supplier.query.order_by(Supplier.name).all()
        
        # Get specific supplier for viewing if requested
            view_supplier = None
            if view_supplier_id:
                try:
                    view_supplier = Supplier.query.get(int(view_supplier_id))
                except (ValueError, TypeError):
                    pass
        
            return render_template('admin/suppliers.html', 
                                 suppliers=suppliers, 
                                 view_supplier=view_supplier)
        except Exception as e:
            flash(f'Error loading suppliers: {str(e)}', 'error')
            return render_template('error.html'), 500

    @app.route('/admin/add-supplier', methods=['GET', 'POST'], endpoint='admin.add_supplier')
    @role_required([Roles.SUPER_HQ])
    def add_supplier():
        """Add new supplier"""
        if request.method == 'POST':
            try:
                data = request.form
            
                supplier = Supplier(
                    name=data.get('name'),
                    contact_person=data.get('contact_person'),
                    email=data.get('email'),
                    phone=data.get('phone'),
                    address=data.get('address'),
                    tax_id=data.get('tax_id'),
                    payment_terms=data.get('payment_terms'),
                    rating=float(data.get('rating', 0)) if data.get('rating') else None,
                    notes=data.get('notes')
                )
            
                db.session.add(supplier)
                db.session.commit()
            
                flash(f'Supplier "{supplier.name}" added successfully!', 'success')
                return redirect(url_for('admin.suppliers'))
            
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating supplier: {str(e)}', 'error')
    
        return render_template('admin/add_supplier.html')

    @app.route('/admin/edit-supplier/<int:supplier_id>', methods=['GET', 'POST'], endpoint='admin.edit_supplier')
    @role_required([Roles.SUPER_HQ])
    def edit_supplier(supplier_id):
        """Edit existing supplier"""
        try:
            supplier = Supplier.query.get_or_404(supplier_id)
        
            if request.method == 'POST':
                try:
                    data = request.form
                
                # Update supplier fields
                    supplier.name = data.get('name')
                    supplier.contact_person = data.get('contact_person')
                    supplier.email = data.get('email')
                    supplier.phone = data.get('phone')
                    supplier.address = data.get('address')
                    supplier.tax_id = data.get('tax_id')
                    supplier.payment_terms = data.get('payment_terms')
                    supplier.rating = float(data.get('rating', 0)) if data.get('rating') else None
                    supplier.notes = data.get('notes')
                    supplier.status = data.get('status', 'Active')
                    supplier.website = data.get('website')
                    supplier.description = data.get('description')
                    supplier.products_services = data.get('products_services')
                
                    db.session.commit()
                
                    flash(f'Supplier "{supplier.name}" updated successfully!', 'success')
                    return redirect(url_for('admin.suppliers'))
                
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating supplier: {str(e)}', 'error')
        
            return render_template('admin/edit_supplier.html', supplier=supplier)
        
        except Exception as e:
            flash(f'Error loading supplier: {str(e)}', 'error')
            return redirect(url_for('admin.suppliers'))

    # Context processor to provide global variables to all admin templates
    @app.context_processor
    def inject_monitoring_counts():
        """Inject monitoring counts for sidebar badges"""
        try:
            incident_count = Incident.query.filter_by(status='Open').count()
            alert_count = Alert.query.filter_by(status='Active').count()
        
            return {
                'incident_count': incident_count,
                'alert_count': alert_count
            }
        except Exception as e:
        # Return default values if database query fails
            return {
                'incident_count': 0,
                'alert_count': 0
            }

# --- Payroll Approval Routes ---
    @app.route('/admin/payroll/pending', endpoint='admin.pending_payrolls')
    @role_required([Roles.SUPER_HQ])
    def pending_payrolls():
        """View pending payroll approvals for admin"""
        try:
        
        # Get payrolls pending admin approval
            pending_approvals = db.session.query(PayrollApproval, User).join(
                User, PayrollApproval.submitted_by == User.id
            ).filter(
                PayrollApproval.status == 'pending_admin'
            ).order_by(PayrollApproval.submitted_at.desc()).all()
        
            return render_template('admin/payroll/pending.html', 
                                 pending_approvals=pending_approvals)
        
        except Exception as e:
            current_app.logger.error(f"Error loading pending payrolls: {str(e)}")
            flash("Error loading pending payrolls", "error")
            return redirect(url_for('admin.index'))

    @app.route('/admin/payroll/<int:approval_id>/review', methods=['GET', 'POST'], endpoint='admin.review_payroll')
    @role_required([Roles.SUPER_HQ])
    def review_payroll(approval_id):
        """Review and approve/reject payroll"""
        try:
        
            approval = db.session.get(PayrollApproval, approval_id)
            if not approval:
                flash("Payroll approval not found", "error")
                return redirect(url_for('admin.pending_payrolls'))
        
            if approval.status != 'pending_admin':
                flash("This payroll is no longer pending admin approval", "warning")
                return redirect(url_for('admin.pending_payrolls'))
        
            if request.method == 'POST':
                action = request.form.get('action')
                comments = request.form.get('comments', '')
            
                if action == 'approve':
                    approval.status = 'pending_finance'
                    approval.admin_reviewer = session.get('user_id')
                    approval.admin_reviewed_at = datetime.now()
                    approval.admin_comments = comments
                
                # Update all related staff payrolls
                    year, month = map(int, approval.payroll_period.split('-'))
                    staff_payrolls = StaffPayroll.query.filter(
                        StaffPayroll.period_year == year,
                        StaffPayroll.period_month == month
                    ).all()
                
                    for payroll in staff_payrolls:
                        payroll.approval_status = 'pending_finance'
                        payroll.approved_by_admin = session.get('user_id')
                        payroll.admin_approved_at = datetime.now()
                
                    flash(f"Payroll for {approval.payroll_period} approved and sent to Finance", "success")
                
                elif action == 'reject':
                    approval.status = 'rejected'
                    approval.admin_reviewer = session.get('user_id')
                    approval.admin_reviewed_at = datetime.now()
                    approval.admin_comments = comments
                
                # Update all related staff payrolls
                    year, month = map(int, approval.payroll_period.split('-'))
                    staff_payrolls = StaffPayroll.query.filter(
                        StaffPayroll.period_year == year,
                        StaffPayroll.period_month == month
                    ).all()
                
                    for payroll in staff_payrolls:
                        payroll.approval_status = 'rejected'
                
                    flash(f"Payroll for {approval.payroll_period} rejected", "warning")
            
                db.session.commit()
                return redirect(url_for('admin.pending_payrolls'))
        
        # Get payroll details for review
            year, month = map(int, approval.payroll_period.split('-'))
            staff_payrolls = db.session.query(StaffPayroll, Employee).join(
                Employee, StaffPayroll.employee_id == Employee.id
            ).filter(
                StaffPayroll.period_year == year,
                StaffPayroll.period_month == month
            ).all()
        
            return render_template('admin/payroll/review.html',
                                 approval=approval,
                                 staff_payrolls=staff_payrolls)
        
        except Exception as e:
            current_app.logger.error(f"Error reviewing payroll: {str(e)}")
            flash("Error reviewing payroll", "error")
            return redirect(url_for('admin.pending_payrolls'))

    @app.route('/admin/<int:project_id>/assign-staff', methods=['POST'], endpoint='admin.assign_staff')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def assign_staff(project_id):
        try:
        # Get data from form
            staff_role = request.form.get('role')
            staff_id = request.form.get('staff_id')
        
            if not staff_role or not staff_id:
                flash('Role and staff member are required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Validate project exists
            project = Project.query.get_or_404(project_id)
        
        # Validate staff member exists
            staff_member = User.query.get(staff_id)
            if not staff_member:
                flash('Staff member not found', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Check if staff is already assigned to this project
            existing_assignment = StaffAssignment.query.filter_by(
                project_id=project_id, 
                staff_id=staff_id
            ).first()
        
            if existing_assignment:
                flash(f'{staff_member.name} is already assigned to this project', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Create new assignment
            assignment = StaffAssignment(
                project_id=project_id, 
                staff_id=staff_id, 
                role=staff_role,
                assigned_at=datetime.now()
            )
        
            db.session.add(assignment)
            db.session.commit()
        
            current_app.logger.info(f"Staff {staff_member.name} (ID: {staff_id}) assigned as {staff_role} to project {project_id}")
        
            flash(f'{staff_member.name} assigned as {staff_role} to {project.name}', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Assign staff error: {str(e)}", exc_info=True)
            flash(f'Error assigning staff: {str(e)}', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


# Remove staff from project
    @app.route('/admin/<int:project_id>/remove-staff', methods=['POST'], endpoint='admin.remove_staff')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def remove_staff(project_id):
        try:
            staff_id = request.form.get('staff_id')
        
            if not staff_id:
                flash('Staff ID is required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            assignment = StaffAssignment.query.filter_by(
                project_id=project_id, 
                staff_id=staff_id
            ).first()
        
            if not assignment:
                flash('Staff assignment not found', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            staff_member = User.query.get(staff_id)
            staff_name = staff_member.name if staff_member else f'Staff {staff_id}'
        
            db.session.delete(assignment)
            db.session.commit()
        
            current_app.logger.info(f"Staff {staff_name} (ID: {staff_id}) removed from project {project_id}")
        
            flash(f'{staff_name} removed from project', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Remove staff error: {str(e)}", exc_info=True)
            flash(f'Error removing staff: {str(e)}', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


# Delete project endpoint
    @app.route('/admin/<int:project_id>/delete', methods=['POST'], endpoint='admin.delete_project')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def delete_project(project_id):
        try:
            project = Project.query.get_or_404(project_id)
            project_name = project.name
        
        # Remove all staff assignments first
            StaffAssignment.query.filter_by(project_id=project_id).delete()
        
        # Remove related milestones
            Milestone.query.filter_by(project_id=project_id).delete()
        
        # Remove related tasks
            Task.query.filter_by(project_id=project_id).delete()
        
        # Remove related schedules if they exist
            if hasattr(Schedule, 'project_id'):
                Schedule.query.filter_by(project_id=project_id).delete()
        
        # Delete the project
            db.session.delete(project)
            db.session.commit()
        
            current_app.logger.info(f"Project {project_name} (ID: {project_id}) deleted by {current_user.name}")
        
            flash(f'Project "{project_name}" deleted successfully', 'success')
            return redirect(url_for('admin.projects'))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Delete project error: {str(e)}", exc_info=True)
            flash(f'Error deleting project: {str(e)}', 'error')
            return redirect(url_for('admin.projects'))


# Update project status endpoint
    @app.route('/admin/<int:project_id>/update-status', methods=['POST'], endpoint='admin.update_project_status')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def update_project_status(project_id):
        try:
            new_status = request.form.get('status')
        
            if not new_status:
                flash('Status is required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            project = Project.query.get_or_404(project_id)
            old_status = project.status
            project.status = new_status
            project.updated_at = datetime.now()
        
        # Auto-update progress based on status
            if new_status == 'Completed':
                project.progress = 100.0
            elif new_status == 'Active' and not project.progress:
                project.progress = 10.0  # Start with 10% if active
        
            db.session.commit()
        
            current_app.logger.info(f"Project {project_id} status updated from {old_status} to {new_status}")
        
            flash(f'Project status updated to {new_status}', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Update project status error: {str(e)}", exc_info=True)
            flash(f'Error updating status: {str(e)}', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


# Update project progress endpoint
    @app.route('/admin/<int:project_id>/update-progress', methods=['POST'], endpoint='admin.update_project_progress')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def update_project_progress(project_id):
        try:
            progress = float(request.form.get('progress', 0))
        
            if progress < 0 or progress > 100:
                flash('Progress must be between 0 and 100', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            project = Project.query.get_or_404(project_id)
            old_progress = project.progress
            project.progress = progress
            project.updated_at = datetime.now()
        
        # Auto-update status based on progress
            if progress == 100:
                project.status = 'Completed'
            elif progress > 0 and project.status == 'Planning':
                project.status = 'Active'
        
            db.session.commit()
        
            current_app.logger.info(f"Project {project_id} progress updated from {old_progress}% to {progress}%")
        
            flash(f'Project progress updated to {progress}%', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Update project progress error: {str(e)}", exc_info=True)
            flash(f'Error updating progress: {str(e)}', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


# Get project progress for admin dashboard
    @app.route('/admin/<int:project_id>/progress', methods=['GET'], endpoint='admin.get_project_progress')
    @login_required  
    @role_required([Roles.SUPER_HQ])
    def get_project_progress(project_id):
        try:
            project = Project.query.get_or_404(project_id)
        
        # Get updated milestone counts
            milestones = Milestone.query.filter_by(project_id=project_id).all()
            completed_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Completed']
        
        # Get updated task counts
            tasks = Task.query.filter_by(project_id=project_id).all()
            completed_tasks = [t for t in tasks if hasattr(t, 'status') and t.status == 'completed']
        
            return jsonify({
                'status': 'success',
                'progress': project.progress or 0,
                'milestone_count': len(milestones),
                'milestones_completed': len(completed_milestones),
                'task_count': len(tasks),
                'tasks_completed': len(completed_tasks),
                'project_status': project.status,
                'last_updated': project.updated_at.isoformat() if project.updated_at else None
            })
        
        except Exception as e:
            current_app.logger.error(f"Get admin project progress error: {str(e)}", exc_info=True)
            return jsonify({'error': 'Error fetching project progress'}), 500


    @app.route('/admin/projects/<int:project_id>', endpoint='admin.project_details')
    @login_required
    def project_details(project_id):
        try:
            current_app.logger.info(f"User {current_user.id} accessing project {project_id}")
            project = Project.query.get_or_404(project_id)
        
        # Check if user has access to this project
            user_assignment = StaffAssignment.query.filter_by(
                project_id=project_id, 
                staff_id=current_user.id
            ).first()
        
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            current_app.logger.info(f"Access check - assignment: {bool(user_assignment)}, manager: {is_manager}, super_hq: {is_super_hq}")
        
        # Allow access if user is assigned, is the manager, or is SUPER_HQ
            if not (user_assignment or is_manager or is_super_hq):
                current_app.logger.warning(f"Access denied for user {current_user.id} to project {project_id}")
                flash("You don't have access to this project.", "error")
                return redirect(url_for('admin.projects'))
        
        # Get staff assignments with user details
            staff_assignments = db.session.query(StaffAssignment, User.name).join(
                User, StaffAssignment.staff_id == User.id
            ).filter(StaffAssignment.project_id == project_id).all()
        
        # Get employee assignments with employee details
            employee_assignments = db.session.query(EmployeeAssignment, Employee.name).join(
                Employee, EmployeeAssignment.employee_id == Employee.id
            ).filter(EmployeeAssignment.project_id == project_id).all()
        
        # Combine both types of assignments for display
            all_assignments = []
        
        # Add staff assignments
            for assignment, staff_name in staff_assignments:
                all_assignments.append({
                    'assignment': assignment,
                    'staff_name': staff_name,
                    'type': 'user',
                    'role': assignment.role,
                    'assigned_at': assignment.assigned_at,
                    'id': assignment.staff_id
                })
        
        # Add employee assignments
            for assignment, employee_name in employee_assignments:
                all_assignments.append({
                    'assignment': assignment,
                    'staff_name': employee_name,
                    'type': 'employee',
                    'role': assignment.role,
                    'assigned_at': assignment.assigned_at,
                    'id': f"emp_{assignment.employee_id}"
                })
        
        # Get ALL available staff and employees for assignment
        # Get all Users (Staff)
            all_users = User.query.all()
        
        # Get all Employees
            all_employees = Employee.query.all()
        
        # Create a combined list with type identification
            available_staff = []
        
        # Add all users (existing logic - show as available even if assigned)
            for user in all_users:
                is_assigned = any(assignment['id'] == user.id for assignment in all_assignments)
            
                available_staff.append({
                    'id': user.id,
                    'name': user.name,
                    'email': user.email,
                    'role': user.role,
                    'type': 'user',
                    'display_info': f"{user.role} | {user.email}",
                    'is_assigned': is_assigned
                })
        
        # Add all employees with unique negative IDs to avoid conflicts
            for employee in all_employees:
                employee_id = f"emp_{employee.id}"
                is_assigned = any(assignment['id'] == employee_id for assignment in all_assignments)
            
                available_staff.append({
                    'id': employee_id,  # Prefix to distinguish from users
                    'name': employee.name,
                    'email': employee.email or 'No email',
                    'role': employee.role or employee.position or 'Employee',
                    'type': 'employee',
                    'display_info': f"{employee.department or 'No Dept'} | {employee.role or employee.position or 'Employee'}",
                    'is_assigned': is_assigned,
                    'staff_code': employee.staff_code,
                    'department': employee.department
                })
        
        # Get milestones with status counts
            milestones = Milestone.query.filter_by(project_id=project_id).all()
            completed_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Completed']
            pending_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Pending']
            overdue_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Pending' and hasattr(m, 'due_date') and m.due_date and m.due_date < datetime.now().date()]
        
        # Get schedules if they exist
            schedules = Schedule.query.filter_by(project_id=project_id).all() if hasattr(Schedule, 'project_id') else []
        
        # Get tasks for the project
            tasks = Task.query.filter_by(project_id=project_id).all()
            completed_tasks = [t for t in tasks if hasattr(t, 'status') and t.status == 'completed']
        
        # Calculate project metrics
            progress = project.progress or 0
            if milestones:
                milestone_progress = (len(completed_milestones) / len(milestones)) * 100
            # Use milestone progress if it differs significantly from stored progress
                if abs(milestone_progress - progress) > 5:
                    progress = milestone_progress
        
        # Budget calculations
            total_budget = project.budget or 0
        # Get total expenses for this project (if expense model has project_id)
            project_expenses = []
            if hasattr(Expense, 'project_id'):
                project_expenses = Expense.query.filter_by(project_id=project_id).all()
            elif hasattr(Expense, 'user_id'):
            # Fallback: if expenses are linked to users instead of projects
                assigned_user_ids = [assignment.staff_id for assignment, _ in staff_assignments]
                if assigned_user_ids:
                    project_expenses = Expense.query.filter(Expense.user_id.in_(assigned_user_ids)).all()
        
            spent_amount = sum(expense.amount for expense in project_expenses if hasattr(expense, 'amount'))
            remaining_budget = total_budget - spent_amount
            budget_utilization = (spent_amount / total_budget * 100) if total_budget > 0 else 0
        
        # Timeline calculations
            is_overdue = False
            days_remaining = None
            if project.end_date:
                today = datetime.now().date()
                if project.end_date < today:
                    is_overdue = True
                    days_remaining = (today - project.end_date).days
                else:
                    days_remaining = (project.end_date - today).days
        
        # Team statistics (combine both user and employee assignments)
            team_size = len(all_assignments)
            team_roles = {}
            for assignment_data in all_assignments:
                role = assignment_data['role'] or 'Unknown'
                if role in team_roles:
                    team_roles[role] += 1
                else:
                    team_roles[role] = 1
        
        # Project health calculation
            health_status = "Good"
            if is_overdue or budget_utilization > 90:
                health_status = "Critical"
            elif progress < 50 and days_remaining and days_remaining < 30:
                health_status = "Warning"
            elif len(overdue_milestones) > 0:
                health_status = "Warning"
        
        # Recent activity (last 3 milestones or tasks)
            recent_milestones = []
            if milestones:
                recent_milestones = sorted([m for m in milestones if hasattr(m, 'due_date') and m.due_date], 
                                         key=lambda x: x.due_date, reverse=True)[:3]
        
            recent_tasks = []
            if tasks:
                recent_tasks = sorted([t for t in tasks if hasattr(t, 'updated_at') and t.updated_at], 
                                    key=lambda x: x.updated_at, reverse=True)[:3]
        
        # BOQ calculations
            boq_items = []
            total_boq_cost = 0
            try:
                boq_items = BOQItem.query.filter_by(project_id=project_id, is_template=False).all()
                total_boq_cost = sum(item.total_cost for item in boq_items if hasattr(item, 'total_cost') and item.total_cost)
            except Exception as boq_error:
                current_app.logger.warning(f"BOQ query error: {str(boq_error)}")

        # Material Schedule calculations
            material_schedules = []
            total_material_cost = 0
            try:
                material_schedules = MaterialSchedule.query.filter_by(project_id=project_id).all()
                total_material_cost = sum(item.total_cost for item in material_schedules if hasattr(item, 'total_cost') and item.total_cost)
            except Exception as material_error:
                current_app.logger.warning(f"Material Schedule query error: {str(material_error)}")

        # Get documents and activity log safely
            documents = []
            activity_log = []
            try:
                documents = ProjectDocument.query.filter_by(project_id=project_id).all()
            except Exception as doc_error:
                current_app.logger.warning(f"Document query error: {str(doc_error)}")
        
            try:
                activity_log = ProjectActivity.query.filter_by(project_id=project_id).order_by(ProjectActivity.created_at.desc()).limit(10).all()
            except Exception as activity_error:
                current_app.logger.warning(f"Activity query error: {str(activity_error)}")

            return render_template('admin/view_project.html',
                                 project=project,
                                 staff_assignments=all_assignments,
                                 available_staff=available_staff,
                                 milestones=milestones,
                                 schedules=schedules,
                                 tasks=tasks,
                             # Metrics
                                 progress=round(progress, 1),
                                 milestone_count=len(milestones),
                                 completed_milestones=len(completed_milestones),
                                 pending_milestones=len(pending_milestones),
                                 overdue_milestones=len(overdue_milestones),
                                 task_count=len(tasks),
                                 completed_tasks=len(completed_tasks),
                             # Budget
                                 total_budget=total_budget,
                                 spent_amount=spent_amount,
                                 remaining_budget=remaining_budget,
                                 budget_utilization=round(budget_utilization, 1),
                             # Timeline
                                 is_overdue=is_overdue,
                                 days_remaining=days_remaining,
                             # Team
                                 team_size=team_size,
                                 team_roles=team_roles,
                             # Health
                                 health_status=health_status,
                             # Recent activity
                                 recent_milestones=recent_milestones,
                                 recent_tasks=recent_tasks,
                             # Additional data for enhanced template
                                 boq_items=boq_items,
                                 total_boq_cost=total_boq_cost,
                                 material_schedules=material_schedules,
                                 total_material_cost=total_material_cost,
                                 documents=documents,
                                 activity_log=activity_log)
        except Exception as e:
            current_app.logger.error(f"Admin project details error: {str(e)}", exc_info=True)
            current_app.logger.error(f"Error type: {type(e).__name__}")
            current_app.logger.error(f"Error args: {e.args}")
            flash(f"Error loading project details: {str(e)}", "error")
            return redirect(url_for('admin.projects'))


# ===== ENHANCED PROJECT MANAGEMENT ROUTES =====

    @app.route('/admin/projects/<int:project_id>/assign_staff', methods=['POST'], endpoint='admin.assign_staff_new')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def assign_staff_new(project_id):
        """Enhanced staff assignment endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            staff_id = request.form.get('staff_id')
            role = request.form.get('role')
        
            if not staff_id or not role:
                flash('Staff ID and role are required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Handle employee IDs (prefixed with 'emp_')
            if str(staff_id).startswith('emp_'):
            # This is an employee from HR database
                employee_id = str(staff_id).replace('emp_', '')
                employee = Employee.query.get(employee_id)
            
                if not employee:
                    flash('Employee not found', 'error')
                    return redirect(url_for('admin.project_details', project_id=project_id))
            
            # Check if employee is already assigned
                existing_assignment = EmployeeAssignment.query.filter_by(
                    project_id=project_id, 
                    employee_id=employee_id
                ).first()
            
                if existing_assignment:
                    flash('Employee is already assigned to this project', 'warning')
                    return redirect(url_for('admin.project_details', project_id=project_id))
            
            # Create new employee assignment
                assignment = EmployeeAssignment(
                    project_id=project_id,
                    employee_id=employee_id,
                    role=role,
                    assigned_at=datetime.now(timezone.utc),
                    assigned_by=current_user.id,
                    status='Active'
                )
            
                db.session.add(assignment)
            
            # Log activity
                activity = ProjectActivity(
                    project_id=project_id,
                    user_id=current_user.id,
                    action_type='employee_assigned',
                    description=f'{employee.name} was assigned as {role}',
                    user_name=current_user.name
                )
                db.session.add(activity)
            
                db.session.commit()
            
                flash(f'{employee.name} has been assigned as {role}', 'success')
                return redirect(url_for('admin.project_details', project_id=project_id))
            
            else:
            # This is a regular user
            # Check if staff is already assigned
                existing_assignment = StaffAssignment.query.filter_by(
                    project_id=project_id, 
                    staff_id=staff_id
                ).first()
            
                if existing_assignment:
                    flash('Staff member is already assigned to this project', 'warning')
                    return redirect(url_for('admin.project_details', project_id=project_id))
            
            # Get staff member details
                staff_member = User.query.get(staff_id)
                if not staff_member:
                    flash('Staff member not found', 'error')
                    return redirect(url_for('admin.project_details', project_id=project_id))
            
            # Create new assignment for user
                assignment = StaffAssignment(
                    project_id=project_id,
                    staff_id=staff_id,
                    role=role,
                    assigned_at=datetime.now(timezone.utc)
                )
            
                db.session.add(assignment)
            
            # Log activity
                activity = ProjectActivity(
                    project_id=project_id,
                    user_id=current_user.id,
                    action_type='staff_assigned',
                    description=f'{staff_member.name} was assigned as {role}',
                    user_name=current_user.name
                )
                db.session.add(activity)
            
                db.session.commit()
            
                flash(f'{staff_member.name} has been assigned as {role}', 'success')
            
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error assigning staff: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while assigning staff', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/remove_staff', methods=['POST'], endpoint='admin.remove_staff_new')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def remove_staff_new(project_id):
        """Enhanced staff removal endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
        # Try JSON first, then form data
            data = request.get_json() or request.form
            staff_id = data.get('staff_id')
        
            if not staff_id:
                flash('Staff ID is required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Find and remove assignment
            assignment = StaffAssignment.query.filter_by(
                project_id=project_id,
                staff_id=staff_id
            ).first()
        
            if not assignment:
                flash('Staff assignment not found', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Get staff member details for logging
            staff_member = User.query.get(staff_id)
            staff_name = staff_member.name if staff_member else 'Unknown'
            role = assignment.role
        
            db.session.delete(assignment)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='staff_removed',
                description=f'{staff_name} was removed from {role} role',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'{staff_name} has been removed from the project', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error removing staff: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while removing staff', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/add_milestone', methods=['POST'], endpoint='admin.add_milestone_new')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def add_milestone_new(project_id):
        """Enhanced milestone creation endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            milestone_name = request.form.get('milestone_name')
            milestone_description = request.form.get('milestone_description', '')
            due_date_str = request.form.get('due_date')
        
            if not milestone_name or not due_date_str:
                flash('Milestone name and due date are required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Parse due date
            try:
                due_date = datetime.strptime(due_date_str, '%Y-%m-%d').date()
            except ValueError:
                flash('Invalid date format', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Create new milestone
            milestone = Milestone(
                project_id=project_id,
                title=milestone_name,
                due_date=due_date,
                status='Pending'
            )
        
        # Add description if Milestone model supports it
            if hasattr(milestone, 'description'):
                milestone.description = milestone_description
        
            db.session.add(milestone)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='milestone_added',
                description=f'Milestone "{milestone_name}" was created with due date {due_date.strftime("%B %d, %Y")}',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Milestone "{milestone_name}" has been created', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error adding milestone: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while adding milestone', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/milestones/<int:milestone_id>', methods=['POST', 'DELETE'], endpoint='admin.delete_milestone_new')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def delete_milestone_new(project_id, milestone_id):
        """Enhanced milestone deletion endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            milestone = Milestone.query.filter_by(id=milestone_id, project_id=project_id).first()
        
            if not milestone:
                flash('Milestone not found', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            milestone_title = milestone.title
            db.session.delete(milestone)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='milestone_deleted',
                description=f'Milestone "{milestone_title}" was deleted',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Milestone "{milestone_title}" has been deleted', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error deleting milestone: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while deleting milestone', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/add_boq_item', methods=['POST'], endpoint='admin.add_boq_item')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def add_boq_item(project_id):
        """Add BOQ (Bill of Quantities) item endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            item_description = request.form.get('item_description')
            quantity = request.form.get('quantity')
            unit = request.form.get('unit')
            unit_price = request.form.get('unit_price')
        
            if not all([item_description, quantity, unit, unit_price]):
                return jsonify({'success': False, 'message': 'All fields are required'}), 400
        
            try:
                quantity = float(quantity)
                unit_price = float(unit_price)
                total_cost = quantity * unit_price
            except ValueError:
                return jsonify({'success': False, 'message': 'Invalid numeric values'}), 400
        
        # Create new BOQ item
            boq_item = BOQItem(
                project_id=project_id,
                item_description=item_description,
                quantity=quantity,
                unit=unit,
                unit_price=unit_price,
                total_cost=total_cost
            )
        
            db.session.add(boq_item)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_added',
                description=f'BOQ item "{item_description}" was added ({total_cost:,.2f})',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            return jsonify({
                'success': True,
                'message': f'BOQ item "{item_description}" has been added'
            })
        
        except Exception as e:
            current_app.logger.error(f"Error adding BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': 'An error occurred while adding BOQ item'}), 500


    @app.route('/admin/projects/<int:project_id>/boq_items/<int:item_id>', methods=['DELETE'], endpoint='admin.delete_boq_item')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def delete_boq_item(project_id, item_id):
        """Delete BOQ item endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            boq_item = BOQItem.query.filter_by(id=item_id, project_id=project_id).first()
        
            if not boq_item:
                return jsonify({'success': False, 'message': 'BOQ item not found'}), 404
        
            item_description = boq_item.item_description
            db.session.delete(boq_item)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_deleted',
                description=f'BOQ item "{item_description}" was deleted',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            return jsonify({
                'success': True,
                'message': f'BOQ item "{item_description}" has been deleted'
            })
        
        except Exception as e:
            current_app.logger.error(f"Error deleting BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': 'An error occurred while deleting BOQ item'}), 500


    @app.route('/admin/projects/<int:project_id>/upload_document', methods=['POST'], endpoint='admin.upload_document')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def upload_document(project_id):
        """Enhanced document upload endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            if 'document_file' not in request.files:
                flash('No file selected', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            file = request.files['document_file']
            document_type = request.form.get('document_type')
            description = request.form.get('document_description', '')
        
            if file.filename == '':
                flash('No file selected', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            if not document_type:
                flash('Document type is required', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Validate file type
            allowed_extensions = {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'png', 'jpg', 'jpeg'}
            if not ('.' in file.filename and file.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
                flash('File type not allowed', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Create uploads directory if it doesn't exist
            upload_folder = os.path.join(current_app.root_path, 'uploads', 'projects', str(project_id))
            os.makedirs(upload_folder, exist_ok=True)
        
        # Generate secure filename
            filename = secure_filename(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_')
            unique_filename = timestamp + filename
            file_path = os.path.join(upload_folder, unique_filename)
        
        # Save file
            file.save(file_path)
            file_size = os.path.getsize(file_path)
        
        # Create document record
            document = ProjectDocument(
                project_id=project_id,
                filename=unique_filename,
                original_filename=filename,
                document_type=document_type,
                description=description,
                file_size=file_size,
                file_path=file_path,
                uploader_id=current_user.id,
                uploader_name=current_user.name
            )
        
            db.session.add(document)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='document_uploaded',
                description=f'Document "{filename}" was uploaded ({document_type})',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Document "{filename}" has been uploaded successfully', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error uploading document: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while uploading document', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/documents/<int:document_id>/download', endpoint='admin.download_document')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def download_document(project_id, document_id):
        """Enhanced document download endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            document = ProjectDocument.query.filter_by(id=document_id, project_id=project_id).first()
        
            if not document:
                flash('Document not found', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            if not os.path.exists(document.file_path):
                flash('File not found on disk', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
            return send_file(
                document.file_path,
                as_attachment=True,
                download_name=document.original_filename,
                mimetype='application/octet-stream'
            )
        
        except Exception as e:
            current_app.logger.error(f"Error downloading document: {str(e)}", exc_info=True)
            flash('An error occurred while downloading the document', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/documents/<int:document_id>', methods=['POST', 'DELETE'], endpoint='admin.delete_document')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def delete_document(project_id, document_id):
        """Enhanced document deletion endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            document = ProjectDocument.query.filter_by(id=document_id, project_id=project_id).first()
        
            if not document:
                flash('Document not found', 'error')
                return redirect(url_for('admin.project_details', project_id=project_id))
        
        # Delete file from disk
            if os.path.exists(document.file_path):
                os.remove(document.file_path)
        
            document_name = document.original_filename
            db.session.delete(document)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='document_deleted',
                description=f'Document "{document_name}" was deleted',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Document "{document_name}" has been deleted', 'success')
            return redirect(url_for('admin.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error deleting document: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while deleting document', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/update_progress', methods=['POST'], endpoint='admin.update_progress_new')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def update_progress_new(project_id):
        """Enhanced progress update endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            data = request.get_json()
            progress = data.get('progress')
        
            if progress is None:
                return jsonify({'success': False, 'message': 'Progress value is required'}), 400
        
            try:
                progress = float(progress)
                if progress < 0 or progress > 100:
                    return jsonify({'success': False, 'message': 'Progress must be between 0 and 100'}), 400
            except ValueError:
                return jsonify({'success': False, 'message': 'Invalid progress value'}), 400
        
            old_progress = project.progress or 0
            project.progress = progress
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='progress_updated',
                description=f'Project progress updated from {old_progress}% to {progress}%',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            return jsonify({
                'success': True,
                'message': f'Project progress updated to {progress}%'
            })
        
        except Exception as e:
            current_app.logger.error(f"Error updating progress: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': 'An error occurred while updating progress'}), 500


    @app.route('/admin/projects/<int:project_id>/update_material_status', methods=['POST'], endpoint='admin.update_material_status')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def update_material_status(project_id):
        """Update material/BOQ item status for project scheduling"""
        try:
            project = Project.query.get_or_404(project_id)
            
            data = request.get_json()
            item_id = data.get('item_id')
            new_status = data.get('status')
            
            if not item_id or not new_status:
                return jsonify({'success': False, 'message': 'Item ID and status are required'}), 400
            
            # Validate status
            valid_statuses = ['Pending', 'Ordered', 'Delivered', 'Used']
            if new_status not in valid_statuses:
                return jsonify({'success': False, 'message': f'Invalid status. Must be one of: {", ".join(valid_statuses)}'}), 400
            
            # Find and update BOQ item
            boq_item = BOQItem.query.filter_by(id=item_id, project_id=project_id).first()
            if not boq_item:
                return jsonify({'success': False, 'message': 'BOQ item not found'}), 404
            
            old_status = boq_item.status or 'Pending'
            boq_item.status = new_status
            
            # Log the material status change activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='material_status_updated',
                description=f'Material "{boq_item.item_description}" status changed from {old_status} to {new_status}',
                user_name=current_user.name
            )
            db.session.add(activity)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'Material status updated to {new_status}',
                'item_id': item_id,
                'new_status': new_status
            })
            
        except Exception as e:
            current_app.logger.error(f"Error updating material status: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': 'An error occurred while updating material status'}), 500


    @app.route('/admin/projects/<int:project_id>/edit', methods=['GET', 'POST'], endpoint='admin.edit_project')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def edit_project(project_id):
        """Edit project information endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            if request.method == 'GET':
            # Return project data for modal/form population
                project_data = {
                    'id': project.id,
                    'name': project.name,
                    'description': project.description,
                    'start_date': project.start_date.isoformat() if project.start_date else None,
                    'end_date': project.end_date.isoformat() if project.end_date else None,
                    'status': project.status,
                    'project_manager': project.project_manager,
                    'budget': project.budget,
                    'project_type': project.project_type,
                    'priority': project.priority,
                    'client_name': project.client_name,
                    'site_location': project.site_location,
                    'funding_source': project.funding_source,
                    'risk_level': project.risk_level,
                    'safety_requirements': project.safety_requirements,
                    'regulatory_requirements': project.regulatory_requirements
                }
                return jsonify({'success': True, 'project': project_data})
        
            elif request.method == 'POST':
            # Handle project update
                data = request.get_json() or request.form
            
            # Store old values for activity log
                changes = []
            
            # Update fields if provided
                if 'name' in data and data['name'] != project.name:
                    changes.append(f"Name changed from '{project.name}' to '{data['name']}'")
                    project.name = data['name']
            
                if 'description' in data and data['description'] != project.description:
                    changes.append(f"Description updated")
                    project.description = data['description']
            
                if 'start_date' in data:
                    new_start = datetime.strptime(data['start_date'], '%Y-%m-%d').date() if data['start_date'] else None
                    if new_start != project.start_date:
                        changes.append(f"Start date changed to {new_start.strftime('%B %d, %Y') if new_start else 'None'}")
                        project.start_date = new_start
            
                if 'end_date' in data:
                    new_end = datetime.strptime(data['end_date'], '%Y-%m-%d').date() if data['end_date'] else None
                    if new_end != project.end_date:
                        changes.append(f"End date changed to {new_end.strftime('%B %d, %Y') if new_end else 'None'}")
                        project.end_date = new_end
            
                if 'status' in data and data['status'] != project.status:
                    changes.append(f"Status changed from '{project.status}' to '{data['status']}'")
                    project.status = data['status']
            
                if 'project_manager' in data and data['project_manager'] != project.project_manager:
                    changes.append(f"Project manager changed to '{data['project_manager']}'")
                    project.project_manager = data['project_manager']
            
                if 'budget' in data:
                    try:
                        new_budget = float(data['budget'])
                        if new_budget != project.budget:
                            changes.append(f"Budget changed from {project.budget:,.2f} to {new_budget:,.2f}")
                            project.budget = new_budget
                    except ValueError:
                        return jsonify({'success': False, 'message': 'Invalid budget value'}), 400
            
                if 'project_type' in data and data['project_type'] != project.project_type:
                    changes.append(f"Project type changed to '{data['project_type']}'")
                    project.project_type = data['project_type']
            
                if 'priority' in data and data['priority'] != project.priority:
                    changes.append(f"Priority changed to '{data['priority']}'")
                    project.priority = data['priority']
            
                if 'client_name' in data and data['client_name'] != project.client_name:
                    changes.append(f"Client name changed to '{data['client_name']}'")
                    project.client_name = data['client_name']
            
                if 'site_location' in data and data['site_location'] != project.site_location:
                    changes.append(f"Site location updated")
                    project.site_location = data['site_location']
            
                if 'funding_source' in data and data['funding_source'] != project.funding_source:
                    changes.append(f"Funding source changed to '{data['funding_source']}'")
                    project.funding_source = data['funding_source']
            
                if 'risk_level' in data and data['risk_level'] != project.risk_level:
                    changes.append(f"Risk level changed to '{data['risk_level']}'")
                    project.risk_level = data['risk_level']
            
                if 'safety_requirements' in data and data['safety_requirements'] != project.safety_requirements:
                    changes.append(f"Safety requirements changed to '{data['safety_requirements']}'")
                    project.safety_requirements = data['safety_requirements']
            
                if 'regulatory_requirements' in data and data['regulatory_requirements'] != project.regulatory_requirements:
                    changes.append(f"Regulatory requirements updated")
                    project.regulatory_requirements = data['regulatory_requirements']
            
            # Update the updated_at timestamp
                project.updated_at = datetime.now(timezone.utc)
            
            # Log activities for changes
                if changes:
                    activity = ProjectActivity(
                        project_id=project_id,
                        user_id=current_user.id,
                        action_type='project_updated',
                        description=f'Project updated: {"; ".join(changes)}',
                        user_name=current_user.name
                    )
                    db.session.add(activity)
                
                    db.session.commit()
                
                    return jsonify({
                        'success': True, 
                        'message': 'Project updated successfully',
                        'changes': len(changes)
                    })
                else:
                    return jsonify({'success': True, 'message': 'No changes made'})
        
        except Exception as e:
            current_app.logger.error(f"Error editing project: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/load_boq_templates', methods=['POST'], endpoint='admin.load_boq_templates')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def load_boq_templates(project_id):
        """Load BOQ templates based on project type"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            project_type = data.get('project_type', project.project_type)
            
            if not project_type:
                return jsonify({'success': False, 'message': 'Project type is required'}), 400
            
            # Determine BOQ template types based on project type
            if 'Bridge' in project_type:
                item_types = ['Bridge']
            elif 'Building' in project_type:
                item_types = ['Building']
            elif 'Road' in project_type:
                item_types = ['Road']
            elif 'Culvert' in project_type:
                item_types = ['Culvert']
            else:
                item_types = [project_type]
            
            # Load template items from database with optimized query
            template_items = BOQItem.query.filter(
                BOQItem.is_template == True,
                BOQItem.item_type.in_(item_types)
            ).all()
            
            if not template_items:
                return jsonify({'success': False, 'message': f'No BOQ templates found for {project_type}'}), 404
            
            # Get existing item descriptions in one query to avoid multiple database calls
            existing_descriptions = set([
                item.item_description for item in 
                BOQItem.query.filter_by(project_id=project_id, is_template=False).with_entities(BOQItem.item_description).all()
            ])
            
            # Prepare new items for bulk insert
            new_items = []
            for template in template_items:
                if template.item_description not in existing_descriptions:
                    new_item = BOQItem(
                        project_id=project_id,
                        item_description=template.item_description,
                        quantity=template.quantity,
                        unit=template.unit,
                        unit_price=template.unit_price,
                        total_cost=template.total_cost,
                        item_type=template.item_type,
                        category=template.category,
                        bill_no=template.bill_no,
                        item_no=template.item_no,
                        status='Pending',
                        is_template=False  # Project items are not templates
                    )
                    new_items.append(new_item)
            
            # Bulk insert new items
            if new_items:
                db.session.add_all(new_items)
            
            items_added = len(new_items)
            
            # Log activity
            if items_added > 0:
                activity = ProjectActivity(
                    project_id=project_id,
                    user_id=current_user.id,
                    action_type='boq_templates_loaded',
                    description=f'Loaded {items_added} BOQ template items for {project_type}',
                    user_name=current_user.name
                )
                db.session.add(activity)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'Loaded {items_added} BOQ template items',
                'items_added': items_added
            })
            
        except Exception as e:
            current_app.logger.error(f"Error loading BOQ templates: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500

    @app.route('/admin/projects/<int:project_id>/load_material_templates', methods=['POST'], endpoint='admin.load_material_templates')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def load_material_templates(project_id):
        """Load Material Schedule templates using raw SQL to bypass model constraints"""
        try:
            # Get project to verify it exists
            project = Projects.query.get_or_404(project_id)
            
            # Use raw SQL to get template materials (project_id IS NULL)
            with db.engine.connect() as connection:
                result = connection.execute(text("""
                    SELECT id, material_name, specification, required_qty, unit, 
                           unit_cost, total_cost, status, supplier_name, supplier_contact
                    FROM material_schedules 
                    WHERE project_id IS NULL
                    ORDER BY material_name
                """))
                
                template_materials = result.fetchall()
                
                if not template_materials:
                    return jsonify({'success': False, 'message': 'No material templates found'}), 404
                
                items_added = 0
                for template in template_materials:
                    # Create new material schedule item for the project
                    new_material = MaterialSchedule(
                        project_id=project_id,
                        material_name=template.material_name,
                        specification=template.specification,
                        required_qty=float(template.required_qty),
                        ordered_qty=0.0,
                        received_qty=0.0,
                        used_qty=0.0,
                        unit=template.unit,
                        unit_cost=float(template.unit_cost),
                        total_cost=float(template.total_cost),
                        status=template.status or 'Planned',
                        supplier_name=template.supplier_name,
                        supplier_contact=template.supplier_contact
                    )
                    
                    try:
                        db.session.add(new_material)
                        items_added += 1
                    except Exception as item_error:
                        current_app.logger.warning(f"Skipping duplicate material: {template.material_name}")
                        continue
                
                if items_added > 0:
                    db.session.commit()
                    current_app.logger.info(f"Loaded {items_added} material template items for project {project_id}")
                
                return jsonify({
                    'success': True,
                    'message': f'Loaded {items_added} material template items',
                    'items_added': items_added
                })
                
        except Exception as e:
            current_app.logger.error(f"Error loading material templates: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    # Template caching for faster loading
    _template_cache = {}
    
    @app.route('/admin/projects/<int:project_id>/get_boq_templates', methods=['POST'], endpoint='admin.get_boq_templates')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def get_boq_templates(project_id):
        """Get BOQ templates for caching (without adding to project)"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            project_type = data.get('project_type')
            
            if not project_type:
                return jsonify({'success': False, 'message': 'Project type is required'}), 400
            
            # Check cache first
            cache_key = f"templates_{project_type}"
            if cache_key in _template_cache:
                current_app.logger.info(f"Serving {project_type} templates from cache")
                return jsonify({
                    'success': True,
                    'templates': _template_cache[cache_key],
                    'cached': True
                })
            
            # Determine BOQ template types based on project type
            if 'Bridge' in project_type:
                item_types = ['Bridge']
            elif 'Building' in project_type:
                item_types = ['Building']
            elif 'Road' in project_type:
                item_types = ['Road']
            elif 'Culvert' in project_type:
                item_types = ['Culvert']
            else:
                item_types = [project_type]
            
            # Load template items from database
            template_items = BOQItem.query.filter(
                BOQItem.is_template == True,
                BOQItem.item_type.in_(item_types)
            ).all()
            
            if not template_items:
                return jsonify({'success': False, 'message': f'No BOQ templates found for {project_type}'}), 404
            
            # Convert to serializable format
            templates_data = []
            for template in template_items:
                templates_data.append({
                    'id': template.id,
                    'item_description': template.item_description,
                    'quantity': template.quantity,
                    'unit': template.unit,
                    'unit_price': template.unit_price,
                    'total_cost': template.total_cost,
                    'item_type': template.item_type,
                    'category': template.category,
                    'bill_no': template.bill_no,
                    'item_no': template.item_no
                })
            
            # Cache the templates
            _template_cache[cache_key] = templates_data
            current_app.logger.info(f"Cached {len(templates_data)} templates for {project_type}")
            
            return jsonify({
                'success': True,
                'templates': templates_data,
                'cached': False
            })
            
        except Exception as e:
            current_app.logger.error(f"Error fetching BOQ templates: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/import_boq', methods=['POST'], endpoint='admin.import_boq')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def import_boq(project_id):
        """Import BOQ data from Excel/CSV file"""
        try:
            project = Project.query.get_or_404(project_id)
            
            if 'boq_file' not in request.files:
                return jsonify({'success': False, 'message': 'No file uploaded'}), 400
            
            file = request.files['boq_file']
            if file.filename == '':
                return jsonify({'success': False, 'message': 'No file selected'}), 400
            
            # Read the file using pandas
            try:
                if file.filename.endswith('.csv'):
                    df = pd.read_csv(file)
                elif file.filename.endswith(('.xlsx', '.xls')):
                    df = pd.read_excel(file)
                else:
                    return jsonify({'success': False, 'message': 'Unsupported file format. Use CSV or Excel files'}), 400
            except Exception as read_error:
                return jsonify({'success': False, 'message': f'Error reading file: {str(read_error)}'}), 400
            
            # Validate required columns
            required_columns = ['item_description', 'quantity', 'unit', 'unit_price']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                return jsonify({
                    'success': False, 
                    'message': f'Missing required columns: {", ".join(missing_columns)}'
                }), 400
            
            items_imported = 0
            errors = []
            
            for index, row in df.iterrows():
                try:
                    # Calculate total cost
                    quantity = float(row['quantity']) if pd.notna(row['quantity']) else 0
                    unit_price = float(row['unit_price']) if pd.notna(row['unit_price']) else 0
                    total_cost = quantity * unit_price
                    
                    new_item = BOQItem(
                        project_id=project_id,
                        item_description=str(row['item_description']),
                        quantity=quantity,
                        unit=str(row['unit']) if pd.notna(row['unit']) else 'unit',
                        unit_price=unit_price,
                        total_cost=total_cost,
                        item_type=str(row.get('item_type', project.project_type or 'General')),
                        category=str(row.get('category', '')) if pd.notna(row.get('category')) else None,
                        bill_no=str(row.get('bill_no', '')) if pd.notna(row.get('bill_no')) else None,
                        item_no=str(row.get('item_no', '')) if pd.notna(row.get('item_no')) else None,
                        status='Pending',
                        is_template=False  # Imported items are not templates
                    )
                    db.session.add(new_item)
                    items_imported += 1
                    
                except Exception as row_error:
                    errors.append(f"Row {index + 1}: {str(row_error)}")
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_imported',
                description=f'Imported {items_imported} BOQ items from {file.filename}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            result = {
                'success': True,
                'message': f'Successfully imported {items_imported} BOQ items',
                'items_imported': items_imported
            }
            
            if errors:
                result['warnings'] = errors[:10]  # Limit error messages
                
            return jsonify(result)
            
        except Exception as e:
            current_app.logger.error(f"Error importing BOQ: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/import_materials', methods=['POST'], endpoint='admin.import_materials')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def import_materials(project_id):
        """Import material schedule from Excel/CSV file"""
        try:
            project = Project.query.get_or_404(project_id)
            
            if 'material_file' not in request.files:
                return jsonify({'success': False, 'message': 'No file uploaded'}), 400
            
            file = request.files['material_file']
            if file.filename == '':
                return jsonify({'success': False, 'message': 'No file selected'}), 400
            
            # Read the file using pandas
            try:
                if file.filename.endswith('.csv'):
                    df = pd.read_csv(file)
                elif file.filename.endswith(('.xlsx', '.xls')):
                    df = pd.read_excel(file)
                else:
                    return jsonify({'success': False, 'message': 'Unsupported file format. Use CSV or Excel files'}), 400
            except Exception as read_error:
                return jsonify({'success': False, 'message': f'Error reading file: {str(read_error)}'}), 400
            
            # Validate required columns
            required_columns = ['material_name', 'required_qty', 'unit', 'unit_cost']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                return jsonify({
                    'success': False, 
                    'message': f'Missing required columns: {", ".join(missing_columns)}'
                }), 400
            
            items_imported = 0
            errors = []
            
            for index, row in df.iterrows():
                try:
                    # Calculate total cost
                    required_qty = float(row['required_qty']) if pd.notna(row['required_qty']) else 0
                    unit_cost = float(row['unit_cost']) if pd.notna(row['unit_cost']) else 0
                    total_cost = required_qty * unit_cost
                    
                    new_material = MaterialSchedule(
                        project_id=project_id,
                        material_name=str(row['material_name']),
                        required_qty=required_qty,
                        unit=str(row['unit']) if pd.notna(row['unit']) else 'unit',
                        unit_cost=unit_cost,
                        total_cost=total_cost,
                        specification=str(row.get('specification', '')),
                        status=str(row.get('status', 'Planned')),
                        supplier_name=str(row.get('supplier_name', '')),
                        supplier_contact=str(row.get('supplier_contact', ''))
                    )
                    db.session.add(new_material)
                    items_imported += 1
                    
                except Exception as row_error:
                    errors.append(f"Row {index + 1}: {str(row_error)}")
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='materials_imported',
                description=f'Imported {items_imported} material items from {file.filename}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            result = {
                'success': True,
                'message': f'Successfully imported {items_imported} material items',
                'items_imported': items_imported
            }
            
            if errors:
                result['warnings'] = errors[:10]  # Limit error messages
                
            return jsonify(result)
            
        except Exception as e:
            current_app.logger.error(f"Error importing materials: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/update_boq_item', methods=['POST'], endpoint='admin.update_boq_item_inline')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def update_boq_item_inline(project_id):
        """Update a single BOQ item"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            
            item_id = data.get('item_id')
            updates = data.get('updates', {})
            
            if not item_id:
                return jsonify({'success': False, 'message': 'Item ID is required'}), 400
            
            boq_item = BOQItem.query.filter_by(id=item_id, project_id=project_id).first()
            if not boq_item:
                return jsonify({'success': False, 'message': 'BOQ item not found'}), 404
            
            # Apply updates
            for field, value in updates.items():
                if hasattr(boq_item, field):
                    if field in ['quantity', 'unit_price']:
                        try:
                            setattr(boq_item, field, float(value))
                        except (ValueError, TypeError):
                            return jsonify({'success': False, 'message': f'Invalid {field} value'}), 400
                    else:
                        setattr(boq_item, field, value)
            
            # Recalculate total cost
            if boq_item.quantity and boq_item.unit_price:
                boq_item.total_cost = boq_item.quantity * boq_item.unit_price
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_updated',
                description=f'Updated BOQ item: {boq_item.item_description}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'BOQ item updated successfully'
            })
            
        except Exception as e:
            current_app.logger.error(f"Error updating BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/delete_boq_item', methods=['POST'], endpoint='admin.delete_boq_item_inline')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def delete_boq_item_inline(project_id):
        """Delete a BOQ item"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            
            item_id = data.get('item_id')
            if not item_id:
                return jsonify({'success': False, 'message': 'Item ID is required'}), 400
            
            boq_item = BOQItem.query.filter_by(id=item_id, project_id=project_id).first()
            if not boq_item:
                return jsonify({'success': False, 'message': 'BOQ item not found'}), 404
            
            item_description = boq_item.item_description
            db.session.delete(boq_item)
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_deleted',
                description=f'Deleted BOQ item: {item_description}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'BOQ item deleted successfully'
            })
            
        except Exception as e:
            current_app.logger.error(f"Error deleting BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/add_boq_item', methods=['POST'], endpoint='admin.add_boq_item_new')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def add_boq_item_new(project_id):
        """Add a new BOQ item"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            
            item_description = data.get('item_description')
            if not item_description:
                return jsonify({'success': False, 'message': 'Item description is required'}), 400
            
            quantity = float(data.get('quantity', 0))
            unit_price = float(data.get('unit_price', 0))
            total_cost = quantity * unit_price
            
            new_item = BOQItem(
                project_id=project_id,
                item_description=item_description,
                quantity=quantity,
                unit=data.get('unit', 'unit'),
                unit_price=unit_price,
                total_cost=total_cost,
                item_type=data.get('item_type', project.project_type or 'General'),
                status='Pending',
                is_template=False  # New BOQ items are not templates
            )
            db.session.add(new_item)
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_added',
                description=f'Added new BOQ item: {item_description}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'BOQ item added successfully'
            })
            
        except Exception as e:
            current_app.logger.error(f"Error adding BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    # Material Schedule Management Endpoints
    @app.route('/admin/projects/<int:project_id>/update_material_item', methods=['POST'], endpoint='admin.update_material_item')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def update_material_item(project_id):
        """Update a material schedule item"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            
            item_id = data.get('item_id')
            field = data.get('field')
            value = data.get('value')
            
            if not all([item_id, field]):
                return jsonify({'success': False, 'message': 'Item ID and field are required'}), 400
            
            material_item = MaterialSchedule.query.filter_by(id=item_id, project_id=project_id).first()
            if not material_item:
                return jsonify({'success': False, 'message': 'Material item not found'}), 404
            
            # Update the field
            if field == 'material_name':
                material_item.material_name = str(value)
            elif field == 'required_qty':
                material_item.required_qty = float(value) if value else 0
                material_item.calculate_total_cost()  # Recalculate total cost
            elif field == 'unit':
                material_item.unit = str(value)
            elif field == 'unit_cost':
                material_item.unit_cost = float(value) if value else 0
                material_item.calculate_total_cost()  # Recalculate total cost
            elif field == 'specification':
                material_item.specification = str(value)
            elif field == 'status':
                material_item.status = str(value)
            elif field == 'supplier_name':
                material_item.supplier_name = str(value)
            elif field == 'supplier_contact':
                material_item.supplier_contact = str(value)
            else:
                return jsonify({'success': False, 'message': f'Invalid field: {field}'}), 400
            
            material_item.updated_at = datetime.now(timezone.utc)
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='material_updated',
                description=f'Updated material {material_item.material_name}: {field} = {value}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Material item updated successfully',
                'total_cost': material_item.total_cost
            })
            
        except Exception as e:
            current_app.logger.error(f"Error updating material item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/delete_material_item', methods=['POST'], endpoint='admin.delete_material_item')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def delete_material_item(project_id):
        """Delete a material schedule item"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            
            item_id = data.get('item_id')
            if not item_id:
                return jsonify({'success': False, 'message': 'Item ID is required'}), 400
            
            material_item = MaterialSchedule.query.filter_by(id=item_id, project_id=project_id).first()
            if not material_item:
                return jsonify({'success': False, 'message': 'Material item not found'}), 404
            
            material_name = material_item.material_name
            db.session.delete(material_item)
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='material_deleted',
                description=f'Deleted material item: {material_name}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Material item deleted successfully'
            })
            
        except Exception as e:
            current_app.logger.error(f"Error deleting material item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/add_material_item', methods=['POST'], endpoint='admin.add_material_item')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def add_material_item(project_id):
        """Add a new material schedule item"""
        try:
            project = Project.query.get_or_404(project_id)
            data = request.get_json()
            
            material_name = data.get('material_name')
            if not material_name:
                return jsonify({'success': False, 'message': 'Material name is required'}), 400
            
            required_qty = float(data.get('required_qty', 0))
            unit_cost = float(data.get('unit_cost', 0))
            total_cost = required_qty * unit_cost
            
            new_material = MaterialSchedule(
                project_id=project_id,
                material_name=material_name,
                required_qty=required_qty,
                unit=data.get('unit', 'unit'),
                unit_cost=unit_cost,
                total_cost=total_cost,
                specification=data.get('specification', ''),
                status='Planned',
                supplier_name=data.get('supplier_name', ''),
                supplier_contact=data.get('supplier_contact', '')
            )
            db.session.add(new_material)
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='material_added',
                description=f'Added new material: {material_name}',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Material item added successfully'
            })
            
        except Exception as e:
            current_app.logger.error(f"Error adding material item: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/generate_material_schedule', methods=['POST'], endpoint='admin.generate_material_schedule')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def generate_material_schedule(project_id):
        """Generate material schedule from BOQ items"""
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get BOQ items for this project
            boq_items = BOQItem.query.filter_by(project_id=project_id, is_template=False).all()
            
            if not boq_items:
                return jsonify({'success': False, 'message': 'No BOQ items found to generate material schedule'}), 400
            
            materials_added = 0
            
            # Generate material schedules based on BOQ items
            for boq_item in boq_items:
                # Check if material already exists
                existing_material = MaterialSchedule.query.filter_by(
                    project_id=project_id,
                    material_name=boq_item.item_description
                ).first()
                
                if not existing_material:
                    new_material = MaterialSchedule(
                        project_id=project_id,
                        material_name=boq_item.item_description,
                        required_qty=boq_item.quantity,
                        unit=boq_item.unit,
                        unit_cost=boq_item.unit_price,
                        total_cost=boq_item.total_cost,
                        specification=f"Generated from BOQ: {boq_item.item_type}",
                        status='Planned'
                    )
                    db.session.add(new_material)
                    materials_added += 1
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='material_schedule_generated',
                description=f'Generated material schedule from BOQ items: {materials_added} materials created',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'Generated {materials_added} material items from BOQ',
                'materials_added': materials_added
            })
            
        except Exception as e:
            current_app.logger.error(f"Error generating material schedule: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/export_material_schedule', methods=['GET'], endpoint='admin.export_material_schedule')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def export_material_schedule(project_id):
        """Export material schedule to Excel"""
        try:
            project = Project.query.get_or_404(project_id)
            material_schedules = MaterialSchedule.query.filter_by(project_id=project_id).all()
            
            if not material_schedules:
                return jsonify({'success': False, 'message': 'No material schedule items to export'}), 400
            
            # Create Excel file
            output = BytesIO()
            workbook = xlsxwriter.Workbook(output, {'in_memory': True})
            worksheet = workbook.add_worksheet('Material Schedule')
            
            # Headers
            headers = [
                'Material Name', 'Required Qty', 'Unit', 'Unit Cost', 'Total Cost',
                'Specification', 'Status', 'Supplier Name', 'Supplier Contact',
                'Required Date', 'Delivery Date'
            ]
            
            # Write headers
            for col, header in enumerate(headers):
                worksheet.write(0, col, header)
            
            # Write data
            for row, material in enumerate(material_schedules, start=1):
                worksheet.write(row, 0, material.material_name)
                worksheet.write(row, 1, material.required_qty or 0)
                worksheet.write(row, 2, material.unit or '')
                worksheet.write(row, 3, material.unit_cost or 0)
                worksheet.write(row, 4, material.total_cost or 0)
                worksheet.write(row, 5, material.specification or '')
                worksheet.write(row, 6, material.status or 'Planned')
                worksheet.write(row, 7, material.supplier_name or '')
                worksheet.write(row, 8, material.supplier_contact or '')
                worksheet.write(row, 9, material.required_date.strftime('%Y-%m-%d') if material.required_date else '')
                worksheet.write(row, 10, material.delivery_date.strftime('%Y-%m-%d') if material.delivery_date else '')
            
            workbook.close()
            output.seek(0)
            
            # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='material_schedule_exported',
                description=f'Exported material schedule ({len(material_schedules)} items)',
                user_name=current_user.name
            )
            db.session.add(activity)
            db.session.commit()
            
            return send_file(
                BytesIO(output.read()),
                mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                as_attachment=True,
                download_name=f'{project.name}_material_schedule.xlsx'
            )
            
        except Exception as e:
            current_app.logger.error(f"Error exporting material schedule: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/activity_log', endpoint='admin.get_activity_log')
    @login_required
    def get_activity_log(project_id):
        """Get detailed activity log for a project"""
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check user access
            user_assignment = StaffAssignment.query.filter_by(
                project_id=project_id, 
                staff_id=current_user.id
            ).first()
        
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (user_assignment or is_manager or is_super_hq):
                return jsonify({'success': False, 'message': 'Access denied'}), 403
        
        # Get activity log with pagination
            page = request.args.get('page', 1, type=int)
            per_page = request.args.get('per_page', 20, type=int)
        
            activities_query = ProjectActivity.query.filter_by(project_id=project_id)\
                                                    .order_by(ProjectActivity.created_at.desc())
        
            activities_paginated = activities_query.paginate(
                page=page, 
                per_page=per_page, 
                error_out=False
            )
        
            activities_data = []
            for activity in activities_paginated.items:
                activity_data = {
                    'id': activity.id,
                    'action_type': activity.action_type,
                    'description': activity.description,
                    'user_name': activity.user_name or 'System',
                    'created_at': activity.created_at.strftime('%B %d, %Y at %I:%M %p'),
                    'created_at_iso': activity.created_at.isoformat(),
                    'user_id': activity.user_id
                }
                activities_data.append(activity_data)
        
        # Get activity statistics
            total_activities = activities_query.count()
        
        # Activity type breakdown
            activity_types = db.session.query(
                ProjectActivity.action_type,
                func.count(ProjectActivity.id).label('count')
            ).filter_by(project_id=project_id)\
             .group_by(ProjectActivity.action_type)\
             .all()
        
            activity_stats = {action_type: count for action_type, count in activity_types}
        
        # Recent activity summary (last 7 days)
            week_ago = datetime.now(timezone.utc) - timedelta(days=7)
            recent_count = ProjectActivity.query.filter(
                ProjectActivity.project_id == project_id,
                ProjectActivity.created_at >= week_ago
            ).count()
        
            return jsonify({
                'success': True,
                'activities': activities_data,
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': total_activities,
                    'pages': activities_paginated.pages,
                    'has_prev': activities_paginated.has_prev,
                    'has_next': activities_paginated.has_next
                },
                'statistics': {
                    'total_activities': total_activities,
                    'recent_activities_week': recent_count,
                    'activity_types': activity_stats
                },
                'project': {
                    'id': project.id,
                    'name': project.name,
                    'created_at': project.created_at.strftime('%B %d, %Y')
                }
            })
        
        except Exception as e:
            current_app.logger.error(f"Error getting activity log: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'message': f'An error occurred: {str(e)}'}), 500


    @app.route('/admin/projects/<int:project_id>/reports', endpoint='admin.project_reports')
    @role_required([Roles.SUPER_HQ])
    def project_reports(project_id):
        """Project analytics and reports page"""
        try:
            current_app.logger.info(f"Accessing project reports for project_id: {project_id}")
        
        # Get project
            project = Project.query.get_or_404(project_id)
            current_app.logger.info(f"Project found: {project.name}")
        
        # Calculate analytics data using correct relationships with safe access
            try:
                total_employees = len(project.staff_assignments) if hasattr(project, 'staff_assignments') and project.staff_assignments else 0
            except Exception:
                total_employees = 0
            
            try:
                total_milestones = len(project.milestones) if hasattr(project, 'milestones') and project.milestones else 0
            except Exception:
                total_milestones = 0
            
            try:
                completed_milestones = len([m for m in project.milestones if m.status and m.status.lower() == 'completed']) if hasattr(project, 'milestones') and project.milestones else 0
            except Exception:
                completed_milestones = 0
            
            try:
                total_documents = len(project.project_documents) if hasattr(project, 'project_documents') and project.project_documents else 0
            except Exception:
                total_documents = 0
        
        # Equipment statistics - using general Equipment model since no project relation exists
            all_equipment = Equipment.query.all()
            equipment_stats = {}
            if all_equipment:
                equipment_stats['total'] = len(all_equipment)
                equipment_stats['operational'] = len([e for e in all_equipment if e.status and e.status.lower() in ['operational', 'active']])
                equipment_stats['maintenance'] = len([e for e in all_equipment if e.status and e.status.lower() in ['maintenance', 'under maintenance']])
            else:
                equipment_stats['total'] = 0
                equipment_stats['operational'] = 0
                equipment_stats['maintenance'] = 0
        
        # Financial data - using budget and purchase orders since no direct expenses relation
            total_expenses = 0
            try:
                if hasattr(project, 'purchase_orders') and project.purchase_orders:
                    total_expenses = sum(order.total_amount or 0 for order in project.purchase_orders)
                elif hasattr(project, 'budgets') and project.budgets:
                    total_expenses = sum(budget.allocated_amount or 0 for budget in project.budgets)
            except Exception:
                total_expenses = 0
        
        # Progress statistics
            milestone_completion_rate = (completed_milestones / total_milestones * 100) if total_milestones > 0 else 0
        
        # Get recent milestones for the template
            recent_milestones = []
            try:
                if hasattr(project, 'milestones') and project.milestones:
                    recent_milestones = sorted([m for m in project.milestones if hasattr(m, 'created_at')], 
                                             key=lambda x: x.created_at if x.created_at else datetime.min, 
                                             reverse=True)[:5]
            except Exception:
                recent_milestones = []

        # Get equipment data
            total_equipment = 0
            active_equipment = 0
            try:
                if hasattr(project, 'equipment') and project.equipment:
                    total_equipment = len(project.equipment)
                    active_equipment = len([e for e in project.equipment if hasattr(e, 'status') and e.status and e.status.lower() in ['active', 'operational']])
            except Exception:
                total_equipment = 0
                active_equipment = 0

        # Calculate budget utilization
            budget_utilized = total_expenses / 1000 if total_expenses > 0 else 0  # Convert to thousands

        # Get recent tasks and alerts (mock data for now)
            recent_tasks = []
            recent_alerts = []

            analytics_data = {
                'project': project,
                'total_employees': total_employees or 0,
                'total_milestones': total_milestones or 0,
                'completed_milestones': completed_milestones or 0,
                'milestone_completion_rate': round(milestone_completion_rate, 1) if milestone_completion_rate is not None else 0,
                'total_documents': total_documents or 0,
                'equipment_stats': equipment_stats or {'total': 0, 'operational': 0, 'maintenance': 0},
                'total_expenses': total_expenses or 0,
                'total_equipment': total_equipment or 0,
                'active_equipment': active_equipment or 0,
                'budget_utilized': budget_utilized or 0,
                'recent_milestones': recent_milestones or [],
                'recent_tasks': recent_tasks or [],
                'recent_alerts': recent_alerts or [],
                'recent_activities': project.milestones[-5:] if hasattr(project, 'milestones') and project.milestones else []
            }
        
            return render_template('admin/project_reports.html', **analytics_data)
        
        except Exception as e:
            current_app.logger.error(f"Error loading project reports for project {project_id}: {str(e)}", exc_info=True)
            current_app.logger.error(f"Exception type: {type(e).__name__}")
            current_app.logger.error(f"Exception args: {e.args}")
            flash(f'Error loading project reports: {str(e)}. Please try again.', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))


    @app.route('/admin/projects/<int:project_id>/budget-analysis', endpoint='admin.budget_analysis')
    @role_required([Roles.SUPER_HQ])
    def budget_analysis(project_id):
        """Comprehensive budget analysis with real business logic"""
        try:
            current_app.logger.info(f"Accessing budget analysis for project_id: {project_id}")
        
        # Get project with all related data
            project = Project.query.get_or_404(project_id)
        
        # Get all budgets for this project
            budgets = Budget.query.filter_by(project_id=project_id).all()
        
        # Get all expenses related to this project (assuming expenses have project_id or can be linked)
        # For now, we'll get all expenses and categorize them
            expenses = Expense.query.all()  # In real scenario, filter by project
        
        # Get procurement requests for this project
            procurement_requests = ProcurementRequest.query.filter_by(project_id=project_id).all()
        
        # Get purchase orders for this project
            purchase_orders = PurchaseOrder.query.filter_by(project_id=project_id).all()
        
        # Calculate budget totals
            total_allocated = sum([b.allocated_amount for b in budgets])
            total_spent = sum([b.spent_amount for b in budgets])
            total_remaining = total_allocated - total_spent
        
        # Calculate budget utilization percentage
            utilization_percentage = (total_spent / total_allocated * 100) if total_allocated > 0 else 0
        
        # Budget breakdown by category
            budget_breakdown = {}
            for budget in budgets:
                budget_breakdown[budget.category] = {
                    'allocated': budget.allocated_amount,
                    'spent': budget.spent_amount,
                    'remaining': budget.remaining_amount,
                    'usage_percentage': budget.usage_percentage
                }
        
        # Calculate expense trends (last 6 months)
            from sqlalchemy import extract, func
        
            current_date = datetime.now()
            six_months_ago = current_date - timedelta(days=180)
        
        # Monthly expense trends
            monthly_expenses = db.session.query(
                extract('month', Expense.date).label('month'),
                extract('year', Expense.date).label('year'),
                func.sum(Expense.amount).label('total_amount'),
                func.count(Expense.id).label('expense_count')
            ).filter(
                Expense.date >= six_months_ago
            ).group_by(
                extract('year', Expense.date),
                extract('month', Expense.date)
            ).order_by(
                extract('year', Expense.date),
                extract('month', Expense.date)
            ).all()
        
        # Category-wise spending analysis
            category_spending = db.session.query(
                Expense.category,
                func.sum(Expense.amount).label('total_amount'),
                func.count(Expense.id).label('expense_count')
            ).group_by(Expense.category).all()
        
        # Cost variance analysis
            cost_variances = []
            for budget in budgets:
                variance = budget.spent_amount - budget.allocated_amount
                variance_percentage = (variance / budget.allocated_amount * 100) if budget.allocated_amount > 0 else 0
                cost_variances.append({
                    'category': budget.category,
                    'planned': budget.allocated_amount,
                    'actual': budget.spent_amount,
                    'variance': variance,
                    'variance_percentage': variance_percentage,
                    'status': 'over_budget' if variance > 0 else 'under_budget' if variance < 0 else 'on_budget'
                })
        
        # Procurement analysis
            total_procurement_value = sum([pr.price * pr.qty for pr in procurement_requests])
            pending_procurement = sum([pr.price * pr.qty for pr in procurement_requests if pr.status == 'pending'])
            approved_procurement = sum([pr.price * pr.qty for pr in procurement_requests if pr.status == 'approved'])
        
        # Purchase order analysis
            total_po_value = sum([po.total_amount for po in purchase_orders])
            pending_po_value = sum([po.total_amount for po in purchase_orders if po.status == 'Pending'])
            approved_po_value = sum([po.total_amount for po in purchase_orders if po.status == 'Approved'])
        
        # ROI and profitability analysis
            project_revenue = project.budget  # Assuming project budget represents revenue/contract value
            project_costs = total_spent
            gross_profit = project_revenue - project_costs
            profit_margin = (gross_profit / project_revenue * 100) if project_revenue > 0 else 0
        
        # Budget forecasting (simple linear projection)
            if monthly_expenses:
            # Calculate average monthly burn rate
                recent_months = monthly_expenses[-3:] if len(monthly_expenses) >= 3 else monthly_expenses
                avg_monthly_burn = sum([exp.total_amount for exp in recent_months]) / len(recent_months) if recent_months else 0
            
            # Forecast remaining budget duration
                months_remaining = (total_remaining / avg_monthly_burn) if avg_monthly_burn > 0 and total_remaining > 0 else 0
            
            # Forecast project completion cost
                if project.end_date:
                    remaining_months = max(0, (project.end_date - current_date.date()).days / 30)
                    forecasted_total_cost = total_spent + (avg_monthly_burn * remaining_months)
                    cost_overrun_risk = max(0, forecasted_total_cost - total_allocated)
                else:
                    forecasted_total_cost = 0
                    cost_overrun_risk = 0
            else:
                avg_monthly_burn = 0
                months_remaining = 0
                forecasted_total_cost = 0
                cost_overrun_risk = 0
        
        # Risk indicators
            risk_indicators = {
                'budget_utilization_risk': 'high' if utilization_percentage > 80 else 'medium' if utilization_percentage > 60 else 'low',
                'cost_overrun_risk': 'high' if cost_overrun_risk > total_allocated * 0.1 else 'medium' if cost_overrun_risk > 0 else 'low',
                'cash_flow_risk': 'high' if months_remaining < 2 else 'medium' if months_remaining < 6 else 'low',
                'procurement_risk': 'high' if pending_procurement > total_allocated * 0.2 else 'medium' if pending_procurement > total_allocated * 0.1 else 'low'
            }
        
        # Key performance indicators
            kpis = {
                'budget_efficiency': min(100, max(0, 100 - abs(utilization_percentage - 80))),  # Optimal around 80%
                'cost_control_score': max(0, 100 - (abs(sum([cv['variance_percentage'] for cv in cost_variances]) / len(cost_variances)) if cost_variances else 0)),
                'procurement_efficiency': (approved_procurement / total_procurement_value * 100) if total_procurement_value > 0 else 100,
                'financial_health': max(0, min(100, profit_margin + 50))  # Normalized score
            }
        
        # Recent financial activities (last 30 days)
            thirty_days_ago = current_date - timedelta(days=30)
            recent_expenses = Expense.query.filter(Expense.date >= thirty_days_ago).order_by(Expense.date.desc()).limit(10).all()
            recent_procurement = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project_id,
                ProcurementRequest.created_at >= thirty_days_ago
            ).order_by(ProcurementRequest.created_at.desc()).limit(5).all()
        
        # Budget alerts
            budget_alerts = []
            for budget in budgets:
                if budget.usage_percentage > 90:
                    budget_alerts.append({
                        'type': 'critical',
                        'category': budget.category,
                        'message': f'{budget.category} budget is {budget.usage_percentage:.1f}% utilized',
                        'severity': 'high'
                    })
                elif budget.usage_percentage > 75:
                    budget_alerts.append({
                        'type': 'warning',
                        'category': budget.category,
                        'message': f'{budget.category} budget is {budget.usage_percentage:.1f}% utilized',
                        'severity': 'medium'
                    })
        
            if cost_overrun_risk > 0:
                budget_alerts.append({
                    'type': 'forecast',
                    'category': 'overall',
                    'message': f'Potential cost overrun of {cost_overrun_risk:,.2f} forecasted',
                    'severity': 'high' if cost_overrun_risk > total_allocated * 0.1 else 'medium'
                })
        
        # Prepare chart data for JavaScript
            chart_categories = list(budget_breakdown.keys())
            chart_allocated = [budget_breakdown[cat]['allocated'] for cat in chart_categories]
            chart_spent = [budget_breakdown[cat]['spent'] for cat in chart_categories]
        
        # Compile all data for template
            budget_data = {
                'project': project,
                'budgets': budgets,
                'budget_breakdown': budget_breakdown,
                'total_allocated': total_allocated,
                'total_spent': total_spent,
                'total_remaining': total_remaining,
                'utilization_percentage': round(utilization_percentage, 1),
                'monthly_expenses': monthly_expenses,
                'category_spending': category_spending,
                'cost_variances': cost_variances,
                'total_procurement_value': total_procurement_value,
                'pending_procurement': pending_procurement,
                'approved_procurement': approved_procurement,
                'total_po_value': total_po_value,
                'pending_po_value': pending_po_value,
                'approved_po_value': approved_po_value,
                'project_revenue': project_revenue,
                'project_costs': project_costs,
                'gross_profit': gross_profit,
                'profit_margin': round(profit_margin, 1),
                'avg_monthly_burn': avg_monthly_burn,
                'months_remaining': round(months_remaining, 1),
                'forecasted_total_cost': forecasted_total_cost,
                'cost_overrun_risk': cost_overrun_risk,
                'risk_indicators': risk_indicators,
                'kpis': kpis,
                'recent_expenses': recent_expenses,
                'recent_procurement': recent_procurement,
                'budget_alerts': budget_alerts,
                'chart_categories': chart_categories,
                'chart_allocated': chart_allocated,
                'chart_spent': chart_spent
            }
        
            return render_template('admin/budget_analysis.html', **budget_data)
        
        except Exception as e:
            current_app.logger.error(f"Error loading budget analysis for project {project_id}: {str(e)}", exc_info=True)
            flash(f'Error loading budget analysis: {str(e)}. Please try again.', 'error')
            return redirect(url_for('admin.project_details', project_id=project_id))

# =====================================
# HR MANAGEMENT ROUTES (Admin Access)
# =====================================

    @app.route('/admin/hr', endpoint='admin.hr_dashboard')
    @role_required([Roles.SUPER_HQ])
    def hr_dashboard():
        """Admin HR Dashboard - Overview of HR operations"""
        try:
        
        # Get HR statistics
            total_employees = Employee.query.count()
            active_employees = Employee.query.filter_by(status='Active').count()
        
        # Get pending payroll approvals
            pending_payrolls = PayrollApproval.query.filter_by(status='pending_admin').all()
            total_pending_amount = sum(approval.total_amount for approval in pending_payrolls)
        
        # Get current month payroll status
            current_date = datetime.now()
            current_month_payroll = PayrollApproval.query.filter(
                PayrollApproval.period_year == current_date.year,
                PayrollApproval.period_month == current_date.month
            ).first()
        
        # Recent HR activities
            recent_employees = Employee.query.order_by(Employee.date_of_employment.desc()).limit(5).all()
        
            hr_summary = {
                'total_employees': total_employees,
                'active_employees': active_employees,
                'pending_payrolls': len(pending_payrolls),
                'total_pending_amount': total_pending_amount,
                'current_month_status': current_month_payroll.status if current_month_payroll else 'Not Submitted',
                'recent_employees': recent_employees
            }
        
            return render_template('admin/hr/dashboard.html', summary=hr_summary)
        
        except Exception as e:
            current_app.logger.error(f"Error loading HR dashboard: {str(e)}")
            flash('Error loading HR dashboard', 'error')
            return render_template('error.html')

    @app.route('/admin/hr/payroll-approvals', endpoint='admin.payroll_approvals')
    @role_required([Roles.SUPER_HQ])
    def payroll_approvals():
        """View pending payroll submissions for approval"""
        try:
        
        # Get all pending payroll approvals
            pending_approvals = PayrollApproval.query.filter_by(status='pending_admin').order_by(
                PayrollApproval.submitted_at.desc()
            ).all()
        
        # Format approval data with employee details
            approval_data = []
            for approval in pending_approvals:
            # Get payroll details for this approval
                payroll_items = StaffPayroll.query.filter(
                    StaffPayroll.period_year == approval.period_year,
                    StaffPayroll.period_month == approval.period_month,
                    StaffPayroll.approval_status == 'pending_admin'
                ).all()
            
            # Get employee count and total
                employee_count = len(payroll_items)
                total_amount = sum(item.gross or 0 for item in payroll_items)
            
                approval_data.append({
                    'id': approval.id,
                    'period': f"{approval.period_month}/{approval.period_year}",
                    'submitted_by': approval.submitted_by,
                    'submitted_at': approval.submitted_at,
                    'employee_count': employee_count,
                    'total_amount': total_amount,
                    'status': approval.status,
                    'comments': approval.comments
                })
        
            return render_template('admin/hr/payroll_approvals.html', approvals=approval_data)
        
        except Exception as e:
            current_app.logger.error(f"Error loading payroll approvals: {str(e)}")
            flash('Error loading payroll approvals', 'error')
            return redirect(url_for('admin.hr_dashboard'))

    @app.route('/admin/hr/payroll-approval/<int:approval_id>', endpoint='admin.view_payroll_details')
    @role_required([Roles.SUPER_HQ])
    def view_payroll_details(approval_id):
        """View detailed payroll submission for approval"""
        try:
        
        # Get the approval record
            approval = PayrollApproval.query.get_or_404(approval_id)
        
        # Get all payroll items for this period
            payroll_items = StaffPayroll.query.filter(
                StaffPayroll.period_year == approval.period_year,
                StaffPayroll.period_month == approval.period_month,
                StaffPayroll.approval_status == 'pending_admin'
            ).order_by(StaffPayroll.id).all()
        
        # Format payroll data with employee details
            payroll_data = []
            total_gross = 0
            total_deductions = 0
            total_net = 0
        
            for item in payroll_items:
                employee = Employee.query.get(item.employee_id)
                gross = item.gross or 0
                deductions = (item.tax or 0) + (item.pension or 0) + (item.nhf or 0) + (item.nhis or 0) + (item.other_deductions or 0)
                net = gross - deductions
            
                total_gross += gross
                total_deductions += deductions
                total_net += net
            
                payroll_data.append({
                    'employee_id': item.employee_id,
                    'employee_name': employee.name if employee else 'Unknown',
                    'designation': item.designation,
                    'site': item.site,
                    'work_days': item.work_days,
                    'gross': gross,
                    'tax': item.tax or 0,
                    'pension': item.pension or 0,
                    'nhf': item.nhf or 0,
                    'nhis': item.nhis or 0,
                    'other_deductions': item.other_deductions or 0,
                    'total_deductions': deductions,
                    'net_pay': net,
                    'bank_name': item.bank_name,
                    'account_number': item.account_number
                })
        
            summary = {
                'period': f"{approval.period_month}/{approval.period_year}",
                'submitted_by': approval.submitted_by,
                'submitted_at': approval.submitted_at,
                'employee_count': len(payroll_items),
                'total_gross': total_gross,
                'total_deductions': total_deductions,
                'total_net': total_net,
                'status': approval.status,
                'comments': approval.comments
            }
        
            return render_template('admin/hr/payroll_details.html', 
                                 approval=approval, 
                                 payroll_data=payroll_data, 
                                 summary=summary)
        
        except Exception as e:
            current_app.logger.error(f"Error loading payroll details: {str(e)}")
            flash('Error loading payroll details', 'error')
            return redirect(url_for('admin.payroll_approvals'))

    @app.route('/admin/hr/approve-payroll/<int:approval_id>', methods=['POST'], endpoint='admin.approve_payroll')
    @role_required([Roles.SUPER_HQ])
    def approve_payroll(approval_id):
        """Approve payroll submission and send to finance"""
        try:
        
        # Get the approval record
            approval = PayrollApproval.query.get_or_404(approval_id)
        
            if approval.status != 'pending_admin':
                flash('This payroll has already been processed', 'warning')
                return redirect(url_for('admin.payroll_approvals'))
        
        # Get admin comments
            admin_comments = request.form.get('comments', '').strip()
        
        # Update approval status
            approval.status = 'approved'
            approval.approved_by = session.get('username', 'Admin')
            approval.approved_at = datetime.now()
            approval.admin_comments = admin_comments
        
        # Update all related payroll items
            payroll_items = StaffPayroll.query.filter(
                StaffPayroll.period_year == approval.period_year,
                StaffPayroll.period_month == approval.period_month,
                StaffPayroll.approval_status == 'pending_admin'
            ).all()
        
            for item in payroll_items:
                item.approval_status = 'approved'
                item.approved_at = datetime.now()
                item.approved_by = session.get('username', 'Admin')
        
            db.session.commit()
        
            flash(f'Payroll for {approval.period_month}/{approval.period_year} approved successfully. '
                  f'Finance team has been notified.', 'success')
        
            current_app.logger.info(f"Payroll approved: Period {approval.period_month}/{approval.period_year}, "
                                   f"Approved by: {session.get('username', 'Admin')}")
        
        except Exception as e:
            current_app.logger.error(f"Error approving payroll: {str(e)}")
            flash('Error approving payroll', 'error')
            db.session.rollback()
    
        return redirect(url_for('admin.payroll_approvals'))

    @app.route('/admin/hr/reject-payroll/<int:approval_id>', methods=['POST'], endpoint='admin.reject_payroll')
    @role_required([Roles.SUPER_HQ])
    def reject_payroll(approval_id):
        """Reject payroll submission and send back to HR"""
        try:
        
        # Get the approval record
            approval = PayrollApproval.query.get_or_404(approval_id)
        
            if approval.status != 'pending_admin':
                flash('This payroll has already been processed', 'warning')
                return redirect(url_for('admin.payroll_approvals'))
        
        # Get rejection reason
            rejection_reason = request.form.get('rejection_reason', '').strip()
            if not rejection_reason:
                flash('Please provide a reason for rejection', 'error')
                return redirect(url_for('admin.view_payroll_details', approval_id=approval_id))
        
        # Update approval status
            approval.status = 'rejected'
            approval.approved_by = session.get('username', 'Admin')
            approval.approved_at = datetime.now()
            approval.admin_comments = rejection_reason
        
        # Update all related payroll items back to draft
            payroll_items = StaffPayroll.query.filter(
                StaffPayroll.period_year == approval.period_year,
                StaffPayroll.period_month == approval.period_month,
                StaffPayroll.approval_status == 'pending_admin'
            ).all()
        
            for item in payroll_items:
                item.approval_status = 'draft'
                item.approved_at = None
                item.approved_by = None
        
            db.session.commit()
        
            flash(f'Payroll for {approval.period_month}/{approval.period_year} rejected. '
                  f'HR team has been notified to make corrections.', 'success')
        
            current_app.logger.info(f"Payroll rejected: Period {approval.period_month}/{approval.period_year}, "
                                   f"Rejected by: {session.get('username', 'Admin')}, Reason: {rejection_reason}")
        
        except Exception as e:
            current_app.logger.error(f"Error rejecting payroll: {str(e)}")
            flash('Error rejecting payroll', 'error')
            db.session.rollback()
    
        return redirect(url_for('admin.payroll_approvals'))

    @app.route('/admin/hr/employees', endpoint='admin.view_employees')
    @role_required([Roles.SUPER_HQ])
    def view_employees():
        """View all employees (admin access to HR data)"""
        try:
        
        # Get search and filter parameters
            search = request.args.get('search', '').strip()
            status_filter = request.args.get('status', '')
            department_filter = request.args.get('department', '')
        
        # Build query
            query = Employee.query
        
            if search:
                query = query.filter(
                    Employee.name.ilike(f'%{search}%') | 
                    Employee.email.ilike(f'%{search}%') |
                    Employee.staff_code.ilike(f'%{search}%')
                )
        
            if status_filter:
                query = query.filter(Employee.status == status_filter)
            
            if department_filter:
                query = query.filter(Employee.department == department_filter)
        
            employees = query.order_by(Employee.date_of_employment.desc()).all()
        
        # Get unique departments for filter
            departments = db.session.query(Employee.department).filter(
                Employee.department.isnot(None)
            ).distinct().all()
            departments = [dept[0] for dept in departments if dept[0]]
        
            return render_template('admin/hr/employees.html', 
                                 employees=employees,
                                 departments=departments,
                                 current_search=search,
                                 current_status=status_filter,
                                 current_department=department_filter)
        
        except Exception as e:
            current_app.logger.error(f"Error loading employees: {str(e)}")
            flash('Error loading employees', 'error')
            return redirect(url_for('admin.hr_dashboard'))

    @app.route('/admin/user-management', endpoint='admin.user_management')
    @login_required
    @role_required(['super_hq', 'hq_hr'])
    def user_management():
        """Comprehensive user management view - shows all users, employees, and their roles"""
        try:
        # Get all users with role information
            users = db.session.query(User).order_by(User.created_at.desc()).all()
        
        # Get all employees with their information
            employees = db.session.query(Employee).order_by(Employee.date_of_employment.desc()).all()
        
        # Get all projects for assignment
            projects = db.session.query(Project).filter(Project.status.in_(['active', 'planning'])).all()
        
        # Get staff assignments for project mapping
            staff_assignments = db.session.query(StaffAssignment).all()
        
        # Create a mapping of employee to assigned projects
            employee_projects = {}
            for assignment in staff_assignments:
                if assignment.employee_id not in employee_projects:
                    employee_projects[assignment.employee_id] = []
                employee_projects[assignment.employee_id].append(assignment.project)
        
        # Available roles for assignment
            available_roles = [
                {'value': 'super_hq', 'name': 'Super HQ Admin'},
                {'value': 'hq_finance', 'name': 'HQ Finance Manager'},
                {'value': 'hr', 'name': 'HQ Manager'},
                {'value': 'hq_hr', 'name': 'HQ HR Manager'},
                {'value': 'hq_procurement', 'name': 'HQ Procurement Manager'},
                {'value': 'hq_quarry', 'name': 'Quarry Manager'},
                {'value': 'hq_project', 'name': 'Project Manager'},
                {'value': 'hq_cost_control', 'name': 'HQ Cost Control Manager'},
                {'value': 'finance_staff', 'name': 'Finance Staff'},
                {'value': 'hr_staff', 'name': 'HR Staff'},
                {'value': 'procurement_staff', 'name': 'Procurement Staff'},
                {'value': 'procurement_officer', 'name': 'Procurement Officer'},
                {'value': 'quarry_staff', 'name': 'Quarry Staff'},
                {'value': 'project_staff', 'name': 'Project Staff'},
            ]
        
        # Statistics
            stats = {
                'total_users': len(users),
                'total_employees': len(employees),
                'active_employees': len([e for e in employees if e.status == 'Active']),
                'total_projects': len(projects),
                'users_with_roles': len([u for u in users if u.role]),
                'employees_assigned': len(set([a.employee_id for a in staff_assignments]))
            }
        
            return render_template('admin/user_management.html',
                                 users=users,
                                 employees=employees,
                                 projects=projects,
                                 employee_projects=employee_projects,
                                 available_roles=available_roles,
                                 stats=stats)
                             
        except Exception as e:
            current_app.logger.error(f"Error in user management: {str(e)}")
            flash('Error loading user management data', 'error')
            return redirect(url_for('admin.dashboard'))

    @app.route('/admin/assign-user-role', methods=['POST'], endpoint='admin.assign_user_role')
    @login_required
    @role_required(['super_hq', 'hq_hr'])
    def assign_user_role():
        """Assign or update user role"""
        try:
            user_id = request.form.get('user_id')
            new_role = request.form.get('role')
        
            if not user_id or not new_role:
                flash('User ID and role are required', 'error')
                return redirect(url_for('admin.user_management'))
        
            user = User.query.get_or_404(user_id)
            old_role = user.role
            user.role = new_role
        
            db.session.commit()
        
            current_app.logger.info(f"User {user.name} (ID: {user.id}) role updated from '{old_role}' to '{new_role}' by {current_user.name}")
            flash(f'Successfully updated {user.name}\'s role to {new_role}', 'success')
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error assigning user role: {str(e)}")
            flash('Error updating user role', 'error')
    
        return redirect(url_for('admin.user_management'))

    @app.route('/admin/assign-employee-project', methods=['POST'], endpoint='admin.assign_employee_project')
    @login_required
    @role_required(['super_hq', 'hq_hr', 'hq_project'])
    def assign_employee_project():
        """Assign employee to project"""
        try:
            employee_id = request.form.get('employee_id')
            project_id = request.form.get('project_id')
            role = request.form.get('assignment_role', 'Team Member')
        
            if not employee_id or not project_id:
                flash('Employee and project are required', 'error')
                return redirect(url_for('admin.user_management'))
        
        # Check if assignment already exists
            existing = StaffAssignment.query.filter_by(
                employee_id=employee_id,
                project_id=project_id
            ).first()
        
            if existing:
                flash('Employee is already assigned to this project', 'warning')
                return redirect(url_for('admin.user_management'))
        
        # Create new assignment
            assignment = StaffAssignment(
                employee_id=employee_id,
                project_id=project_id,
                role=role,
                assigned_at=datetime.now(timezone.utc),
                assigned_by=current_user.id
            )
        
            db.session.add(assignment)
            db.session.commit()
        
            employee = Employee.query.get(employee_id)
            project = Project.query.get(project_id)
        
            current_app.logger.info(f"Employee {employee.name} assigned to project {project.name} by {current_user.name}")
            flash(f'Successfully assigned {employee.name} to {project.name}', 'success')
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error assigning employee to project: {str(e)}")
            flash('Error assigning employee to project', 'error')
    
        return redirect(url_for('admin.user_management'))

    @app.route('/admin/remove-employee-assignment/<int:assignment_id>', methods=['POST'], endpoint='admin.remove_employee_assignment')
    @login_required
    @role_required(['super_hq', 'hq_hr', 'hq_project'])
    def remove_employee_assignment(assignment_id):
        """Remove employee from project assignment"""
        try:
            assignment = StaffAssignment.query.get_or_404(assignment_id)
            employee_name = assignment.employee.name
            project_name = assignment.project.name
        
            db.session.delete(assignment)
            db.session.commit()
        
            current_app.logger.info(f"Employee {employee_name} removed from project {project_name} by {current_user.name}")
            flash(f'Successfully removed {employee_name} from {project_name}', 'success')
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error removing employee assignment: {str(e)}")
            flash('Error removing employee assignment', 'error')
    
        return redirect(url_for('admin.user_management'))

    @app.route('/admin/comprehensive-user-management', endpoint='admin.comprehensive_user_management')
    @login_required
    @role_required(['super_hq', 'hq_hr', 'hq_project'])
    def comprehensive_user_management():
        """Comprehensive user management page - display all users and employees"""
        try:
        # Get all users from User table (staff)
            users = User.query.all()
        
        # Get all employees from Employee table
            employees = Employee.query.all()
        
        # Get all projects for assignment options
            projects = Project.query.filter_by(status='Active').all()
        
        # Get available roles
            available_roles = ['admin', 'manager', 'supervisor', 'staff', 'viewer', 'project_manager', 
                              'site_engineer', 'foreman', 'safety_officer', 'quality_control']
        
        # Get staff assignments with project details
            staff_assignments = db.session.query(StaffAssignment, Project.name.label('project_name')).join(Project).all()
        
        # Create assignment lookup for easy access
            user_assignments = {}
            for assignment, project_name in staff_assignments:
                if assignment.staff_id not in user_assignments:
                    user_assignments[assignment.staff_id] = []
                user_assignments[assignment.staff_id].append({
                    'project_id': assignment.project_id,
                    'project_name': project_name,
                    'role': assignment.role,
                    'assigned_at': assignment.assigned_at
                })
        
        # Statistics
            total_users = len(users)
            total_employees = len(employees)
            active_users = len([u for u in users if u.role != 'inactive'])
            users_with_projects = len(user_assignments)
        
            current_app.logger.info(f"Comprehensive user management accessed by {current_user.name}")
        
            return render_template('admin/comprehensive_user_management.html',
                                 users=users,
                                 employees=employees,
                                 projects=projects,
                                 available_roles=available_roles,
                                 user_assignments=user_assignments,
                                 total_users=total_users,
                                 total_employees=total_employees,
                                 active_users=active_users,
                                 users_with_projects=users_with_projects)
                             
        except Exception as e:
            current_app.logger.error(f"Error loading comprehensive user management: {str(e)}")
            flash('Error loading user management page', 'error')
            return redirect(url_for('admin.index'))

    @app.route('/admin/assign-user-role-new', methods=['POST'], endpoint='admin.assign_user_role_new')
    @login_required
    @role_required(['super_hq', 'hq_hr'])
    def assign_user_role_new():
        """Assign or update user role"""
        try:
            user_id = request.form.get('user_id')
            new_role = request.form.get('role')
        
            if not user_id or not new_role:
                flash('User and role are required', 'error')
                return redirect(url_for('admin.comprehensive_user_management'))
        
            user = User.query.get_or_404(user_id)
            old_role = user.role
            user.role = new_role
            user.updated_at = datetime.now(timezone.utc)
        
            db.session.commit()
        
            current_app.logger.info(f"User {user.name} role changed from {old_role} to {new_role} by {current_user.name}")
            flash(f'Successfully updated {user.name}\'s role from {old_role} to {new_role}', 'success')
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating user role: {str(e)}")
            flash('Error updating user role', 'error')
    
        return redirect(url_for('admin.comprehensive_user_management'))

    @app.route('/admin/assign-user-project-new', methods=['POST'], endpoint='admin.assign_user_project_new')
    @login_required
    @role_required(['super_hq', 'hq_project'])
    def assign_user_project_new():
        """Assign user to project"""
        try:
            user_id = request.form.get('user_id')
            project_id = request.form.get('project_id')
            role = request.form.get('project_role', 'Staff')
        
            if not user_id or not project_id:
                flash('User and project are required', 'error')
                return redirect(url_for('admin.comprehensive_user_management'))
        
        # Check if assignment already exists
            existing = StaffAssignment.query.filter_by(staff_id=user_id, project_id=project_id).first()
            if existing:
                flash('User is already assigned to this project', 'warning')
                return redirect(url_for('admin.comprehensive_user_management'))
        
            assignment = StaffAssignment(
                staff_id=user_id,
                project_id=project_id,
                role=role,
                assigned_at=datetime.now(timezone.utc)
            )
        
            db.session.add(assignment)
            db.session.commit()
        
            user = User.query.get(user_id)
            project = Project.query.get(project_id)
        
            current_app.logger.info(f"User {user.name} assigned to project {project.name} as {role} by {current_user.name}")
            flash(f'Successfully assigned {user.name} to {project.name} as {role}', 'success')
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error assigning user to project: {str(e)}")
            flash('Error assigning user to project', 'error')
    
        return redirect(url_for('admin.comprehensive_user_management'))

    @app.route('/admin/remove-user-project/<int:user_id>/<int:project_id>', methods=['POST'], endpoint='admin.remove_user_project')
    @login_required
    @role_required(['super_hq', 'hq_project'])
    def remove_user_project(user_id, project_id):
        """Remove user from project"""
        try:
            assignment = StaffAssignment.query.filter_by(staff_id=user_id, project_id=project_id).first()
            if not assignment:
                flash('Assignment not found', 'error')
                return redirect(url_for('admin.comprehensive_user_management'))
        
            user = User.query.get(user_id)
            project = Project.query.get(project_id)
        
            db.session.delete(assignment)
            db.session.commit()
        
            current_app.logger.info(f"User {user.name} removed from project {project.name} by {current_user.name}")
            flash(f'Successfully removed {user.name} from {project.name}', 'success')
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error removing user from project: {str(e)}")
            flash('Error removing user from project', 'error')
    
        return redirect(url_for('admin.comprehensive_user_management'))


    # ============================================================================
    # OFFICE PROJECT MANAGER ENDPOINTS
    # ============================================================================
    # Role: Oversees overall execution of multiple construction projects from HQ
    # Responsibilities: Approve plans/budgets, monitor progress, review submissions,
    #                   coordinate departments, generate performance dashboards
    # ============================================================================

    @app.route('/office-pm/dashboard', endpoint='office_pm.dashboard')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_dashboard():
        """
        Office Project Manager Dashboard - Comprehensive KPI and project overview
        Shows all projects under management with key performance indicators
        """
        try:
            from sqlalchemy import extract, func
            from datetime import datetime, timedelta
            
            # Get all projects managed by this user or all projects if SUPER_HQ
            if current_user.role == Roles.SUPER_HQ:
                projects = Project.query.filter_by(status='Active').all()
            else:
                projects = Project.query.filter(
                    (Project.project_manager == current_user.name) | 
                    (Project.status == 'Active')
                ).all()
            
            # Calculate KPIs for each project
            project_kpis = []
            for project in projects:
                # Budget analysis
                total_budget = project.budget or 0
                # Get budget spent from Budget model
                budgets = Budget.query.filter_by(project_id=project.id).all()
                total_spent = sum(b.spent_amount or 0 for b in budgets)
                budget_utilization = (total_spent / total_budget * 100) if total_budget > 0 else 0
                
                # Schedule performance
                start_date = project.start_date
                end_date = project.end_date
                today = datetime.now().date()
                
                if start_date and end_date:
                    total_days = (end_date - start_date).days
                    elapsed_days = (today - start_date).days
                    time_progress = (elapsed_days / total_days * 100) if total_days > 0 else 0
                else:
                    time_progress = 0
                
                # Task completion
                milestones = Milestone.query.filter_by(project_id=project.id).all()
                total_milestones = len(milestones)
                completed_milestones = sum(1 for m in milestones if m.status == 'Completed')
                milestone_completion = (completed_milestones / total_milestones * 100) if total_milestones > 0 else 0
                
                # Issues and risks - using DPR issues as open issues count
                recent_dprs_with_issues = DailyProductionReport.query.filter(
                    DailyProductionReport.project_id == project.id,
                    DailyProductionReport.issues.isnot(None),
                    DailyProductionReport.issues != ''
                ).count()
                open_issues = recent_dprs_with_issues
                
                # Count pending procurement requests as pending approvals
                pending_approvals = ProcurementRequest.query.filter_by(
                    project_id=project.id, 
                    status='pending'
                ).count()
                
                # Recent activity
                recent_dprs = DailyProductionReport.query.filter_by(
                    project_id=project.id
                ).order_by(DailyProductionReport.report_date.desc()).limit(7).all()
                
                avg_daily_progress = 0
                if recent_dprs:
                    total_progress = sum(dpr.daily_progress or 0 for dpr in recent_dprs)
                    avg_daily_progress = total_progress / len(recent_dprs)
                
                # Health status calculation
                if budget_utilization > 100 or time_progress - milestone_completion > 20:
                    health_status = 'critical'
                    health_color = 'red'
                elif budget_utilization > 85 or time_progress - milestone_completion > 10:
                    health_status = 'warning'
                    health_color = 'yellow'
                else:
                    health_status = 'good'
                    health_color = 'green'
                
                project_kpis.append({
                    'project': project,
                    'budget_total': total_budget,
                    'budget_spent': total_spent,
                    'budget_remaining': total_budget - total_spent,
                    'budget_utilization': round(budget_utilization, 1),
                    'time_progress': round(time_progress, 1),
                    'milestone_completion': round(milestone_completion, 1),
                    'total_milestones': total_milestones,
                    'completed_milestones': completed_milestones,
                    'open_issues': open_issues,
                    'pending_approvals': pending_approvals,
                    'avg_daily_progress': round(avg_daily_progress, 1),
                    'health_status': health_status,
                    'health_color': health_color
                })
            
            # Overall portfolio metrics
            total_portfolio_budget = sum(p['budget_total'] for p in project_kpis)
            total_portfolio_spent = sum(p['budget_spent'] for p in project_kpis)
            avg_completion = sum(p['milestone_completion'] for p in project_kpis) / len(project_kpis) if project_kpis else 0
            total_issues = sum(p['open_issues'] for p in project_kpis)
            total_pending_approvals = sum(p['pending_approvals'] for p in project_kpis)
            
            # Pending submissions requiring approval
            pending_budgets = Project.query.filter_by(
                budget_status='Pending Approval'
            ).count() if hasattr(Project, 'budget_status') else 0
            
            # Count pending procurement as variations
            pending_variations = ProcurementRequest.query.filter_by(status='pending').count()
            
            # Recent communications
            recent_communications = Audit.query.filter(
                Audit.action.like('%communication%') | 
                Audit.action.like('%message%')
            ).order_by(Audit.timestamp.desc()).limit(10).all()
            
            return render_template('office_pm/dashboard.html',
                project_kpis=project_kpis,
                total_projects=len(projects),
                total_portfolio_budget=total_portfolio_budget,
                total_portfolio_spent=total_portfolio_spent,
                avg_completion=round(avg_completion, 1),
                total_issues=total_issues,
                total_pending_approvals=total_pending_approvals,
                pending_budgets=pending_budgets,
                pending_variations=pending_variations,
                recent_communications=recent_communications
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading Office PM dashboard: {str(e)}", exc_info=True)
            flash('Error loading dashboard', 'error')
            return redirect(url_for('main_home'))

    @app.route('/office-pm/approvals', endpoint='office_pm.approvals')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_approvals():
        """
        Centralized approval center for Office Project Manager
        Includes budgets, schedules, variations, claims, change orders
        """
        try:
            # Pending budget approvals
            pending_budgets = Project.query.filter_by(
                budget_status='Pending Approval'
            ).all()
            
            # Pending payment requests
            pending_payments = PaymentRequest.query.filter_by(
                status='Pending'
            ).order_by(PaymentRequest.request_date.desc()).all()
            
            # Pending variations - using procurement requests as proxy
            pending_variations = []
            
            # Pending procurement requests
            pending_procurement = ProcurementRequest.query.filter_by(
                status='pending'
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Pending project documents
            pending_documents = Document.query.filter_by(
                status='Pending Approval'
            ).order_by(Document.uploaded_at.desc()).all()
            
            # Pending milestone approvals
            pending_milestones = Milestone.query.filter_by(
                status='Pending Approval'
            ).order_by(Milestone.due_date).all()
            
            # Group by priority
            high_priority = []
            medium_priority = []
            low_priority = []
            
            # Categorize by urgency
            today = datetime.now().date()
            
            for payment in pending_payments:
                days_pending = (today - payment.request_date.date()).days if payment.request_date else 0
                priority = 'high' if days_pending > 7 or payment.amount > 1000000 else 'medium'
                item = {
                    'type': 'Payment Request',
                    'id': payment.id,
                    'description': f"Payment request for {payment.amount:,.2f}",
                    'project': payment.project.name if payment.project else 'N/A',
                    'date': payment.request_date,
                    'priority': priority,
                    'amount': payment.amount
                }
                if priority == 'high':
                    high_priority.append(item)
                else:
                    medium_priority.append(item)
            
            for variation in pending_variations:
                days_pending = (today - variation.created_at.date()).days
                priority = 'high' if days_pending > 5 else 'medium'
                item = {
                    'type': variation.query_type,
                    'id': variation.id,
                    'description': variation.subject,
                    'project': variation.project.name if variation.project else 'N/A',
                    'date': variation.created_at,
                    'priority': priority
                }
                if priority == 'high':
                    high_priority.append(item)
                else:
                    medium_priority.append(item)
            
            for procurement in pending_procurement:
                days_pending = (today - procurement.request_date.date()).days if procurement.request_date else 0
                priority = 'high' if days_pending > 3 or procurement.estimated_cost > 500000 else 'low'
                item = {
                    'type': 'Procurement',
                    'id': procurement.id,
                    'description': f"{procurement.item_description}",
                    'project': procurement.project.name if procurement.project else 'N/A',
                    'date': procurement.request_date,
                    'priority': priority,
                    'amount': procurement.estimated_cost
                }
                if priority == 'high':
                    high_priority.append(item)
                else:
                    low_priority.append(item)
            
            return render_template('office_pm/approvals.html',
                high_priority=sorted(high_priority, key=lambda x: x['date'], reverse=True),
                medium_priority=sorted(medium_priority, key=lambda x: x['date'], reverse=True),
                low_priority=sorted(low_priority, key=lambda x: x['date'], reverse=True),
                pending_budgets=pending_budgets,
                pending_documents=pending_documents,
                pending_milestones=pending_milestones,
                total_pending=len(high_priority) + len(medium_priority) + len(low_priority)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading approvals: {str(e)}", exc_info=True)
            flash('Error loading approvals', 'error')
            return redirect(url_for('office_pm.dashboard'))

    @app.route('/office-pm/approve/<string:item_type>/<int:item_id>', methods=['POST'], endpoint='office_pm.approve_item')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_approve_item(item_type, item_id):
        """
        Approve various types of submissions
        Types: budget, payment, variation, procurement, document, milestone
        """
        try:
            data = request.get_json() or {}
            comments = data.get('comments', '').strip()
            approved = data.get('approved', True)
            
            # Process based on item type
            if item_type == 'payment':
                payment = PaymentRequest.query.get_or_404(item_id)
                payment.status = 'Approved' if approved else 'Rejected'
                payment.approved_by = current_user.username
                payment.approval_date = datetime.now()
                
                # Create audit log
                Audit.log_action(
                    user_id=current_user.id,
                    action=f"{'Approved' if approved else 'Rejected'} payment request #{payment.id}",
                    details=f"Amount: {payment.amount:,.2f}. Comments: {comments}"
                )
                
                message = f"Payment request {'approved' if approved else 'rejected'} successfully"
                
            elif item_type == 'variation':
                variation = Query.query.get_or_404(item_id)
                variation.status = 'Approved' if approved else 'Rejected'
                variation.resolved_by = current_user.username
                variation.resolved_at = datetime.now()
                variation.resolution = comments
                
                Audit.log_action(
                    user_id=current_user.id,
                    action=f"{'Approved' if approved else 'Rejected'} {variation.query_type} #{variation.id}",
                    details=f"Subject: {variation.subject}. Comments: {comments}"
                )
                
                message = f"{variation.query_type} {'approved' if approved else 'rejected'} successfully"
                
            elif item_type == 'procurement':
                procurement = ProcurementRequest.query.get_or_404(item_id)
                procurement.approval_status = 'Approved' if approved else 'Rejected'
                procurement.approved_by = current_user.username
                procurement.approval_date = datetime.now()
                procurement.approval_notes = comments
                
                Audit.log_action(
                    user_id=current_user.id,
                    action=f"{'Approved' if approved else 'Rejected'} procurement request #{procurement.id}",
                    details=f"Item: {procurement.item_description}. Cost: {procurement.estimated_cost:,.2f}"
                )
                
                message = f"Procurement request {'approved' if approved else 'rejected'} successfully"
                
            elif item_type == 'document':
                document = Document.query.get_or_404(item_id)
                document.status = 'Approved' if approved else 'Rejected'
                document.reviewed_by = current_user.username
                document.review_date = datetime.now()
                document.review_comments = comments
                
                Audit.log_action(
                    user_id=current_user.id,
                    action=f"{'Approved' if approved else 'Rejected'} document #{document.id}",
                    details=f"Document: {document.name}. Comments: {comments}"
                )
                
                message = f"Document {'approved' if approved else 'rejected'} successfully"
                
            elif item_type == 'milestone':
                milestone = Milestone.query.get_or_404(item_id)
                milestone.status = 'Approved' if approved else 'Rejected'
                milestone.approved_by = current_user.username
                milestone.approval_date = datetime.now()
                
                Audit.log_action(
                    user_id=current_user.id,
                    action=f"{'Approved' if approved else 'Rejected'} milestone #{milestone.id}",
                    details=f"Milestone: {milestone.name}. Comments: {comments}"
                )
                
                message = f"Milestone {'approved' if approved else 'rejected'} successfully"
                
            elif item_type == 'budget':
                project = Project.query.get_or_404(item_id)
                project.budget_status = 'Approved' if approved else 'Rejected'
                project.budget_approved_by = current_user.username
                project.budget_approval_date = datetime.now()
                
                Audit.log_action(
                    user_id=current_user.id,
                    action=f"{'Approved' if approved else 'Rejected'} budget for project {project.name}",
                    details=f"Budget: {project.budget:,.2f}. Comments: {comments}"
                )
                
                message = f"Project budget {'approved' if approved else 'rejected'} successfully"
            
            else:
                return jsonify({'success': False, 'message': 'Invalid item type'}), 400
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': message,
                'approved': approved
            })
            
        except Exception as e:
            current_app.logger.error(f"Error approving {item_type}: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': str(e)}), 500

    @app.route('/office-pm/progress-reports', endpoint='office_pm.progress_reports')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_progress_reports():
        """
        View and monitor progress reports from all site project managers
        Includes DPRs, weekly reports, and milestone updates
        """
        try:
            from sqlalchemy import extract
            
            # Get filter parameters
            project_id = request.args.get('project_id', type=int)
            report_type = request.args.get('type', 'all')
            date_range = request.args.get('range', '30')  # days
            
            # Calculate date range
            end_date = datetime.now()
            start_date = end_date - timedelta(days=int(date_range))
            
            # Get projects
            if project_id:
                projects = [Project.query.get_or_404(project_id)]
            else:
                if current_user.role == Roles.SUPER_HQ:
                    projects = Project.query.filter_by(status='Active').all()
                else:
                    projects = Project.query.filter(
                        (Project.project_manager == current_user.name) |
                        (Project.status == 'Active')
                    ).all()
            
            # Get daily production reports
            dprs = DailyProductionReport.query.filter(
                DailyProductionReport.report_date.between(start_date, end_date)
            ).order_by(DailyProductionReport.report_date.desc()).all()
            
            # Filter by project if needed
            if project_id:
                dprs = [dpr for dpr in dprs if dpr.project_id == project_id]
            
            # Get weekly/monthly reports
            reports = Report.query.filter(
                Report.report_date.between(start_date, end_date)
            ).order_by(Report.report_date.desc()).all()
            
            if project_id:
                reports = [r for r in reports if r.project_id == project_id]
            
            # Get milestone updates
            milestone_updates = Milestone.query.filter(
                Milestone.updated_at.between(start_date, end_date)
            ).order_by(Milestone.updated_at.desc()).all()
            
            if project_id:
                milestone_updates = [m for m in milestone_updates if m.project_id == project_id]
            
            # Analyze progress trends
            progress_data = {}
            for project in projects:
                project_dprs = [dpr for dpr in dprs if dpr.project_id == project.id]
                
                if project_dprs:
                    dates = [dpr.report_date.strftime('%Y-%m-%d') for dpr in project_dprs]
                    progress = [dpr.daily_progress or 0 for dpr in project_dprs]
                    
                    progress_data[project.id] = {
                        'project_name': project.name,
                        'dates': dates[::-1],  # Reverse for chronological order
                        'progress': progress[::-1],
                        'avg_progress': sum(progress) / len(progress) if progress else 0
                    }
            
            return render_template('office_pm/progress_reports.html',
                dprs=dprs,
                reports=reports,
                milestone_updates=milestone_updates,
                projects=projects,
                selected_project=project_id,
                progress_data=progress_data,
                date_range=date_range
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading progress reports: {str(e)}", exc_info=True)
            flash('Error loading progress reports', 'error')
            return redirect(url_for('office_pm.dashboard'))

    @app.route('/office-pm/communications', endpoint='office_pm.communications')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_communications():
        """
        Communication center for Office PM
        View and manage communications with field teams, departments, and stakeholders
        """
        try:
            # Get communication logs
            project_id = request.args.get('project_id', type=int)
            comm_type = request.args.get('type', 'all')
            
            # Base query for audit logs related to communications
            query = Audit.query.filter(
                Audit.action.like('%message%') |
                Audit.action.like('%communication%') |
                Audit.action.like('%email%') |
                Audit.action.like('%notification%')
            ).order_by(Audit.timestamp.desc())
            
            communications = query.limit(100).all()
            
            # Get issues from DPRs instead of Query model
            if project_id:
                dprs_with_issues = DailyProductionReport.query.filter(
                    DailyProductionReport.project_id == project_id,
                    DailyProductionReport.issues.isnot(None),
                    DailyProductionReport.issues != ''
                ).order_by(DailyProductionReport.report_date.desc()).limit(50).all()
            else:
                dprs_with_issues = DailyProductionReport.query.filter(
                    DailyProductionReport.issues.isnot(None),
                    DailyProductionReport.issues != ''
                ).order_by(DailyProductionReport.report_date.desc()).limit(50).all()
            
            # Convert DPRs to issue format
            issues = [{
                'id': dpr.id,
                'subject': f"Issue - {dpr.project.name if dpr.project else 'Unknown'}",
                'description': dpr.issues,
                'status': 'Open',
                'project': dpr.project.name if dpr.project else 'Unknown',
                'date': dpr.report_date
            } for dpr in dprs_with_issues]
            
            # Get queries for actual queries (employee queries not project-specific)
            queries = Query.query.order_by(Query.submitted_at.desc()).limit(20).all() if hasattr(Query, 'submitted_at') else []
            
            # Get projects for filtering
            projects = Project.query.filter_by(status='Active').all()
            
            # Count by type
            comm_stats = {
                'total': len(communications),
                'today': sum(1 for c in communications if c.timestamp.date() == datetime.now().date()),
                'open_issues': sum(1 for i in issues if i.status == 'Open'),
                'pending_responses': sum(1 for i in issues if i.status == 'Pending')
            }
            
            return render_template('office_pm/communications.html',
                communications=communications,
                issues=issues,
                projects=projects,
                selected_project=project_id,
                comm_stats=comm_stats
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading communications: {str(e)}", exc_info=True)
            flash('Error loading communications', 'error')
            return redirect(url_for('office_pm.dashboard'))

    @app.route('/office-pm/send-message', methods=['POST'], endpoint='office_pm.send_message')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_send_message():
        """
        Send message to project team or department
        """
        try:
            data = request.get_json()
            recipient_type = data.get('recipient_type')  # 'project', 'department', 'user'
            recipient_id = data.get('recipient_id')
            subject = data.get('subject', '').strip()
            message = data.get('message', '').strip()
            priority = data.get('priority', 'normal')
            
            if not message:
                return jsonify({'success': False, 'message': 'Message cannot be empty'}), 400
            
            # Create query/issue for tracking
            new_query = Query(
                project_id=recipient_id if recipient_type == 'project' else None,
                query_type='Communication',
                subject=subject or 'Message from Office PM',
                description=message,
                raised_by=current_user.username,
                status='Sent',
                priority=priority
            )
            
            db.session.add(new_query)
            
            # Log the communication
            Audit.log_action(
                user_id=current_user.id,
                action=f"Sent message: {subject}",
                details=f"To: {recipient_type} {recipient_id}. Priority: {priority}"
            )
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Message sent successfully',
                'query_id': new_query.id
            })
            
        except Exception as e:
            current_app.logger.error(f"Error sending message: {str(e)}", exc_info=True)
            db.session.rollback()
            return jsonify({'success': False, 'message': str(e)}), 500

    @app.route('/office-pm/performance-analytics', endpoint='office_pm.performance_analytics')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def office_pm_performance_analytics():
        """
        Advanced performance analytics and dashboards
        Portfolio-wide insights, trends, and predictive analytics
        """
        try:
            from sqlalchemy import extract, func
            
            # Get all active projects
            if current_user.role == Roles.SUPER_HQ:
                projects = Project.query.filter_by(status='Active').all()
            else:
                projects = Project.query.filter(
                    Project.project_manager == current_user.name
                ).all()
            
            # Portfolio financial metrics
            total_portfolio_value = sum(p.budget or 0 for p in projects)
            
            # Get all expenses from Budget model
            portfolio_budgets = []
            for project in projects:
                budgets = Budget.query.filter_by(project_id=project.id).all()
                portfolio_budgets.extend(budgets)
            
            total_spent = sum(b.spent_amount or 0 for b in portfolio_budgets)
            
            # Schedule performance metrics
            on_schedule_count = 0
            delayed_count = 0
            ahead_count = 0
            
            today = datetime.now().date()
            
            for project in projects:
                if project.start_date and project.end_date:
                    total_days = (project.end_date - project.start_date).days
                    elapsed_days = (today - project.start_date).days
                    time_progress = (elapsed_days / total_days * 100) if total_days > 0 else 0
                    
                    # Get completion percentage
                    milestones = Milestone.query.filter_by(project_id=project.id).all()
                    if milestones:
                        completed = sum(1 for m in milestones if m.status == 'Completed')
                        completion = (completed / len(milestones) * 100)
                        
                        variance = completion - time_progress
                        if variance >= 5:
                            ahead_count += 1
                        elif variance <= -5:
                            delayed_count += 1
                        else:
                            on_schedule_count += 1
            
            # Quality metrics - count issues from DPRs
            dprs_with_issues_all = DailyProductionReport.query.filter(
                DailyProductionReport.project_id.in_([p.id for p in projects]),
                DailyProductionReport.issues.isnot(None),
                DailyProductionReport.issues != ''
            ).all()
            
            total_issues = len(dprs_with_issues_all)
            
            # All DPR issues are considered "open" unless resolved field exists
            open_issues = total_issues  # Simplified: all issues are open
            
            # Team performance
            dprs_last_30_days = DailyProductionReport.query.filter(
                DailyProductionReport.project_id.in_([p.id for p in projects]),
                DailyProductionReport.report_date >= datetime.now() - timedelta(days=30)
            ).all()
            
            avg_productivity = sum(dpr.daily_progress or 0 for dpr in dprs_last_30_days) / len(dprs_last_30_days) if dprs_last_30_days else 0
            
            # Trend data for charts
            months = []
            budget_data = []
            actual_data = []
            
            for i in range(6):
                month_date = datetime.now() - timedelta(days=30*i)
                month_name = month_date.strftime('%b %Y')
                months.insert(0, month_name)
                
                # Calculate expenses for that month
                month_start = month_date.replace(day=1)
                next_month = month_start + timedelta(days=32)
                month_end = next_month.replace(day=1) - timedelta(days=1)
                
                # Calculate spending for that month from budgets
                month_expenses = sum(
                    b.spent_amount or 0 for b in portfolio_budgets 
                    if b.created_at and month_start <= b.created_at.date() <= month_end
                )
                
                actual_data.insert(0, round(month_expenses, 2))
                
                # Estimated budget for the month (total budget / project months)
                estimated_monthly = total_portfolio_value / 12  # Simplified
                budget_data.insert(0, round(estimated_monthly, 2))
            
            return render_template('office_pm/performance_analytics.html',
                projects=projects,
                total_projects=len(projects),
                total_portfolio_value=total_portfolio_value,
                total_spent=total_spent,
                budget_remaining=total_portfolio_value - total_spent,
                utilization_percentage=round((total_spent / total_portfolio_value * 100) if total_portfolio_value > 0 else 0, 1),
                on_schedule_count=on_schedule_count,
                delayed_count=delayed_count,
                ahead_count=ahead_count,
                total_issues=total_issues,
                open_issues=open_issues,
                avg_productivity=round(avg_productivity, 1),
                chart_months=months,
                chart_budget_data=budget_data,
                chart_actual_data=actual_data
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading performance analytics: {str(e)}", exc_info=True)
            flash('Error loading analytics', 'error')
            return redirect(url_for('office_pm.dashboard'))

    
    @app.route('/project/<int:project_id>')
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def project_details(project_id):
        """View detailed information about a specific project"""
        try:
            project = Project.query.get_or_404(project_id)
            
            # Project metrics
            milestones = Milestone.query.filter_by(project_id=project.id).all()
            completed_milestones = [m for m in milestones if m.status == 'Completed']
            in_progress_milestones = [m for m in milestones if m.status == 'In Progress']
            pending_milestones = [m for m in milestones if m.status == 'Pending']
            
            # Financial data
            # Financial data - use Budget model
            budgets = Budget.query.filter_by(project_id=project.id).all()
            total_spent = sum(b.spent_amount or 0 for b in budgets)
            budget_remaining = (project.budget or 0) - total_spent
            
            # Use procurement requests as "payment requests" for project
            procurement_requests = ProcurementRequest.query.filter_by(project_id=project.id).all()
            pending_payments = [pr for pr in procurement_requests if pr.status == 'pending']
            approved_payments = [pr for pr in procurement_requests if pr.status == 'approved']
            payment_requests = procurement_requests  # For template compatibility
            
            # Procurement
            pending_procurement = pending_payments  # Same as pending payments
            
            # Recent DPRs
            recent_dprs = DailyProductionReport.query.filter_by(
                project_id=project.id
            ).order_by(DailyProductionReport.report_date.desc()).limit(10).all()
            
            # Project documents
            documents = Document.query.filter_by(project_id=project.id).all()
            
            # Issues from DPRs
            dprs_with_issues = DailyProductionReport.query.filter(
                DailyProductionReport.project_id == project.id,
                DailyProductionReport.issues.isnot(None),
                DailyProductionReport.issues != ''
            ).all()
            issues = [{'subject': f"DPR Issue - {dpr.report_date.strftime('%Y-%m-%d')}", 
                      'description': dpr.issues, 
                      'status': 'Open'} for dpr in dprs_with_issues]
            open_issues = issues  # All DPR issues are considered open
            
            # Schedule analysis
            if project.start_date and project.end_date:
                total_days = (project.end_date - project.start_date).days
                elapsed_days = (datetime.now().date() - project.start_date).days
                time_progress = (elapsed_days / total_days * 100) if total_days > 0 else 0
                
                completion = (len(completed_milestones) / len(milestones) * 100) if milestones else 0
                schedule_variance = completion - time_progress
                
                days_remaining = (project.end_date - datetime.now().date()).days
            else:
                time_progress = 0
                completion = 0
                schedule_variance = 0
                days_remaining = 0
            
            # Health status
            if schedule_variance >= 0 and budget_remaining >= 0:
                health_status = 'good'
            elif schedule_variance < -10 or budget_remaining < 0:
                health_status = 'critical'
            else:
                health_status = 'warning'
            
            return render_template('office_pm/project_details.html',
                project=project,
                milestones=milestones,
                completed_milestones=completed_milestones,
                in_progress_milestones=in_progress_milestones,
                pending_milestones=pending_milestones,
                budgets=budgets,
                total_spent=total_spent,
                budget_remaining=budget_remaining,
                payment_requests=payment_requests,
                pending_payments=pending_payments,
                approved_payments=approved_payments,
                procurement_requests=procurement_requests,
                pending_procurement=pending_procurement,
                recent_dprs=recent_dprs,
                documents=documents,
                issues=issues,
                open_issues=open_issues,
                time_progress=round(time_progress, 1),
                completion=round(completion, 1),
                schedule_variance=round(schedule_variance, 1),
                days_remaining=days_remaining,
                health_status=health_status
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading project details: {str(e)}", exc_info=True)
            flash('Error loading project details', 'error')
            return redirect(url_for('office_pm.dashboard'))
    
    
    @app.route('/project/<int:project_id>/staff')
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def project_staff(project_id):
        """View staff assigned to a project"""
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get staff assignments
            from models import EmployeeAssignment, Employee
            
            assignments = EmployeeAssignment.query.filter_by(
                project_id=project.id,
                status='Active'
            ).all()
            
            staff_list = []
            for assignment in assignments:
                employee = Employee.query.get(assignment.employee_id)
                if employee:
                    staff_list.append({
                        'id': employee.id,
                        'name': f"{employee.first_name} {employee.last_name}",
                        'staff_code': employee.staff_code,
                        'position': assignment.role or employee.position,
                        'assignment_date': assignment.start_date,
                        'department': employee.department,
                        'contact': employee.phone_number,
                        'email': employee.email,
                        'status': assignment.status
                    })
            
            # Get attendance/productivity metrics
            total_staff = len(staff_list)
            
            # Recent DPRs for labor count
            recent_dpr = DailyProductionReport.query.filter_by(
                project_id=project.id
            ).order_by(DailyProductionReport.report_date.desc()).first()
            
            current_onsite = recent_dpr.labor_count if recent_dpr else 0
            
            return render_template('office_pm/project_staff.html',
                project=project,
                staff_list=staff_list,
                total_staff=total_staff,
                current_onsite=current_onsite
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading project staff: {str(e)}", exc_info=True)
            flash('Error loading project staff', 'error')
            return redirect(url_for('office_pm.project_details', project_id=project_id))
    
    
    @app.route('/project/<int:project_id>/documents')
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def project_documents(project_id):
        """View and manage project documents"""
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get all project documents
            documents = Document.query.filter_by(project_id=project.id).order_by(
                Document.upload_date.desc()
            ).all()
            
            # Categorize documents
            doc_categories = {
                'contracts': [],
                'drawings': [],
                'permits': [],
                'reports': [],
                'photos': [],
                'other': []
            }
            
            for doc in documents:
                category = doc.document_type.lower() if doc.document_type else 'other'
                if category in doc_categories:
                    doc_categories[category].append(doc)
                else:
                    doc_categories['other'].append(doc)
            
            # Document statistics
            total_documents = len(documents)
            recent_uploads = [d for d in documents if d.upload_date and 
                            (datetime.now() - d.upload_date).days <= 7]
            
            return render_template('office_pm/project_documents.html',
                project=project,
                documents=documents,
                doc_categories=doc_categories,
                total_documents=total_documents,
                recent_uploads=len(recent_uploads)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading project documents: {str(e)}", exc_info=True)
            flash('Error loading project documents', 'error')
            return redirect(url_for('office_pm.project_details', project_id=project_id))
    
    
    @app.route('/project/<int:project_id>/documents/upload', methods=['POST'])
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def upload_project_document(project_id):
        """Upload a document to a project"""
        try:
            project = Project.query.get_or_404(project_id)
            
            if 'document' not in request.files:
                return jsonify({'success': False, 'message': 'No file uploaded'})
            
            file = request.files['document']
            if file.filename == '':
                return jsonify({'success': False, 'message': 'No file selected'})
            
            document_type = request.form.get('document_type', 'Other')
            description = request.form.get('description', '')
            
            # Save file
            import os
            from werkzeug.utils import secure_filename
            
            filename = secure_filename(file.filename)
            upload_folder = os.path.join('uploads', 'projects', str(project.id), 'documents')
            os.makedirs(upload_folder, exist_ok=True)
            
            # Add timestamp to filename to avoid duplicates
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            name, ext = os.path.splitext(filename)
            new_filename = f"{name}_{timestamp}{ext}"
            
            file_path = os.path.join(upload_folder, new_filename)
            file.save(file_path)
            
            # Create document record
            document = Document(
                project_id=project.id,
                document_type=document_type,
                file_name=new_filename,
                file_path=file_path,
                description=description,
                uploaded_by=current_user.id,
                upload_date=datetime.now()
            )
            
            db.session.add(document)
            
            # Add audit log
            audit = Audit(
                user_id=current_user.id,
                action='upload_document',
                table_name='documents',
                record_id=None,
                changes=f"Uploaded document: {new_filename} to {project.name}",
                timestamp=datetime.now()
            )
            db.session.add(audit)
            
            db.session.commit()
            
            return jsonify({
                'success': True, 
                'message': 'Document uploaded successfully',
                'document_id': document.id
            })
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error uploading document: {str(e)}", exc_info=True)
            return jsonify({'success': False, 'message': str(e)})
    
    
    @app.route('/project/<int:project_id>/daily-reports')
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def project_daily_reports(project_id):
        """View daily production reports for a project"""
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get date filter
            filter_date = request.args.get('date')
            if filter_date:
                filter_date = datetime.strptime(filter_date, '%Y-%m-%d').date()
            else:
                filter_date = datetime.now().date()
            
            # Get DPRs
            dprs = DailyProductionReport.query.filter_by(
                project_id=project.id
            ).order_by(DailyProductionReport.report_date.desc()).all()
            
            # Filter by date if specified
            if filter_date:
                dprs = [dpr for dpr in dprs if dpr.report_date.date() == filter_date]
            
            # Calculate metrics
            total_reports = len(DailyProductionReport.query.filter_by(project_id=project.id).all())
            
            if dprs:
                avg_productivity = sum(dpr.daily_progress or 0 for dpr in dprs) / len(dprs)
                avg_labor = sum(dpr.labor_count or 0 for dpr in dprs) / len(dprs)
            else:
                avg_productivity = 0
                avg_labor = 0
            
            # Recent 7 days productivity trend
            trend_data = []
            for i in range(7):
                day = datetime.now().date() - timedelta(days=i)
                day_dprs = [dpr for dpr in DailyProductionReport.query.filter_by(
                    project_id=project.id
                ).all() if dpr.report_date.date() == day]
                
                if day_dprs:
                    avg = sum(dpr.daily_progress or 0 for dpr in day_dprs) / len(day_dprs)
                else:
                    avg = 0
                
                trend_data.insert(0, {
                    'date': day.strftime('%b %d'),
                    'productivity': round(avg, 1)
                })
            
            return render_template('office_pm/project_daily_reports.html',
                project=project,
                dprs=dprs,
                filter_date=filter_date,
                total_reports=total_reports,
                avg_productivity=round(avg_productivity, 1),
                avg_labor=round(avg_labor, 1),
                trend_data=trend_data
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading daily reports: {str(e)}", exc_info=True)
            flash('Error loading daily reports', 'error')
            return redirect(url_for('office_pm.project_details', project_id=project_id))
    
    
    @app.route('/reports/create')
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def create_report():
        """Create custom reports"""
        try:
            projects = Project.query.all()
            
            return render_template('office_pm/create_report.html',
                projects=projects
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading create report page: {str(e)}", exc_info=True)
            flash('Error loading page', 'error')
            return redirect(url_for('office_pm.dashboard'))
    
    
    @app.route('/reports/generate', methods=['POST'])
    @login_required
    @role_required(['PROJECT_MANAGER', 'SUPER_HQ'])
    def generate_report():
        """Generate custom report based on criteria"""
        try:
            report_type = request.form.get('report_type')
            project_ids = request.form.getlist('project_ids')
            start_date = request.form.get('start_date')
            end_date = request.form.get('end_date')
            
            if start_date:
                start_date = datetime.strptime(start_date, '%Y-%m-%d')
            if end_date:
                end_date = datetime.strptime(end_date, '%Y-%m-%d')
            
            report_data = {}
            
            if report_type == 'financial':
                # Financial report - use Budget model for project expenses
                projects = Project.query.filter(Project.id.in_(project_ids)).all() if project_ids else Project.query.all()
                
                report_data['projects'] = []
                for project in projects:
                    # Get budgets for this project
                    budgets = Budget.query.filter_by(project_id=project.id)
                    if start_date:
                        budgets = budgets.filter(Budget.created_at >= start_date)
                    if end_date:
                        budgets = budgets.filter(Budget.created_at <= end_date)
                    
                    budgets = budgets.all()
                    total_spent = sum(b.spent_amount or 0 for b in budgets)
                    
                    report_data['projects'].append({
                        'name': project.name,
                        'budget': project.budget or 0,
                        'spent': total_spent,
                        'remaining': (project.budget or 0) - total_spent,
                        'utilization': round((total_spent / project.budget * 100) if project.budget else 0, 1)
                    })
            
            elif report_type == 'progress':
                # Progress report
                projects = Project.query.filter(Project.id.in_(project_ids)).all() if project_ids else Project.query.all()
                
                report_data['projects'] = []
                for project in projects:
                    milestones = Milestone.query.filter_by(project_id=project.id).all()
                    completed = len([m for m in milestones if m.status == 'Completed'])
                    
                    report_data['projects'].append({
                        'name': project.name,
                        'total_milestones': len(milestones),
                        'completed': completed,
                        'completion': round((completed / len(milestones) * 100) if milestones else 0, 1),
                        'status': project.status
                    })
            
            elif report_type == 'productivity':
                # Productivity report
                projects = Project.query.filter(Project.id.in_(project_ids)).all() if project_ids else Project.query.all()
                
                report_data['projects'] = []
                for project in projects:
                    dprs = DailyProductionReport.query.filter_by(project_id=project.id)
                    if start_date:
                        dprs = dprs.filter(DailyProductionReport.report_date >= start_date)
                    if end_date:
                        dprs = dprs.filter(DailyProductionReport.report_date <= end_date)
                    
                    dprs = dprs.all()
                    avg_productivity = sum(dpr.daily_progress or 0 for dpr in dprs) / len(dprs) if dprs else 0
                    
                    report_data['projects'].append({
                        'name': project.name,
                        'reports_count': len(dprs),
                        'avg_productivity': round(avg_productivity, 1),
                        'total_labor_days': sum(dpr.labor_count or 0 for dpr in dprs)
                    })
            
            return render_template('office_pm/generated_report.html',
                report_type=report_type,
                report_data=report_data,
                start_date=start_date,
                end_date=end_date,
                generated_at=datetime.now()
            )
            
        except Exception as e:
            current_app.logger.error(f"Error generating report: {str(e)}", exc_info=True)
            flash('Error generating report', 'error')
            return redirect(url_for('office_pm.create_report'))


    # ============================================================================
    # QS (QUANTITY SURVEYING) MANAGER ENDPOINTS
    # ============================================================================
    # Role: Responsible for cost estimation, valuation, and financial control
    # Responsibilities: BOQs, valuations, variations, claims, cost tracking
    # ============================================================================

    @app.route('/qs/dashboard', endpoint='qs.dashboard')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_dashboard():
        """
        QS Manager Dashboard - Overview of all project costs and valuations
        """
        try:
            # Get accessible projects
            if current_user.has_role(Roles.SUPER_HQ):
                projects = Project.query.filter_by(status='Active').all()
            else:
                # QS can see projects they're assigned to
                projects = Project.query.filter(
                    (Project.qs_manager == current_user.name) |
                    (Project.status == 'Active')
                ).all()
            
            # Calculate portfolio metrics
            total_contract_value = sum(p.budget or 0 for p in projects)
            
            # Total BOQ values across all projects
            total_boq_value = 0
            for project in projects:
                boq_items = BOQItem.query.filter_by(project_id=project.id, is_template=False).all()
                total_boq_value += sum(item.total_cost or 0 for item in boq_items)
            
            # Total spent from budgets
            total_spent = 0
            for project in projects:
                budgets = Budget.query.filter_by(project_id=project.id).all()
                total_spent += sum(b.spent_amount or 0 for b in budgets)
            
            # Pending valuations (using procurement requests as proxy for payment certificates)
            pending_valuations = ProcurementRequest.query.filter(
                ProcurementRequest.project_id.in_([p.id for p in projects]),
                ProcurementRequest.status == 'pending'
            ).count()
            
            # Recent cost variances
            cost_variances = CostVarianceReport.query.filter(
                CostVarianceReport.project_id.in_([p.id for p in projects])
            ).order_by(CostVarianceReport.id.desc()).limit(5).all()
            
            # Projects requiring attention (over budget)
            projects_over_budget = []
            projects_on_track = []
            
            for project in projects:
                budgets = Budget.query.filter_by(project_id=project.id).all()
                project_spent = sum(b.spent_amount or 0 for b in budgets)
                budget_remaining = (project.budget or 0) - project_spent
                
                utilization = (project_spent / project.budget * 100) if project.budget else 0
                
                project_data = {
                    'id': project.id,
                    'name': project.name,
                    'budget': project.budget or 0,
                    'spent': project_spent,
                    'remaining': budget_remaining,
                    'utilization': round(utilization, 1)
                }
                
                if utilization > 90:
                    projects_over_budget.append(project_data)
                else:
                    projects_on_track.append(project_data)
            
            # Recent activities
            recent_boq_updates = BOQItem.query.filter(
                BOQItem.project_id.in_([p.id for p in projects])
            ).order_by(BOQItem.updated_at.desc()).limit(10).all()
            
            return render_template('qs/dashboard.html',
                projects=projects,
                total_contract_value=total_contract_value,
                total_boq_value=total_boq_value,
                total_spent=total_spent,
                budget_remaining=total_contract_value - total_spent,
                pending_valuations=pending_valuations,
                cost_variances=cost_variances,
                projects_over_budget=projects_over_budget,
                projects_on_track=projects_on_track,
                recent_boq_updates=recent_boq_updates
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading QS dashboard: {str(e)}", exc_info=True)
            flash('Error loading dashboard', 'error')
            return redirect(url_for('main_home'))

    @app.route('/qs/project/<int:project_id>/boq', endpoint='qs.project_boq')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_project_boq(project_id):
        """
        View and manage BOQ (Bill of Quantities) for a specific project
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get BOQ items
            boq_items = BOQItem.query.filter_by(
                project_id=project.id,
                is_template=False
            ).order_by(BOQItem.bill_no, BOQItem.item_no).all()
            
            # Calculate totals by bill category
            bill_summaries = {}
            for item in boq_items:
                bill_no = item.bill_no or 'Uncategorized'
                if bill_no not in bill_summaries:
                    bill_summaries[bill_no] = {
                        'items': [],
                        'total': 0,
                        'count': 0
                    }
                bill_summaries[bill_no]['items'].append(item)
                bill_summaries[bill_no]['total'] += item.total_cost or 0
                bill_summaries[bill_no]['count'] += 1
            
            # Overall BOQ statistics
            total_boq_value = sum(item.total_cost or 0 for item in boq_items)
            total_items = len(boq_items)
            
            # Budget comparison
            budgets = Budget.query.filter_by(project_id=project.id).all()
            total_spent = sum(b.spent_amount or 0 for b in budgets)
            
            # Material schedules linked to BOQ
            material_schedules = MaterialSchedule.query.filter_by(
                project_id=project.id
            ).all()
            
            return render_template('qs/project_boq.html',
                project=project,
                boq_items=boq_items,
                bill_summaries=bill_summaries,
                total_boq_value=total_boq_value,
                total_items=total_items,
                total_spent=total_spent,
                budget_remaining=total_boq_value - total_spent,
                material_schedules=material_schedules
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading project BOQ: {str(e)}", exc_info=True)
            flash('Error loading BOQ', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/boq/add', methods=['POST'], endpoint='qs.add_boq_item')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_add_boq_item(project_id):
        """
        Add new BOQ item to project
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            data = request.get_json() if request.is_json else request.form
            
            # Create new BOQ item
            boq_item = BOQItem(
                project_id=project.id,
                bill_no=data.get('bill_no', '').strip(),
                item_no=data.get('item_no', '').strip(),
                item_description=data.get('item_description', '').strip(),
                quantity=float(data.get('quantity', 0)),
                unit=data.get('unit', '').strip(),
                unit_price=float(data.get('unit_price', 0)),
                item_type=data.get('item_type', '').strip(),
                category=data.get('category', '').strip(),
                is_template=False,
                status='Pending'
            )
            
            # Calculate total cost
            boq_item.calculate_total_cost()
            
            db.session.add(boq_item)
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action='add_boq_item',
                table_name='boq_items',
                record_id=None,
                changes=f"Added BOQ item: {boq_item.item_description} to {project.name}",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            if request.is_json:
                return jsonify({
                    'success': True,
                    'message': 'BOQ item added successfully',
                    'boq_item_id': boq_item.id
                })
            else:
                flash('BOQ item added successfully', 'success')
                return redirect(url_for('qs.project_boq', project_id=project.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error adding BOQ item: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': str(e)}), 500
            else:
                flash(f'Error adding BOQ item: {str(e)}', 'error')
                return redirect(url_for('qs.project_boq', project_id=project_id))

    @app.route('/qs/project/<int:project_id>/boq/<int:boq_id>/update', methods=['POST'], endpoint='qs.update_boq_item')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_update_boq_item(project_id, boq_id):
        """
        Update existing BOQ item
        """
        try:
            boq_item = BOQItem.query.get_or_404(boq_id)
            
            if boq_item.project_id != project_id:
                return jsonify({'success': False, 'message': 'BOQ item does not belong to this project'}), 400
            
            data = request.get_json() if request.is_json else request.form
            
            # Update fields
            if 'bill_no' in data:
                boq_item.bill_no = data['bill_no'].strip()
            if 'item_no' in data:
                boq_item.item_no = data['item_no'].strip()
            if 'item_description' in data:
                boq_item.item_description = data['item_description'].strip()
            if 'quantity' in data:
                boq_item.quantity = float(data['quantity'])
            if 'unit' in data:
                boq_item.unit = data['unit'].strip()
            if 'unit_price' in data:
                boq_item.unit_price = float(data['unit_price'])
            if 'status' in data:
                boq_item.status = data['status']
            if 'category' in data:
                boq_item.category = data['category'].strip()
            
            # Recalculate total cost
            boq_item.calculate_total_cost()
            boq_item.updated_at = datetime.now(timezone.utc)
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action='update_boq_item',
                table_name='boq_items',
                record_id=boq_item.id,
                changes=f"Updated BOQ item: {boq_item.item_description}",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            if request.is_json:
                return jsonify({
                    'success': True,
                    'message': 'BOQ item updated successfully',
                    'total_cost': boq_item.total_cost
                })
            else:
                flash('BOQ item updated successfully', 'success')
                return redirect(url_for('qs.project_boq', project_id=project_id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating BOQ item: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': str(e)}), 500
            else:
                flash(f'Error updating BOQ item: {str(e)}', 'error')
                return redirect(url_for('qs.project_boq', project_id=project_id))

    @app.route('/qs/project/<int:project_id>/valuations', endpoint='qs.project_valuations')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_project_valuations(project_id):
        """
        Manage valuations and interim payment applications for a project
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get procurement requests as valuation/payment certificates
            valuations = ProcurementRequest.query.filter_by(
                project_id=project.id
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Calculate valuation statistics
            total_valuations = len(valuations)
            approved_valuations = [v for v in valuations if v.status == 'approved']
            pending_valuations = [v for v in valuations if v.status == 'pending']
            
            total_approved_value = sum(v.price * v.qty for v in approved_valuations)
            total_pending_value = sum(v.price * v.qty for v in pending_valuations)
            
            # Get BOQ for reference
            boq_items = BOQItem.query.filter_by(
                project_id=project.id,
                is_template=False
            ).all()
            total_boq_value = sum(item.total_cost or 0 for item in boq_items)
            
            # Calculate work done percentage
            work_done_percentage = (total_approved_value / total_boq_value * 100) if total_boq_value > 0 else 0
            
            return render_template('qs/project_valuations.html',
                project=project,
                valuations=valuations,
                total_valuations=total_valuations,
                approved_valuations=approved_valuations,
                pending_valuations=pending_valuations,
                total_approved_value=total_approved_value,
                total_pending_value=total_pending_value,
                total_boq_value=total_boq_value,
                work_done_percentage=round(work_done_percentage, 2)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading valuations: {str(e)}", exc_info=True)
            flash('Error loading valuations', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/valuations/create', methods=['POST'], endpoint='qs.create_valuation')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_create_valuation(project_id):
        """
        Create new valuation/payment certificate
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            data = request.get_json() if request.is_json else request.form
            
            # Create valuation as procurement request
            valuation = ProcurementRequest(
                project_id=project.id,
                item_name=data.get('item_name', '').strip() or f"Valuation - {datetime.now().strftime('%Y-%m-%d')}",
                price=float(data.get('price', 0)),
                qty=float(data.get('qty', 1)),
                unit=data.get('unit', 'LS').strip(),
                status='pending',
                current_approver='Finance Manager',
                created_at=datetime.now(timezone.utc)
            )
            
            db.session.add(valuation)
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action='create_valuation',
                table_name='procurement_requests',
                record_id=None,
                changes=f"Created valuation for {project.name}: {valuation.price * valuation.qty:,.2f}",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            if request.is_json:
                return jsonify({
                    'success': True,
                    'message': 'Valuation created successfully',
                    'valuation_id': valuation.id
                })
            else:
                flash('Valuation created successfully', 'success')
                return redirect(url_for('qs.project_valuations', project_id=project.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating valuation: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': str(e)}), 500
            else:
                flash(f'Error creating valuation: {str(e)}', 'error')
                return redirect(url_for('qs.project_valuations', project_id=project_id))

    @app.route('/qs/project/<int:project_id>/variations', endpoint='qs.project_variations')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_project_variations(project_id):
        """
        Track variations and change orders for project
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get variations (using procurement requests with specific naming pattern)
            variations = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id,
                ProcurementRequest.item_name.like('%Variation%')
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Calculate variation statistics
            total_variations = len(variations)
            approved_variations = [v for v in variations if v.status == 'approved']
            pending_variations = [v for v in variations if v.status == 'pending']
            rejected_variations = [v for v in variations if v.status == 'rejected']
            
            total_variation_value = sum(v.price * v.qty for v in variations)
            approved_variation_value = sum(v.price * v.qty for v in approved_variations)
            
            # Original contract value
            original_value = project.budget or 0
            revised_value = original_value + approved_variation_value
            
            return render_template('qs/project_variations.html',
                project=project,
                variations=variations,
                total_variations=total_variations,
                approved_variations=approved_variations,
                pending_variations=pending_variations,
                rejected_variations=rejected_variations,
                total_variation_value=total_variation_value,
                approved_variation_value=approved_variation_value,
                original_value=original_value,
                revised_value=revised_value
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading variations: {str(e)}", exc_info=True)
            flash('Error loading variations', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/cost-summary', endpoint='qs.project_cost_summary')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_project_cost_summary(project_id):
        """
        Generate comprehensive cost summary and profitability analysis
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # BOQ Summary
            boq_items = BOQItem.query.filter_by(
                project_id=project.id,
                is_template=False
            ).all()
            
            total_boq_value = sum(item.total_cost or 0 for item in boq_items)
            
            # Actual costs from budgets
            budgets = Budget.query.filter_by(project_id=project.id).all()
            total_spent = sum(b.spent_amount or 0 for b in budgets)
            
            # Break down by category
            cost_by_category = {}
            for budget in budgets:
                category = budget.category or 'Uncategorized'
                if category not in cost_by_category:
                    cost_by_category[category] = {
                        'allocated': 0,
                        'spent': 0,
                        'remaining': 0
                    }
                cost_by_category[category]['allocated'] += budget.allocated_amount
                cost_by_category[category]['spent'] += budget.spent_amount
                cost_by_category[category]['remaining'] += budget.remaining_amount
            
            # Material costs
            material_schedules = MaterialSchedule.query.filter_by(
                project_id=project.id
            ).all()
            total_material_cost = sum(ms.total_cost or 0 for ms in material_schedules)
            
            # Variations
            variations = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id,
                ProcurementRequest.item_name.like('%Variation%'),
                ProcurementRequest.status == 'approved'
            ).all()
            total_variations = sum(v.price * v.qty for v in variations)
            
            # Financial summary
            contract_value = project.budget or 0
            revised_contract = contract_value + total_variations
            cost_to_date = total_spent
            projected_final_cost = total_boq_value
            estimated_profit = revised_contract - projected_final_cost
            profit_margin = (estimated_profit / revised_contract * 100) if revised_contract > 0 else 0
            
            # Cost variance
            cost_variance = total_boq_value - cost_to_date
            variance_percentage = (cost_variance / total_boq_value * 100) if total_boq_value > 0 else 0
            
            return render_template('qs/project_cost_summary.html',
                project=project,
                total_boq_value=total_boq_value,
                total_spent=total_spent,
                cost_by_category=cost_by_category,
                total_material_cost=total_material_cost,
                total_variations=total_variations,
                contract_value=contract_value,
                revised_contract=revised_contract,
                cost_to_date=cost_to_date,
                projected_final_cost=projected_final_cost,
                estimated_profit=estimated_profit,
                profit_margin=round(profit_margin, 2),
                cost_variance=cost_variance,
                variance_percentage=round(variance_percentage, 2)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error generating cost summary: {str(e)}", exc_info=True)
            flash('Error generating cost summary', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/material-takeoff', endpoint='qs.material_takeoff')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_material_takeoff(project_id):
        """
        Material take-off and cost verification with Procurement
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get material schedules
            material_schedules = MaterialSchedule.query.filter_by(
                project_id=project.id
            ).order_by(MaterialSchedule.material_name).all()
            
            # Categorize materials by status
            materials_by_status = {
                'Planned': [],
                'Ordered': [],
                'Delivered': [],
                'In Use': [],
                'Depleted': []
            }
            
            for material in material_schedules:
                status = material.status or 'Planned'
                if status in materials_by_status:
                    materials_by_status[status].append(material)
            
            # Calculate costs
            total_material_cost = sum(ms.total_cost or 0 for ms in material_schedules)
            ordered_cost = sum(ms.total_cost or 0 for ms in materials_by_status.get('Ordered', []))
            delivered_cost = sum(ms.total_cost or 0 for ms in materials_by_status.get('Delivered', []))
            
            # Link to BOQ items
            boq_linked_materials = []
            for material in material_schedules:
                if material.boq_item_id:
                    boq_item = BOQItem.query.get(material.boq_item_id)
                    if boq_item:
                        boq_linked_materials.append({
                            'material': material,
                            'boq_item': boq_item
                        })
            
            return render_template('qs/material_takeoff.html',
                project=project,
                material_schedules=material_schedules,
                materials_by_status=materials_by_status,
                total_material_cost=total_material_cost,
                ordered_cost=ordered_cost,
                delivered_cost=delivered_cost,
                boq_linked_materials=boq_linked_materials
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading material takeoff: {str(e)}", exc_info=True)
            flash('Error loading material takeoff', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/approve-valuation/<int:valuation_id>', methods=['POST'], endpoint='qs.approve_valuation')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_approve_valuation(valuation_id):
        """
        Approve or reject valuation
        """
        try:
            valuation = ProcurementRequest.query.get_or_404(valuation_id)
            
            data = request.get_json() if request.is_json else request.form
            action = data.get('action', 'approve')  # approve or reject
            comments = data.get('comments', '').strip()
            
            if action == 'approve':
                valuation.status = 'approved'
                valuation.approved_by = current_user.name
                valuation.approval_date = datetime.now(timezone.utc)
                message = 'Valuation approved successfully'
            else:
                valuation.status = 'rejected'
                message = 'Valuation rejected'
            
            valuation.approval_notes = comments
            valuation.updated_at = datetime.now(timezone.utc)
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action=f'{action}_valuation',
                table_name='procurement_requests',
                record_id=valuation.id,
                changes=f"{action.capitalize()}d valuation #{valuation.id}: {comments}",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            if request.is_json:
                return jsonify({'success': True, 'message': message})
            else:
                flash(message, 'success')
                return redirect(url_for('qs.project_valuations', project_id=valuation.project_id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error approving valuation: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': str(e)}), 500
            else:
                flash(f'Error: {str(e)}', 'error')
                return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/claims', endpoint='qs.project_claims')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_project_claims():
        """
        Claims management - track contractor claims, variations claims, and additional works
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get all claims (using procurement requests with 'Claim' in name)
            claims = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id,
                ProcurementRequest.item_name.like('%Claim%')
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Categorize claims
            approved_claims = [c for c in claims if c.status == 'approved']
            pending_claims = [c for c in claims if c.status == 'pending']
            rejected_claims = [c for c in claims if c.status == 'rejected']
            
            # Calculate claim values
            total_claims_value = sum(c.price * c.qty for c in claims)
            approved_claims_value = sum(c.price * c.qty for c in approved_claims)
            pending_claims_value = sum(c.price * c.qty for c in pending_claims)
            
            # Contract impact
            original_contract = project.budget or 0
            revised_contract = original_contract + approved_claims_value
            
            return render_template('qs/project_claims.html',
                project=project,
                claims=claims,
                approved_claims=approved_claims,
                pending_claims=pending_claims,
                rejected_claims=rejected_claims,
                total_claims_value=total_claims_value,
                approved_claims_value=approved_claims_value,
                pending_claims_value=pending_claims_value,
                original_contract=original_contract,
                revised_contract=revised_contract
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading claims: {str(e)}", exc_info=True)
            flash('Error loading claims', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/claims/create', methods=['POST'], endpoint='qs.create_claim')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_create_claim(project_id):
        """
        Create new claim for additional works or variations
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            data = request.get_json() if request.is_json else request.form
            
            claim = ProcurementRequest(
                project_id=project.id,
                item_name=f"Claim - {data.get('claim_description', '').strip()}",
                price=float(data.get('claim_amount', 0)),
                qty=1,
                unit='LS',
                status='pending',
                current_approver='Project Manager',
                created_at=datetime.now(timezone.utc)
            )
            
            db.session.add(claim)
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action='create_claim',
                table_name='procurement_requests',
                record_id=None,
                changes=f"Created claim for {project.name}: {claim.price:,.2f}",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            if request.is_json:
                return jsonify({'success': True, 'message': 'Claim created successfully', 'claim_id': claim.id})
            else:
                flash('Claim created successfully', 'success')
                return redirect(url_for('qs.project_claims', project_id=project.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating claim: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': str(e)}), 500
            else:
                flash(f'Error: {str(e)}', 'error')
                return redirect(url_for('qs.project_claims', project_id=project_id))

    @app.route('/qs/project/<int:project_id>/payment-applications', endpoint='qs.payment_applications')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_payment_applications():
        """
        Interim Payment Applications (IPAs) - Monthly payment certificates
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get all payment applications (valuations are payment apps)
            payment_apps = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Group by month
            apps_by_month = {}
            for app in payment_apps:
                month_key = app.created_at.strftime('%Y-%m') if app.created_at else 'Unknown'
                if month_key not in apps_by_month:
                    apps_by_month[month_key] = []
                apps_by_month[month_key].append(app)
            
            # Calculate cumulative values
            cumulative_approved = 0
            monthly_summary = []
            
            for month_key in sorted(apps_by_month.keys(), reverse=True):
                apps = apps_by_month[month_key]
                month_approved = sum(a.price * a.qty for a in apps if a.status == 'approved')
                cumulative_approved += month_approved
                
                monthly_summary.append({
                    'month': month_key,
                    'count': len(apps),
                    'month_value': month_approved,
                    'cumulative': cumulative_approved,
                    'apps': apps
                })
            
            # BOQ comparison
            boq_items = BOQItem.query.filter_by(project_id=project.id, is_template=False).all()
            total_boq = sum(item.total_cost or 0 for item in boq_items)
            
            payment_percentage = (cumulative_approved / total_boq * 100) if total_boq > 0 else 0
            
            return render_template('qs/payment_applications.html',
                project=project,
                payment_apps=payment_apps,
                monthly_summary=monthly_summary,
                total_boq=total_boq,
                cumulative_approved=cumulative_approved,
                payment_percentage=round(payment_percentage, 2)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading payment applications: {str(e)}", exc_info=True)
            flash('Error loading payment applications', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/subcontractor-payments', endpoint='qs.subcontractor_payments')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_subcontractor_payments():
        """
        Certify and track subcontractor payments
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get subcontractor payments (procurement requests)
            subcon_payments = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Group by status
            certified_payments = [p for p in subcon_payments if p.status == 'approved']
            pending_certification = [p for p in subcon_payments if p.status == 'pending']
            
            # Calculate totals
            total_certified = sum(p.price * p.qty for p in certified_payments)
            total_pending = sum(p.price * p.qty for p in pending_certification)
            
            # Get unique "subcontractors" (item names as proxy)
            subcontractors = {}
            for payment in subcon_payments:
                subcon_name = payment.item_name.split('-')[0].strip() if '-' in payment.item_name else payment.item_name
                if subcon_name not in subcontractors:
                    subcontractors[subcon_name] = {
                        'payments': [],
                        'total_certified': 0,
                        'total_pending': 0
                    }
                subcontractors[subcon_name]['payments'].append(payment)
                if payment.status == 'approved':
                    subcontractors[subcon_name]['total_certified'] += payment.price * payment.qty
                elif payment.status == 'pending':
                    subcontractors[subcon_name]['total_pending'] += payment.price * payment.qty
            
            return render_template('qs/subcontractor_payments.html',
                project=project,
                subcon_payments=subcon_payments,
                certified_payments=certified_payments,
                pending_certification=pending_certification,
                total_certified=total_certified,
                total_pending=total_pending,
                subcontractors=subcontractors
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading subcontractor payments: {str(e)}", exc_info=True)
            flash('Error loading subcontractor payments', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/cost-forecast', endpoint='qs.cost_forecast')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_cost_forecast():
        """
        Budget forecasting and projection to completion
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Current position
            budgets = Budget.query.filter_by(project_id=project.id).all()
            total_spent = sum(b.spent_amount or 0 for b in budgets)
            
            # BOQ analysis
            boq_items = BOQItem.query.filter_by(project_id=project.id, is_template=False).all()
            total_boq = sum(item.total_cost or 0 for item in boq_items)
            
            # Work done analysis
            approved_valuations = ProcurementRequest.query.filter_by(
                project_id=project.id,
                status='approved'
            ).all()
            work_done_value = sum(v.price * v.qty for v in approved_valuations)
            
            # Calculate completion percentage
            if project.start_date and project.end_date:
                total_days = (project.end_date - project.start_date).days
                elapsed_days = (datetime.now().date() - project.start_date).days
                time_elapsed_percentage = (elapsed_days / total_days * 100) if total_days > 0 else 0
            else:
                time_elapsed_percentage = 0
            
            work_done_percentage = (work_done_value / total_boq * 100) if total_boq > 0 else 0
            
            # Cost to Complete (ETC - Estimate to Complete)
            if work_done_percentage > 0:
                cost_per_percent = total_spent / work_done_percentage
                estimated_final_cost = cost_per_percent * 100
            else:
                estimated_final_cost = total_boq
            
            cost_to_complete = estimated_final_cost - total_spent
            
            # Forecast by category
            forecast_by_category = []
            for budget in budgets:
                spent_percentage = (budget.spent_amount / budget.allocated_amount * 100) if budget.allocated_amount > 0 else 0
                
                # Project final cost based on current burn rate
                if spent_percentage > 0:
                    projected_final = (budget.spent_amount / spent_percentage) * 100
                else:
                    projected_final = budget.allocated_amount
                
                forecast_by_category.append({
                    'category': budget.category,
                    'allocated': budget.allocated_amount,
                    'spent': budget.spent_amount,
                    'remaining': budget.remaining_amount,
                    'spent_percentage': round(spent_percentage, 1),
                    'projected_final': projected_final,
                    'variance': projected_final - budget.allocated_amount
                })
            
            # Performance indicators
            cost_performance_index = (work_done_value / total_spent) if total_spent > 0 else 0
            schedule_performance_index = (work_done_percentage / time_elapsed_percentage) if time_elapsed_percentage > 0 else 0
            
            return render_template('qs/cost_forecast.html',
                project=project,
                total_spent=total_spent,
                total_boq=total_boq,
                work_done_value=work_done_value,
                work_done_percentage=round(work_done_percentage, 2),
                time_elapsed_percentage=round(time_elapsed_percentage, 2),
                estimated_final_cost=estimated_final_cost,
                cost_to_complete=cost_to_complete,
                forecast_by_category=forecast_by_category,
                cost_performance_index=round(cost_performance_index, 2),
                schedule_performance_index=round(schedule_performance_index, 2)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading cost forecast: {str(e)}", exc_info=True)
            flash('Error loading cost forecast', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/rate-analysis', endpoint='qs.rate_analysis')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_rate_analysis():
        """
        Rate analysis and comparison - compare BOQ rates with market rates
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Get BOQ items
            boq_items = BOQItem.query.filter_by(
                project_id=project.id,
                is_template=False
            ).order_by(BOQItem.category, BOQItem.item_no).all()
            
            # Group by category for analysis
            items_by_category = {}
            for item in boq_items:
                category = item.category or 'Uncategorized'
                if category not in items_by_category:
                    items_by_category[category] = []
                items_by_category[category].append(item)
            
            # Calculate statistics by category
            category_stats = []
            for category, items in items_by_category.items():
                total_items = len(items)
                total_value = sum(item.total_cost or 0 for item in items)
                avg_unit_price = sum(item.unit_price for item in items) / total_items if total_items > 0 else 0
                
                category_stats.append({
                    'category': category,
                    'item_count': total_items,
                    'total_value': total_value,
                    'avg_unit_price': avg_unit_price,
                    'percentage_of_total': 0  # Will calculate after
                })
            
            # Calculate percentages
            total_project_value = sum(stat['total_value'] for stat in category_stats)
            for stat in category_stats:
                stat['percentage_of_total'] = (stat['total_value'] / total_project_value * 100) if total_project_value > 0 else 0
            
            # Sort by value
            category_stats.sort(key=lambda x: x['total_value'], reverse=True)
            
            return render_template('qs/rate_analysis.html',
                project=project,
                boq_items=boq_items,
                items_by_category=items_by_category,
                category_stats=category_stats,
                total_project_value=total_project_value
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading rate analysis: {str(e)}", exc_info=True)
            flash('Error loading rate analysis', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/project/<int:project_id>/cost-control-report', endpoint='qs.cost_control_report')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_cost_control_report():
        """
        Comprehensive cost control report for management
        """
        try:
            project = Project.query.get_or_404(project_id)
            
            # Financial summary
            original_contract = project.budget or 0
            
            # Variations and claims
            variations = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id,
                ProcurementRequest.item_name.like('%Variation%'),
                ProcurementRequest.status == 'approved'
            ).all()
            total_variations = sum(v.price * v.qty for v in variations)
            
            claims = ProcurementRequest.query.filter(
                ProcurementRequest.project_id == project.id,
                ProcurementRequest.item_name.like('%Claim%'),
                ProcurementRequest.status == 'approved'
            ).all()
            total_claims = sum(c.price * c.qty for c in claims)
            
            revised_contract = original_contract + total_variations + total_claims
            
            # Expenditure
            budgets = Budget.query.filter_by(project_id=project.id).all()
            total_expenditure = sum(b.spent_amount or 0 for b in budgets)
            
            # Commitments (pending payments)
            pending_payments = ProcurementRequest.query.filter_by(
                project_id=project.id,
                status='pending'
            ).all()
            total_commitments = sum(p.price * p.qty for p in pending_payments)
            
            # Forecast final cost
            projected_final_cost = total_expenditure + total_commitments
            
            # Variance analysis
            budget_variance = revised_contract - projected_final_cost
            variance_percentage = (budget_variance / revised_contract * 100) if revised_contract > 0 else 0
            
            # Risk assessment
            if variance_percentage < -10:
                risk_level = 'Critical'
                risk_color = 'red'
            elif variance_percentage < 0:
                risk_level = 'High'
                risk_color = 'orange'
            elif variance_percentage < 5:
                risk_level = 'Medium'
                risk_color = 'yellow'
            else:
                risk_level = 'Low'
                risk_color = 'green'
            
            # Monthly expenditure trend
            monthly_trend = []
            for i in range(6):
                month_date = datetime.now() - timedelta(days=30*i)
                month_name = month_date.strftime('%b %Y')
                
                # This is simplified - in production, you'd filter by actual date ranges
                monthly_trend.insert(0, {
                    'month': month_name,
                    'expenditure': total_expenditure / 6  # Simplified average
                })
            
            return render_template('qs/cost_control_report.html',
                project=project,
                original_contract=original_contract,
                total_variations=total_variations,
                total_claims=total_claims,
                revised_contract=revised_contract,
                total_expenditure=total_expenditure,
                total_commitments=total_commitments,
                projected_final_cost=projected_final_cost,
                budget_variance=budget_variance,
                variance_percentage=round(variance_percentage, 2),
                risk_level=risk_level,
                risk_color=risk_color,
                monthly_trend=monthly_trend
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading cost control report: {str(e)}", exc_info=True)
            flash('Error loading cost control report', 'error')
            return redirect(url_for('qs.dashboard'))

    @app.route('/qs/reports', endpoint='qs.reports')
    @login_required
    @role_required([Roles.SUPER_HQ, 'QS_MANAGER'])
    def qs_reports():
        """
        QS Reports hub - access all QS reports and analytics
        """
        try:
            # Get accessible projects
            if current_user.has_role(Roles.SUPER_HQ):
                projects = Project.query.filter_by(status='Active').all()
            else:
                projects = Project.query.filter(
                    (Project.qs_manager == current_user.name) |
                    (Project.status == 'Active')
                ).all()
            
            # Report types available
            report_types = [
                {
                    'name': 'Cost Summary Report',
                    'description': 'Comprehensive cost breakdown and profitability analysis',
                    'icon': 'chart-bar',
                    'url': 'qs.project_cost_summary'
                },
                {
                    'name': 'Cost Control Report',
                    'description': 'Budget performance, variance analysis, and risk assessment',
                    'icon': 'shield-check',
                    'url': 'qs.cost_control_report'
                },
                {
                    'name': 'Cost Forecast Report',
                    'description': 'Budget projection and estimate to complete',
                    'icon': 'trending-up',
                    'url': 'qs.cost_forecast'
                },
                {
                    'name': 'Payment Applications Report',
                    'description': 'Interim payment certificates and cumulative values',
                    'icon': 'receipt',
                    'url': 'qs.payment_applications'
                },
                {
                    'name': 'Rate Analysis Report',
                    'description': 'BOQ rate comparison and market analysis',
                    'icon': 'calculator',
                    'url': 'qs.rate_analysis'
                },
                {
                    'name': 'Claims Report',
                    'description': 'Contractor claims and additional works tracking',
                    'icon': 'file-text',
                    'url': 'qs.project_claims'
                }
            ]
            
            return render_template('qs/reports.html',
                projects=projects,
                report_types=report_types
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading QS reports: {str(e)}", exc_info=True)
            flash('Error loading reports', 'error')
            return redirect(url_for('qs.dashboard'))


    # ============================================================================
    # PROCUREMENT MANAGER ENDPOINTS (ENHANCED)
    # ============================================================================
    # Role: Manages all material and equipment purchases
    # Responsibilities: Source vendors, manage POs, track deliveries, cost control
    # ============================================================================

    @app.route('/procurement/manager/dashboard', endpoint='procurement_mgr.dashboard')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def procurement_manager_dashboard():
        """
        Enhanced Procurement Manager Dashboard with comprehensive metrics
        """
        try:
            # Get active projects
            if current_user.has_role(Roles.SUPER_HQ):
                projects = Project.query.filter_by(status='Active').all()
            else:
                projects = Project.query.filter_by(status='Active').limit(10).all()
            
            project_ids = [p.id for p in projects]
            
            # Purchase Orders Statistics
            total_pos = PurchaseOrder.query.filter(
                PurchaseOrder.project_id.in_(project_ids)
            ).count() if project_ids else PurchaseOrder.query.count()
            
            pending_pos = PurchaseOrder.query.filter(
                PurchaseOrder.status == 'Pending',
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).count()
            
            approved_pos = PurchaseOrder.query.filter(
                PurchaseOrder.status == 'Approved',
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).count()
            
            delivered_pos = PurchaseOrder.query.filter(
                PurchaseOrder.status == 'Delivered',
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).count()
            
            # Financial Metrics
            total_po_value = db.session.query(
                db.func.sum(PurchaseOrder.total_amount)
            ).filter(
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).scalar() or 0
            
            pending_po_value = db.session.query(
                db.func.sum(PurchaseOrder.total_amount)
            ).filter(
                PurchaseOrder.status.in_(['Pending', 'Approved']),
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).scalar() or 0
            
            delivered_po_value = db.session.query(
                db.func.sum(PurchaseOrder.total_amount)
            ).filter(
                PurchaseOrder.status == 'Delivered',
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).scalar() or 0
            
            # Procurement Requests
            pending_requests = ProcurementRequest.query.filter(
                ProcurementRequest.status == 'pending',
                ProcurementRequest.project_id.in_(project_ids) if project_ids else True
            ).count()
            
            # Supplier Statistics
            total_suppliers = Supplier.query.count()
            active_suppliers = Supplier.query.filter_by(status='Active').count()
            
            # Recent Activity - Purchase Orders
            recent_pos = PurchaseOrder.query.filter(
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).order_by(PurchaseOrder.created_at.desc()).limit(10).all()
            
            # Overdue Deliveries
            today = datetime.now().date()
            overdue_deliveries = PurchaseOrder.query.filter(
                PurchaseOrder.expected_delivery < today,
                PurchaseOrder.status.in_(['Approved', 'Ordered']),
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).all()
            
            # Supplier Performance - Top suppliers by volume
            top_suppliers = db.session.query(
                PurchaseOrder.supplier_name,
                db.func.count(PurchaseOrder.id).label('order_count'),
                db.func.sum(PurchaseOrder.total_amount).label('total_value')
            ).filter(
                PurchaseOrder.project_id.in_(project_ids) if project_ids else True
            ).group_by(PurchaseOrder.supplier_name).order_by(
                db.desc('total_value')
            ).limit(5).all()
            
            # Budget vs Spend Analysis per project
            project_budget_analysis = []
            for project in projects[:5]:  # Top 5 projects
                # Get procurement budget
                proc_budgets = Budget.query.filter_by(
                    project_id=project.id,
                    category='procurement'
                ).all()
                
                allocated = sum(b.allocated_amount for b in proc_budgets)
                
                # Get PO spend
                spent = db.session.query(
                    db.func.sum(PurchaseOrder.total_amount)
                ).filter(
                    PurchaseOrder.project_id == project.id,
                    PurchaseOrder.status.in_(['Approved', 'Ordered', 'Delivered'])
                ).scalar() or 0
                
                if allocated > 0:
                    project_budget_analysis.append({
                        'project': project,
                        'allocated': allocated,
                        'spent': spent,
                        'remaining': allocated - spent,
                        'utilization': round((spent / allocated * 100), 1)
                    })
            
            return render_template('procurement/manager/dashboard.html',
                total_pos=total_pos,
                pending_pos=pending_pos,
                approved_pos=approved_pos,
                delivered_pos=delivered_pos,
                total_po_value=total_po_value,
                pending_po_value=pending_po_value,
                delivered_po_value=delivered_po_value,
                pending_requests=pending_requests,
                total_suppliers=total_suppliers,
                active_suppliers=active_suppliers,
                recent_pos=recent_pos,
                overdue_deliveries=overdue_deliveries,
                top_suppliers=top_suppliers,
                project_budget_analysis=project_budget_analysis,
                projects=projects
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading procurement manager dashboard: {str(e)}", exc_info=True)
            flash('Error loading dashboard', 'error')
            return redirect(url_for('main_home'))

    @app.route('/procurement/manager/purchase-orders', endpoint='procurement_mgr.purchase_orders')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def procurement_purchase_orders():
        """
        Manage all purchase orders with filtering and search
        """
        try:
            # Get filter parameters
            status_filter = request.args.get('status', 'all')
            project_filter = request.args.get('project_id', type=int)
            supplier_filter = request.args.get('supplier')
            search_query = request.args.get('search', '').strip()
            
            # Build query
            query = PurchaseOrder.query
            
            if status_filter != 'all':
                query = query.filter(PurchaseOrder.status == status_filter)
            
            if project_filter:
                query = query.filter(PurchaseOrder.project_id == project_filter)
            
            if supplier_filter:
                query = query.filter(PurchaseOrder.supplier_name.ilike(f'%{supplier_filter}%'))
            
            if search_query:
                query = query.filter(
                    db.or_(
                        PurchaseOrder.order_number.ilike(f'%{search_query}%'),
                        PurchaseOrder.description.ilike(f'%{search_query}%'),
                        PurchaseOrder.supplier_name.ilike(f'%{search_query}%')
                    )
                )
            
            # Order by latest first
            purchase_orders = query.order_by(PurchaseOrder.created_at.desc()).all()
            
            # Get all projects and suppliers for filters
            projects = Project.query.filter_by(status='Active').all()
            suppliers = db.session.query(PurchaseOrder.supplier_name).distinct().all()
            supplier_list = [s[0] for s in suppliers if s[0]]
            
            return render_template('procurement/manager/purchase_orders.html',
                purchase_orders=purchase_orders,
                projects=projects,
                suppliers=supplier_list,
                status_filter=status_filter,
                project_filter=project_filter,
                supplier_filter=supplier_filter,
                search_query=search_query
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading purchase orders: {str(e)}", exc_info=True)
            flash('Error loading purchase orders', 'error')
            return redirect(url_for('procurement_mgr.dashboard'))

    @app.route('/procurement/manager/purchase-orders/create', methods=['GET', 'POST'], endpoint='procurement_mgr.create_po')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def create_purchase_order():
        """
        Create new purchase order
        """
        try:
            if request.method == 'GET':
                projects = Project.query.filter_by(status='Active').all()
                suppliers = Supplier.query.filter_by(status='Active').all()
                
                # Get material schedules for quick reference
                materials = MaterialSchedule.query.filter_by(status='Planned').all()
                
                return render_template('procurement/manager/create_po.html',
                    projects=projects,
                    suppliers=suppliers,
                    materials=materials
                )
            
            # POST - Create PO
            data = request.form
            
            # Generate PO number
            last_po = PurchaseOrder.query.order_by(PurchaseOrder.id.desc()).first()
            po_number = f"PO-{datetime.now().strftime('%Y%m')}-{(last_po.id + 1) if last_po else 1:04d}"
            
            # Create PO
            po = PurchaseOrder(
                order_number=po_number,
                project_id=int(data.get('project_id')) if data.get('project_id') else None,
                supplier_name=data.get('supplier_name', '').strip(),
                supplier_contact=data.get('supplier_contact', '').strip(),
                supplier_email=data.get('supplier_email', '').strip(),
                supplier_phone=data.get('supplier_phone', '').strip(),
                description=data.get('description', '').strip(),
                delivery_address=data.get('delivery_address', '').strip(),
                expected_delivery=datetime.strptime(data.get('expected_delivery'), '%Y-%m-%d').date() if data.get('expected_delivery') else None,
                priority=data.get('priority', 'Normal'),
                status='Draft',
                requested_by=current_user.id if hasattr(current_user, 'id') else None,
                notes=data.get('notes', '').strip()
            )
            
            db.session.add(po)
            db.session.flush()  # Get PO ID
            
            # Add line items
            item_names = request.form.getlist('item_name[]')
            item_descriptions = request.form.getlist('item_description[]')
            item_quantities = request.form.getlist('item_quantity[]')
            item_units = request.form.getlist('item_unit[]')
            item_prices = request.form.getlist('item_unit_price[]')
            
            subtotal = 0
            for i in range(len(item_names)):
                if item_names[i].strip():
                    qty = float(item_quantities[i])
                    unit_price = float(item_prices[i])
                    line_total = qty * unit_price
                    
                    line_item = PurchaseOrderLineItem(
                        purchase_order_id=po.id,
                        item_name=item_names[i].strip(),
                        description=item_descriptions[i].strip() if i < len(item_descriptions) else '',
                        quantity=qty,
                        unit=item_units[i].strip() if i < len(item_units) else 'pcs',
                        unit_price=unit_price,
                        line_total=line_total
                    )
                    db.session.add(line_item)
                    subtotal += line_total
            
            # Calculate totals
            tax_rate = float(data.get('tax_rate', 0))
            po.subtotal = subtotal
            po.tax_rate = tax_rate
            po.tax_amount = (subtotal * tax_rate / 100)
            po.total_amount = subtotal + po.tax_amount
            
            # Check if submitting for approval
            submit_for_approval = data.get('submit_for_approval') == 'yes'
            
            if submit_for_approval:
                # Import workflow utilities
                from utils.workflow import create_approval_workflow, log_audit as workflow_log_audit
                
                # Update PO status
                po.status = 'Pending_Cost_Control'
                
                # Create approval workflow
                workflow = create_approval_workflow(
                    workflow_type='purchase_order',
                    reference_id=po.id,
                    reference_number=po.order_number,
                    initiated_by=current_user.id,
                    total_amount=po.total_amount,
                    description=po.description or f"Purchase Order for {po.supplier_name}",
                    project_id=po.project_id,
                    priority=po.priority.lower() if po.priority else 'normal'
                )
                
                # Link workflow to PO
                po.workflow_id = workflow.id
                
                flash(f'Purchase Order {po.order_number} submitted for approval', 'success')
            else:
                flash(f'Purchase Order {po.order_number} created as draft', 'info')
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action='create_purchase_order',
                table_name='purchase_order',
                record_id=po.id,
                changes=f"Created PO {po.order_number} for {po.supplier_name}",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            return redirect(url_for('procurement_mgr.view_po', po_id=po.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating purchase order: {str(e)}", exc_info=True)
            flash(f'Error creating purchase order: {str(e)}', 'error')
            return redirect(url_for('procurement_mgr.purchase_orders'))

    @app.route('/procurement/manager/purchase-orders/<int:po_id>', endpoint='procurement_mgr.view_po')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def view_purchase_order(po_id):
        """
        View purchase order details
        """
        try:
            po = PurchaseOrder.query.get_or_404(po_id)
            
            # Get line items
            line_items = PurchaseOrderLineItem.query.filter_by(purchase_order_id=po.id).all()
            
            # Get related supplier info
            supplier = Supplier.query.filter_by(name=po.supplier_name).first()
            
            # Get project budget info
            project_budget = None
            if po.project_id:
                budgets = Budget.query.filter_by(
                    project_id=po.project_id,
                    category='procurement'
                ).all()
                
                if budgets:
                    allocated = sum(b.allocated_amount for b in budgets)
                    spent = sum(b.spent_amount for b in budgets)
                    project_budget = {
                        'allocated': allocated,
                        'spent': spent,
                        'remaining': allocated - spent
                    }
            
            return render_template('procurement/manager/view_po.html',
                po=po,
                line_items=line_items,
                supplier=supplier,
                project_budget=project_budget
            )
            
        except Exception as e:
            current_app.logger.error(f"Error viewing purchase order: {str(e)}", exc_info=True)
            flash('Error loading purchase order', 'error')
            return redirect(url_for('procurement_mgr.purchase_orders'))

    @app.route('/procurement/manager/purchase-orders/<int:po_id>/approve', methods=['POST'], endpoint='procurement_mgr.approve_po')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def approve_purchase_order(po_id):
        """
        Submit purchase order for approval workflow (Procurement  Cost Control  Finance)
        """
        try:
            po = PurchaseOrder.query.get_or_404(po_id)
            
            data = request.get_json() if request.is_json else request.form
            
            # Check if PO already has a workflow
            if po.workflow_id:
                message = f'Purchase Order {po.order_number} is already in approval workflow'
                if request.is_json:
                    return jsonify({'success': False, 'error': message}), 400
                flash(message, 'warning')
                return redirect(url_for('procurement_mgr.view_po', po_id=po.id))
            
            # Import workflow utilities
            from utils.workflow import create_approval_workflow
            
            # Update PO status to pending cost control approval
            po.status = 'Pending_Cost_Control'
            
            # Create approval workflow
            workflow = create_approval_workflow(
                workflow_type='purchase_order',
                reference_id=po.id,
                reference_number=po.order_number,
                initiated_by=current_user.id,
                total_amount=po.total_amount,
                description=po.description or f"Purchase Order for {po.supplier_name}",
                project_id=po.project_id,
                priority=po.priority.lower() if po.priority else 'normal'
            )
            
            # Link workflow to PO
            po.workflow_id = workflow.id
            
            # Log activity
            audit = Audit(
                user_id=current_user.id,
                action='submit_for_approval',
                table_name='purchase_order',
                record_id=po.id,
                changes=f"Submitted PO {po.order_number} for approval workflow",
                timestamp=datetime.now(timezone.utc)
            )
            db.session.add(audit)
            
            db.session.commit()
            
            message = f'Purchase Order {po.order_number} submitted for approval'
            
            if request.is_json:
                return jsonify({'success': True, 'message': message})
            else:
                flash(message, 'success')
                return redirect(url_for('procurement_mgr.view_po', po_id=po.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error submitting purchase order for approval: {str(e)}", exc_info=True)
            
            if request.is_json:
                return jsonify({'success': False, 'error': str(e)}), 500
            else:
                flash(f'Error submitting purchase order: {str(e)}', 'error')
                return redirect(url_for('procurement_mgr.view_po', po_id=po.id))
                flash(message, 'success')
                return redirect(url_for('procurement_mgr.view_po', po_id=po.id))
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error approving purchase order: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': str(e)}), 500
            else:
                flash(f'Error: {str(e)}', 'error')
                return redirect(url_for('procurement_mgr.view_po', po_id=po_id))

    @app.route('/procurement/manager/suppliers', endpoint='procurement_mgr.suppliers')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def manage_suppliers():
        """
        Supplier management - vetting, performance tracking
        """
        try:
            # Get unique supplier names from POs
            po_suppliers = db.session.query(
                PurchaseOrder.supplier_name,
                func.count(PurchaseOrder.id).label('total_pos'),
                func.sum(PurchaseOrder.total_amount).label('total_value')
            ).group_by(PurchaseOrder.supplier_name).all()
            
            suppliers = []
            total_on_time_rate = 0
            total_po_value = 0
            
            for supplier_name, total_pos, total_value in po_suppliers:
                # Get all POs for this supplier
                pos = PurchaseOrder.query.filter_by(supplier_name=supplier_name).all()
                
                completed_pos = len([p for p in pos if p.status == 'Delivered'])
                
                # Calculate on-time delivery
                delivered = [p for p in pos if p.status == 'Delivered' and p.expected_delivery and hasattr(p, 'delivery_date') and p.delivery_date]
                on_time = 0
                avg_delivery_days = None
                
                if delivered:
                    delivery_days = []
                    for p in delivered:
                        if p.delivery_date and p.expected_delivery:
                            days = (p.delivery_date - p.expected_delivery).days
                            delivery_days.append(days)
                            if days <= 0:  # On time or early
                                on_time += 1
                    
                    on_time_rate = (on_time / len(delivered) * 100) if delivered else 0
                    avg_delivery_days = sum(delivery_days) / len(delivery_days) if delivery_days else None
                else:
                    on_time_rate = 0
                
                # Get supplier contact info (from most recent PO)
                recent_po = pos[0] if pos else None
                
                suppliers.append({
                    'supplier_name': supplier_name,
                    'contact': recent_po.supplier_contact if recent_po else None,
                    'email': recent_po.supplier_email if recent_po else None,
                    'total_pos': total_pos,
                    'total_value': float(total_value) if total_value else 0,
                    'completed_pos': completed_pos,
                    'on_time_rate': round(on_time_rate, 1),
                    'avg_delivery_days': round(avg_delivery_days, 1) if avg_delivery_days else None,
                    'rating': min(5, max(1, int(on_time_rate / 20))) if on_time_rate > 0 else 3,  # Convert to 1-5 rating
                    'is_active': any(p.status in ['Pending', 'Approved', 'Ordered'] for p in pos)
                })
                
                total_on_time_rate += on_time_rate
                total_po_value += float(total_value) if total_value else 0
            
            # Calculate averages
            avg_on_time_rate = (total_on_time_rate / len(suppliers)) if suppliers else 0
            
            # Sort by total value
            suppliers.sort(key=lambda x: x['total_value'], reverse=True)
            
            return render_template('procurement/manager/suppliers.html',
                suppliers=suppliers,
                avg_on_time_rate=round(avg_on_time_rate, 1),
                total_po_value=total_po_value
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading suppliers: {str(e)}", exc_info=True)
            flash('Error loading suppliers', 'error')
            return redirect(url_for('procurement_mgr.dashboard'))

    @app.route('/procurement/manager/rfq', endpoint='procurement_mgr.rfq')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def manage_rfq():
        """
        Request for Quotations management
        """
        try:
            # Get procurement requests that need RFQs
            procurement_requests = ProcurementRequest.query.filter_by(
                status='Pending'
            ).order_by(ProcurementRequest.created_at.desc()).all()
            
            # Get material schedules that need procurement
            material_needs = MaterialSchedule.query.filter(
                MaterialSchedule.status.in_(['Pending', 'Planned'])
            ).all()
            
            # Group material needs by project
            material_needs_by_project = {}
            projects_with_needs = set()
            
            for material in material_needs:
                if material.project_id:
                    if material.project_id not in material_needs_by_project:
                        material_needs_by_project[material.project_id] = []
                    material_needs_by_project[material.project_id].append(material)
                    projects_with_needs.add(material.project_id)
            
            return render_template('procurement/manager/rfq.html',
                procurement_requests=procurement_requests,
                material_needs=material_needs,
                material_needs_by_project=material_needs_by_project,
                projects_with_needs=list(projects_with_needs)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading RFQ page: {str(e)}", exc_info=True)
            flash('Error loading RFQ management', 'error')
            return redirect(url_for('procurement_mgr.dashboard'))

    @app.route('/procurement/manager/delivery-tracking', endpoint='procurement_mgr.delivery_tracking')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def delivery_tracking():
        """
        Track deliveries and verify receipts
        """
        try:
            # Get all ordered/in-transit POs
            in_transit_pos = PurchaseOrder.query.filter(
                PurchaseOrder.status.in_(['Approved', 'Ordered'])
            ).order_by(PurchaseOrder.expected_delivery).all()
            
            # Recent deliveries (last 30 days)
            thirty_days_ago = datetime.now() - timedelta(days=30)
            recent_deliveries = PurchaseOrder.query.filter(
                PurchaseOrder.status == 'Delivered',
                PurchaseOrder.updated_at >= thirty_days_ago
            ).order_by(PurchaseOrder.updated_at.desc()).all()
            
            # Overdue deliveries
            today = datetime.now().date()
            overdue_pos = [po for po in in_transit_pos if po.expected_delivery and po.expected_delivery < today]
            
            # Delivery performance
            all_delivered = PurchaseOrder.query.filter_by(status='Delivered').all()
            on_time = 0
            late = 0
            
            for po in all_delivered:
                if po.expected_delivery and hasattr(po, 'delivery_date') and po.delivery_date:
                    if po.delivery_date <= po.expected_delivery:
                        on_time += 1
                    else:
                        late += 1
            
            on_time_percentage = (on_time / len(all_delivered) * 100) if all_delivered else 0
            
            return render_template('procurement/manager/delivery_tracking.html',
                in_transit_pos=in_transit_pos,
                recent_deliveries=recent_deliveries,
                overdue_pos=overdue_pos,
                on_time_count=on_time,
                late_count=late,
                on_time_percentage=round(on_time_percentage, 1)
            )
            
        except Exception as e:
            current_app.logger.error(f"Error loading delivery tracking: {str(e)}", exc_info=True)
            flash('Error loading delivery tracking', 'error')
            return redirect(url_for('procurement_mgr.dashboard'))

    @app.route('/procurement/manager/reports', endpoint='procurement_mgr.reports')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.HQ_PROCUREMENT, 'PROCUREMENT_MANAGER'])
    def procurement_reports():
        """
        Comprehensive procurement reports - cost vs budget, supplier performance
        """
        try:
            # Get date range and filters
            start_date = request.args.get('start_date')
            end_date = request.args.get('end_date')
            project_id = request.args.get('project_id', type=int)
            
            if not start_date:
                start_date = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d')
            if not end_date:
                end_date = datetime.now().strftime('%Y-%m-%d')
            
            start_dt = datetime.strptime(start_date, '%Y-%m-%d')
            end_dt = datetime.strptime(end_date, '%Y-%m-%d')
            
            # Build query
            query = PurchaseOrder.query.filter(
                PurchaseOrder.created_at.between(start_dt, end_dt)
            )
            
            if project_id:
                query = query.filter(PurchaseOrder.project_id == project_id)
            
            purchase_orders = query.order_by(PurchaseOrder.created_at.desc()).all()
            
            # Calculate metrics
            total_spend = sum(po.total_amount for po in purchase_orders)
            avg_po_value = total_spend / len(purchase_orders) if purchase_orders else 0
            
            # Spend by status (dictionary format)
            spend_by_status = {}
            for po in purchase_orders:
                if po.status not in spend_by_status:
                    spend_by_status[po.status] = 0
                spend_by_status[po.status] += po.total_amount
            
            # Top suppliers (list of dicts)
            supplier_totals = {}
            for po in purchase_orders:
                if po.supplier_name not in supplier_totals:
                    supplier_totals[po.supplier_name] = 0
                supplier_totals[po.supplier_name] += po.total_amount
            
            top_suppliers = [
                {'supplier_name': name, 'total_value': value}
                for name, value in sorted(supplier_totals.items(), key=lambda x: x[1], reverse=True)
            ]
            
            # Spend by project
            spend_by_project = []
            if project_id:
                projects = [Project.query.get(project_id)]
            else:
                projects = Project.query.filter_by(status='Active').all()
            
            total_budget = 0
            total_remaining = 0
            
            for project in projects:
                project_pos = [po for po in purchase_orders if po.project_id == project.id]
                project_spend = sum(po.total_amount for po in project_pos)
                
                budget = project.budget.total_budget if project.budget else 0
                remaining = budget - project_spend
                utilization = (project_spend / budget * 100) if budget > 0 else 0
                
                spend_by_project.append({
                    'project_name': project.name,
                    'total_budget': budget,
                    'total_spend': project_spend,
                    'remaining': remaining,
                    'utilization': utilization,
                    'po_count': len(project_pos)
                })
                
                total_budget += budget
                total_remaining += remaining
            
            # Calculate budget utilization
            budget_utilization = (total_spend / total_budget * 100) if total_budget > 0 else 0
            
            # Get all projects for filter dropdown
            projects_list = Project.query.filter_by(status='Active').all()
            
            return render_template('procurement/manager/reports.html',
                start_date=start_date,
                end_date=end_date,
                project_id=project_id,
                projects=projects_list,
                purchase_orders=purchase_orders,
                total_spend=total_spend,
                avg_po_value=avg_po_value,
                budget_utilization=budget_utilization,
                spend_by_status=spend_by_status,
                top_suppliers=top_suppliers,
                spend_by_project=spend_by_project,
                total_budget=total_budget,
                total_remaining=total_remaining
            )
            
        except Exception as e:
            current_app.logger.error(f"Error generating procurement reports: {str(e)}", exc_info=True)
            flash('Error generating reports', 'error')
            return redirect(url_for('procurement_mgr.dashboard'))


    # ============================================================================
    # ROUTES FROM PROJECT.PY
    # ============================================================================


    from werkzeug.utils import secure_filename
    from sqlalchemy import func


    def get_user_accessible_projects(user):
        """Get projects that the user has access to based on their role"""
        current_app.logger.info(f"Getting accessible projects for user {user.id} ({user.role})")
    
        if user.has_role(Roles.SUPER_HQ):
        # SUPER_HQ sees all projects
            projects = Project.query.all()
            current_app.logger.info(f"SUPER_HQ user - returning all {len(projects)} projects")
            return projects
        elif user.has_role(Roles.PROJECT_MANAGER):
        # Project managers see projects they manage AND projects they're assigned to
            managed_projects = Project.query.filter(Project.project_manager == user.name).all()
        
        # Also get projects assigned to them as staff
            assigned_projects_query = db.session.query(Project).join(
                StaffAssignment, Project.id == StaffAssignment.project_id
            ).filter(StaffAssignment.staff_id == user.id)
            assigned_projects = assigned_projects_query.all()
        
        # Combine and remove duplicates
            all_projects = managed_projects + assigned_projects
            unique_projects = list({project.id: project for project in all_projects}.values())
        
            current_app.logger.info(f"PROJECT_MANAGER user - {len(managed_projects)} managed, {len(assigned_projects)} assigned, {len(unique_projects)} total")
            return unique_projects
        else:
        # Staff see only assigned projects - check both User assignments and Employee assignments
            current_app.logger.info(f"Staff user - checking assignments for user {user.id}")
        
        # Get projects assigned to user directly
            user_projects_query = db.session.query(Project).join(
                StaffAssignment, Project.id == StaffAssignment.project_id
            ).filter(StaffAssignment.staff_id == user.id)
            user_projects = user_projects_query.all()
            current_app.logger.info(f"Found {len(user_projects)} direct user assignments")
        
        # Get projects assigned to user as employee (match by email or name)
            employee_projects = []
            try:
            # Find employee record that matches this user (by email first, then by name)
                employee = None
                if user.email:
                    employee = Employee.query.filter_by(email=user.email).first()
                    if employee:
                        current_app.logger.info(f"Found matching employee by email: {employee.name} (ID: {employee.id})")
                if not employee and user.name:
                    employee = Employee.query.filter_by(name=user.name).first()
                    if employee:
                        current_app.logger.info(f"Found matching employee by name: {employee.name} (ID: {employee.id})")
            
                if employee:
                # Get projects assigned to this employee
                    employee_projects_query = db.session.query(Project).join(
                        EmployeeAssignment, Project.id == EmployeeAssignment.project_id
                    ).filter(EmployeeAssignment.employee_id == employee.id)
                    employee_projects = employee_projects_query.all()
                    current_app.logger.info(f"Found {len(employee_projects)} employee assignments")
                else:
                    current_app.logger.info("No matching employee record found")
                
            except Exception as e:
                current_app.logger.error(f"Error getting employee projects for user {user.id}: {str(e)}")
                employee_projects = []
        
        # Combine both lists and remove duplicates
            all_projects = user_projects + employee_projects
            unique_projects = list({project.id: project for project in all_projects}.values())
        
            current_app.logger.info(f"Staff user - {len(user_projects)} user assignments + {len(employee_projects)} employee assignments = {len(unique_projects)} total projects")
        
            return unique_projects

    def get_user_accessible_project_ids(user):
        """Get project IDs that the user has access to"""
        projects = get_user_accessible_projects(user)
        return [p.id for p in projects]

# Dashboard
    @app.route('/project', endpoint='project.project_home')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def project_home():
        try:
            current_app.logger.info(f"User {current_user.id} ({current_user.role}) accessing project dashboard")
        
        # Filter projects based on user role and assignments using centralized function
            projects = get_user_accessible_projects(current_user)
            current_app.logger.info(f"User {current_user.id} ({current_user.role}) accessing {len(projects)} projects")
        
        # Get project statistics for user's projects only
            total_projects = len(projects)
            active_projects = len([p for p in projects if p.status in ['Active', 'In Progress']])
            completed_projects = len([p for p in projects if p.status == 'Completed'])
            planning_projects = len([p for p in projects if p.status == 'Planning'])
        
        # Calculate total budget and spent amounts for user's projects
            total_budget = sum([p.budget or 0 for p in projects])
            total_spent = 0  # This would come from expenses table in real system
        
        # Get recent activities for user's projects only
            recent_activities = []
            for project in projects[:5]:  # Last 5 projects
                recent_activities.append({
                    'project_name': project.name,
                    'activity': 'Project created' if project.status == 'Planning' else f'Status updated to {project.status}',
                    'timestamp': project.updated_at or project.created_at,
                    'user': project.project_manager or 'System'
                })
        
        # Enhanced project data with staff assignments and progress for user's projects
            enhanced_projects = []
            for project in projects:
                try:
                # Get user's role in this project
                    user_assignment = StaffAssignment.query.filter_by(
                        project_id=project.id, 
                        staff_id=current_user.id
                    ).first()
                    user_role_in_project = user_assignment.role if user_assignment else "Manager"
                
                # Get milestones for progress calculation
                    milestones = project.milestones if hasattr(project, 'milestones') else []
                    completed_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Completed']
                    progress = (len(completed_milestones) / len(milestones) * 100) if milestones else 0
                
                # Get all staff assignments for the project (for display)
                    all_staff_assignments = StaffAssignment.query.filter_by(project_id=project.id).all()
                
                    enhanced_project = {
                        'id': project.id,
                        'name': project.name,
                        'description': project.description or 'No description provided',
                        'status': project.status or 'Planning',
                        'progress': progress,
                        'manager': project.project_manager or 'Not assigned',
                        'created_at': project.created_at,  # Keep as datetime object
                        'updated_at': project.updated_at,  # Keep as datetime object
                        'start_date': project.start_date,  # Keep as datetime object
                        'end_date': project.end_date,  # Keep as datetime object
                        'budget': project.budget or 0,
                        'spent': project.budget * 0.6 if project.budget else 0,  # Simulated spent amount
                        'milestone_count': len(milestones),
                        'completed_milestones': len(completed_milestones),
                        'staff_count': len(all_staff_assignments),
                        'days_remaining': (project.end_date - datetime.now().date()).days if project.end_date else None,
                        'is_overdue': project.end_date and project.end_date < datetime.now().date() and project.status != 'Completed',
                        'priority': 'High' if project.budget and project.budget > 10000000 else 'Medium' if project.budget and project.budget > 5000000 else 'Normal',
                        'user_role': user_role_in_project,  # Current user's role in this project
                        'is_manager': project.project_manager == current_user.name,
                        'staff': {
                            'Project Manager': project.project_manager or 'Not assigned',
                            'Team Size': len(all_staff_assignments),
                            'User Role': user_role_in_project
                        }
                    }
                    enhanced_projects.append(enhanced_project)
                
                except Exception as e:
                    current_app.logger.error(f"Error processing project {project.id}: {str(e)}")
                # Fallback basic project data
                    enhanced_projects.append({
                        'id': project.id,
                        'name': project.name,
                        'description': project.description or 'No description provided',
                        'status': project.status or 'Planning',
                        'progress': project.progress or 0,
                        'manager': project.project_manager or 'Not assigned',
                        'created_at': project.created_at.strftime('%Y-%m-%d') if project.created_at else 'Unknown',
                        'start_date': project.start_date.strftime('%Y-%m-%d') if project.start_date else 'Not set',
                        'end_date': project.end_date.strftime('%Y-%m-%d') if project.end_date else 'Not set',
                        'budget': project.budget or 0,
                        'spent': 0,
                        'milestone_count': 0,
                        'completed_milestones': 0,
                        'staff_count': 0,
                        'days_remaining': None,
                        'is_overdue': False,
                        'priority': 'Normal',
                        'user_role': 'Member',
                        'is_manager': False,
                        'staff': {
                            'Project Manager': project.project_manager or 'Not assigned',
                            'Team Size': 0,
                            'User Role': 'Member'
                        }
                    })
        
            project_stats = {
                'total_projects': total_projects,
                'active_projects': active_projects,
                'completed_projects': completed_projects,
                'planning_projects': planning_projects,
                'total_budget': total_budget,
                'total_spent': total_spent,
                'completion_rate': (completed_projects / total_projects * 100) if total_projects > 0 else 0,
                'user_name': current_user.name,
                'user_role': current_user.role
            }
        
            return render_template('projects/index.html', 
                                 projects=enhanced_projects,
                                 project_stats=project_stats,
                                 recent_activities=recent_activities,
                                 current_user=current_user,
                                 current_date_obj=datetime.now().date())
                             
        except Exception as e:
            current_app.logger.error(f"Project dashboard error: {str(e)}", exc_info=True)
        # Fallback with empty data
            return render_template('projects/index.html', 
                                 projects=[],
                                 project_stats={
                                     'total_projects': 0,
                                     'active_projects': 0,
                                     'completed_projects': 0,
                                     'planning_projects': 0,
                                     'total_budget': 0,
                                     'total_spent': 0,
                                     'completion_rate': 0,
                                     'user_name': current_user.name if current_user.is_authenticated else 'Unknown',
                                     'user_role': current_user.role if current_user.is_authenticated else 'Unknown'
                                 },
                                 recent_activities=[],
                                 current_user=current_user,
                                 current_date_obj=datetime.now().date())


# Create Project - Only SUPER_HQ can create projects
    @app.route('/project/create', methods=['GET', 'POST'], endpoint='project.create_project')
    @login_required
    @role_required([Roles.SUPER_HQ])
    def create_project():
        try:
            if request.method == 'POST':
                name = request.form.get('name')
                manager_id = current_user.id
                status = request.form.get('status')
                description = request.form.get('description', '')
                if not all([name, manager_id, status]):
                    flash("Please fill in all required fields", "error")
                    return render_template('projects/create.html'), 400
                project = Project(name=name, manager_id=manager_id, status=status, description=description, created_at=datetime.now())
                db.session.add(project)
                db.session.commit()
                flash("Project created successfully!", "success")
                return redirect(url_for('project.project_home'))
            return render_template('projects/create.html')
        except Exception as e:
            db.session.rollback()
            current_app.logger.exception("Project creation error")
            flash("Failed to create project", "error")
            return render_template('error.html'), 500


# Assign Staff to Project - Only SUPER_HQ and Project Managers can assign staff
    @app.route('/project/<int:project_id>/assign-staff', methods=['POST'], endpoint='project.assign_staff')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def assign_staff(project_id):
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check if user has permission to assign staff to this project
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied staff assignment access to project {project_id}")
                flash("You don't have permission to assign staff to this project.", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
        
            staff_role = request.form.get('role')
            staff_id = request.form.get('staff_id')
            assignment = StaffAssignment(project_id=project_id, staff_id=staff_id, role=staff_role)
            db.session.add(assignment)
            db.session.commit()
            current_app.logger.info(f"Staff {staff_id} assigned to project {project_id} by user {current_user.id}")
            flash(f"{staff_role} assigned to project {project_id} successfully!", "success")
            return redirect(url_for('project.project_details', project_id=project_id))
        except Exception as e:
            db.session.rollback()
            flash(f"Error assigning staff: {str(e)}", "error")
            return redirect(url_for('project.project_details', project_id=project_id))


# View Project Details
    @app.route('/project/<int:project_id>', endpoint='project.project_details')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def project_details(project_id):
        try:
            current_app.logger.info(f"Project route: User {current_user.id} ({current_user.role}) accessing project {project_id}")
            project = Project.query.get_or_404(project_id)
        
        # Check if user has access to this project
            user_assignment = StaffAssignment.query.filter_by(
                project_id=project_id, 
                staff_id=current_user.id
            ).first()
        
        # Also check if user has access as an employee
            employee_assignment = None
            try:
            # Find employee record that matches this user
                employee = None
                if current_user.email:
                    employee = Employee.query.filter_by(email=current_user.email).first()
                if not employee and current_user.name:
                    employee = Employee.query.filter_by(name=current_user.name).first()
            
                if employee:
                    employee_assignment = EmployeeAssignment.query.filter_by(
                        project_id=project_id,
                        employee_id=employee.id
                    ).first()
            except Exception as e:
                current_app.logger.error(f"Error checking employee assignment for user {current_user.id}: {str(e)}")
                employee_assignment = None
        
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
        # Allow access if user is assigned (as user or employee), is the manager, or is SUPER_HQ
            if not (user_assignment or employee_assignment or is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied access to project {project_id}")
                flash("You don't have access to this project.", "error")
                return redirect(url_for('project.project_home'))
        
        # Get staff assignments with user details
            staff_assignments = db.session.query(StaffAssignment, User.name).join(
                User, StaffAssignment.staff_id == User.id
            ).filter(StaffAssignment.project_id == project_id).all()
        
        # Get available staff for assignment (exclude already assigned staff)
            assigned_staff_ids = [assignment.staff_id for assignment, _ in staff_assignments]
            available_staff = User.query.filter(
                User.id.notin_(assigned_staff_ids) if assigned_staff_ids else True
            ).all()
        
        # Get milestones with status counts
            milestones = Milestone.query.filter_by(project_id=project_id).all()
            completed_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Completed']
            pending_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Pending']
            overdue_milestones = [m for m in milestones if hasattr(m, 'status') and m.status == 'Pending' and hasattr(m, 'due_date') and m.due_date and m.due_date < datetime.now().date()]
        
        # Get schedules if they exist
            schedules = Schedule.query.filter_by(project_id=project_id).all() if hasattr(Schedule, 'project_id') else []
        
        # Get tasks for the project
            tasks = Task.query.filter_by(project_id=project_id).all()
            completed_tasks = [t for t in tasks if hasattr(t, 'status') and t.status == 'completed']
        
        # Calculate project metrics
            progress = project.progress or 0
            if milestones:
                milestone_progress = (len(completed_milestones) / len(milestones)) * 100
            # Use milestone progress if it differs significantly from stored progress
                if abs(milestone_progress - progress) > 5:
                    progress = milestone_progress
        
        # Budget calculations
            total_budget = project.budget or 0
        # Get total expenses for this project (if expense model has project_id)
            project_expenses = []
            if hasattr(Expense, 'project_id'):
                project_expenses = Expense.query.filter_by(project_id=project_id).all()
            elif hasattr(Expense, 'user_id'):
            # Fallback: if expenses are linked to users instead of projects
                assigned_user_ids = [assignment.staff_id for assignment, _ in staff_assignments]
                if assigned_user_ids:
                    project_expenses = Expense.query.filter(Expense.user_id.in_(assigned_user_ids)).all()
        
            spent_amount = sum(expense.amount for expense in project_expenses if hasattr(expense, 'amount'))
            remaining_budget = total_budget - spent_amount
            budget_utilization = (spent_amount / total_budget * 100) if total_budget > 0 else 0
        
        # Timeline calculations
            is_overdue = False
            days_remaining = None
            if project.end_date:
                today = datetime.now().date()
                if project.end_date < today:
                    is_overdue = True
                    days_remaining = (today - project.end_date).days
                else:
                    days_remaining = (project.end_date - today).days
        
        # Team statistics
            team_size = len(staff_assignments)
            team_roles = {}
            for assignment, staff_name in staff_assignments:
                role = assignment.role if hasattr(assignment, 'role') else 'Unknown'
                if role in team_roles:
                    team_roles[role] += 1
                else:
                    team_roles[role] = 1
        
        # Project health calculation
            health_status = "Good"
            if is_overdue or budget_utilization > 90:
                health_status = "Critical"
            elif progress < 50 and days_remaining and days_remaining < 30:
                health_status = "Warning"
            elif len(overdue_milestones) > 0:
                health_status = "Warning"
        
        # Recent activity (last 3 milestones or tasks)
            recent_milestones = []
            if milestones:
                recent_milestones = sorted([m for m in milestones if hasattr(m, 'due_date') and m.due_date], 
                                         key=lambda x: x.due_date, reverse=True)[:3]
        
            recent_tasks = []
            if tasks:
                recent_tasks = sorted([t for t in tasks if hasattr(t, 'updated_at') and t.updated_at], 
                                    key=lambda x: x.updated_at, reverse=True)[:3]
        
            return render_template('admin/view_project.html',
                                 project=project,
                                 staff_assignments=[{'assignment': assignment, 'staff_name': staff_name}
                                                  for assignment, staff_name in staff_assignments],
                                 available_staff=available_staff,
                                 milestones=milestones,
                                 schedules=schedules,
                                 tasks=tasks,
                             # Metrics
                                 progress=round(progress, 1),
                                 milestone_count=len(milestones),
                                 completed_milestones=len(completed_milestones),
                                 pending_milestones=len(pending_milestones),
                                 overdue_milestones=len(overdue_milestones),
                                 task_count=len(tasks),
                                 completed_tasks=len(completed_tasks),
                             # Budget
                                 total_budget=total_budget,
                                 spent_amount=spent_amount,
                                 remaining_budget=remaining_budget,
                                 budget_utilization=round(budget_utilization, 1),
                             # Timeline
                                 is_overdue=is_overdue,
                                 days_remaining=days_remaining,
                             # Team
                                 team_size=team_size,
                                 team_roles=team_roles,
                             # Health
                                 health_status=health_status,
                             # Recent activity
                                 recent_milestones=recent_milestones,
                                 recent_tasks=recent_tasks,
                             # Additional data for enhanced template
                                 boq_items=BOQItem.query.filter_by(project_id=project_id).all() if BOQItem else [],
                                 project_documents=ProjectDocument.query.filter_by(project_id=project_id).all() if ProjectDocument else [],
                                 activity_log=ProjectActivity.query.filter_by(project_id=project_id).order_by(ProjectActivity.created_at.desc()).limit(10).all() if ProjectActivity else [])
        except Exception as e:
            current_app.logger.error(f"Project details error: {str(e)}", exc_info=True)
            flash("Error loading project details", "error")
            return redirect(url_for('project.project_home'))


# API: List Projects (for AJAX)
    @app.route('/project/api/list', endpoint='project.list_projects')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def list_projects():
        try:
            projects = Project.query.order_by(Project.created_at.desc()).all()
        # Instead of returning JSON, redirect to project home which displays the list
            return redirect(url_for('project.project_home'))
        except Exception as e:
            flash(f"Error loading projects: {str(e)}", "error")
            return redirect(url_for('project.project_home'))
    
# Update Project - Only SUPER_HQ and Project Managers can edit their projects
    @app.route('/project/<int:project_id>/edit', methods=['GET', 'POST'], endpoint='project.edit_project')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def edit_project(project_id):
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check if user has permission to edit this project
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied edit access to project {project_id}")
                flash("You don't have permission to edit this project.", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
        
            if request.method == 'POST':
                project.name = request.form.get('name', project.name)
                project.status = request.form.get('status', project.status)
                project.description = request.form.get('description', project.description)
                project.updated_at = datetime.now(timezone.utc)
                db.session.commit()
                current_app.logger.info(f"Project {project_id} updated by user {current_user.id}")
                flash(f"Project {project_id} updated successfully!", "success")
                return redirect(url_for('project.project_details', project_id=project_id))
            return render_template('projects/edit.html', project=project)
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Project edit error: {str(e)}")
            flash("Error updating project", "error")
            return render_template('error.html'), 500


# Delete Project
    @app.route('/project/<int:project_id>/delete', methods=['POST'], endpoint='project.delete_project')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_project(project_id):
        try:
            project = Project.query.get_or_404(project_id)
            db.session.delete(project)
            db.session.commit()
            flash(f"Project {project_id} deleted successfully!", "success")
            return redirect(url_for('project.project_home'))
        except Exception as e:
            db.session.rollback()
            flash(f"Error deleting project: {str(e)}", "error")
            return redirect(url_for('project.project_home'))


# Project Timeline / Milestones - Allow project managers to manage their project milestones
    @app.route('/project/<int:project_id>/timeline', methods=['GET', 'POST'], endpoint='project.project_timeline')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def project_timeline(project_id):
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check if user has permission to manage milestones for this project
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied milestone access to project {project_id}")
                flash("You don't have permission to manage milestones for this project.", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
        
            if request.method == 'POST':
                title = request.form.get('title')
                due_date = request.form.get('due_date')
                status = request.form.get('status', 'Pending')
                milestone = Milestone(project_id=project_id, title=title, due_date=due_date, status=status)
                db.session.add(milestone)
                db.session.commit()
                current_app.logger.info(f"Milestone added to project {project_id} by user {current_user.id}")
                flash("Milestone added successfully!", "success")
            milestones = Milestone.query.filter_by(project_id=project_id).order_by(Milestone.due_date).all()
            return render_template('projects/timeline.html', milestones=milestones, project_id=project_id)
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Timeline error: {str(e)}")
            flash("Error loading timeline", "error")
            return render_template('error.html'), 500


# Project API: Staff Assignments
    @app.route('/project/<int:project_id>/api/staff', endpoint='project.project_staff_api')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def project_staff_api(project_id):
        try:
            staff = StaffAssignment.query.filter_by(project_id=project_id).all()
        # Instead of returning JSON, redirect to project details which shows staff
            return redirect(url_for('project.project_details', project_id=project_id))
        except Exception as e:
            flash(f"Error loading project staff: {str(e)}", "error")
            return redirect(url_for('project.project_details', project_id=project_id))


# Tasks Page
    @app.route('/project/tasks', endpoint='project.tasks')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def tasks():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
            current_app.logger.info(f"User {current_user.id} ({current_user.role}) accessing tasks for {len(accessible_projects)} projects")
        
        # Pass accessible projects to template for project selection
            return render_template('projects/tasks.html', 
                                 accessible_projects=accessible_projects,
                                 user_role=current_user.role)
        except Exception as e:
            current_app.logger.error(f"Tasks page error: {str(e)}")
            return render_template('error.html', error="Failed to load tasks"), 500


# Get milestones for a specific project (API endpoint)
    @app.route('/project/milestones/project/<int:project_id>', endpoint='project.get_project_milestones')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def get_project_milestones(project_id):
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
        # Validate project access
            if project_id not in accessible_project_ids:
                return jsonify({'error': 'Access denied to this project'}), 403
        
        # Get milestones for the project
            milestones = Milestone.query.filter_by(project_id=project_id).order_by(Milestone.due_date).all()
        
        # Convert to JSON
            milestones_data = []
            for milestone in milestones:
                milestones_data.append({
                    'id': milestone.id,
                    'title': milestone.title,
                    'due_date': milestone.due_date.isoformat(),
                    'status': milestone.status,
                    'description': getattr(milestone, 'description', ''),  # Handle case where description might not exist
                    'project_id': milestone.project_id
                })
        
            return jsonify({'milestones': milestones_data})
        
        except Exception as e:
            current_app.logger.error(f"Error loading project milestones: {str(e)}")
            return jsonify({'error': 'Failed to load milestones'}), 500


# Create milestone (API endpoint)
    @app.route('/project/milestones', methods=['POST'], endpoint='project.create_milestone')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def create_milestone():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
            project_id = request.form.get('project_id')
            title = request.form.get('title')
            due_date = request.form.get('due_date')
            status = request.form.get('status', 'Pending')
            description = request.form.get('description', '')
        
        # Validate required fields
            if not all([project_id, title, due_date]):
                return jsonify({'error': 'Project, title, and due date are required'}), 400
        
        # Validate project access
            if int(project_id) not in accessible_project_ids:
                return jsonify({'error': 'Access denied to this project'}), 403
        
        # Create milestone
            milestone = Milestone(
                project_id=int(project_id),
                title=title,
                due_date=datetime.strptime(due_date, '%Y-%m-%d').date(),
                status=status
            )
        
        # Add description if the model supports it
            if hasattr(milestone, 'description'):
                milestone.description = description
        
            db.session.add(milestone)
            db.session.commit()
        
            current_app.logger.info(f"Milestone '{title}' created for project {project_id} by user {current_user.id}")
        
            return jsonify({'status': 'success', 'message': 'Milestone created successfully'})
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error creating milestone: {str(e)}")
            return jsonify({'error': 'Failed to create milestone'}), 500


# Delete milestone (API endpoint)
    @app.route('/project/milestones/<int:milestone_id>/delete', methods=['POST'], endpoint='project.delete_milestone')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_milestone(milestone_id):
        try:
            milestone = Milestone.query.get_or_404(milestone_id)
        
        # Check project access
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
            if milestone.project_id not in accessible_project_ids:
                return jsonify({'error': 'Access denied to this project'}), 403
        
        # Delete milestone
            db.session.delete(milestone)
            db.session.commit()
        
            current_app.logger.info(f"Milestone {milestone_id} deleted by user {current_user.id}")
        
            return jsonify({'status': 'success', 'message': 'Milestone deleted successfully'})
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting milestone: {str(e)}")
            return jsonify({'error': 'Failed to delete milestone'}), 500


# Equipment Page - Filter by user's accessible projects
    @app.route('/project/equipment', methods=['GET', 'POST'], endpoint='project.equipment')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def equipment():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
        # Only SUPER_HQ and PROJECT_MANAGER can add/edit equipment
            can_manage = current_user.has_role(Roles.SUPER_HQ) or current_user.has_role(Roles.PROJECT_MANAGER)
        
            current_app.logger.info(f"User {current_user.id} ({current_user.role}) accessing equipment for {len(accessible_projects)} projects")
        
        # Get selected project from request
            selected_project_id = request.args.get('project_id') or request.form.get('project_id')
            selected_project = None
            equipment_list = []
        
            if selected_project_id:
                try:
                    selected_project_id = int(selected_project_id)
                    if selected_project_id in accessible_project_ids:
                        selected_project = Project.query.get(selected_project_id)
                except (ValueError, TypeError):
                    selected_project_id = None
        
        # Handle POST request (add new equipment)
            if request.method == 'POST' and 'add_equipment' in request.form:
                if not can_manage:
                    flash('You do not have permission to add equipment', 'error')
                    return redirect(url_for('project.equipment', project_id=selected_project_id))
            
                name = request.form.get('name')
                project_id = request.form.get('project_id')
                maintenance_due = request.form.get('maintenance_due')
                machine_hours = request.form.get('machine_hours', 0)
                diesel_consumption = request.form.get('diesel_consumption', 0)
                remarks = request.form.get('remarks', '')
                status = request.form.get('status', 'Active')
            
            # Validate required fields
                if not name or not project_id:
                    flash('Equipment name and project are required', 'error')
                    return redirect(url_for('project.equipment', project_id=project_id))
            
            # Validate project access
                if int(project_id) not in accessible_project_ids:
                    flash('You do not have access to the selected project', 'error')
                    return redirect(url_for('project.equipment'))
            
            # Create equipment record
                equipment = Equipment(
                    name=name,
                    project_id=int(project_id),
                    maintenance_due=datetime.strptime(maintenance_due, '%Y-%m-%d').date() if maintenance_due else None,
                    machine_hours=float(machine_hours) if machine_hours else 0,
                    diesel_consumption=float(diesel_consumption) if diesel_consumption else 0,
                    remarks=remarks,
                    status=status
                )
            
                try:
                    db.session.add(equipment)
                    db.session.commit()
                
                    current_app.logger.info(f"Equipment '{name}' added by user {current_user.id} for project {project_id}")
                    flash(f'Equipment "{name}" added successfully!', 'success')
                    return redirect(url_for('project.equipment', project_id=project_id))
                
                except Exception as e:
                    db.session.rollback()
                    current_app.logger.error(f"Database error during equipment creation: {str(e)}")
                    flash('Failed to add equipment', 'error')
                    return redirect(url_for('project.equipment', project_id=project_id))
        
        # GET request - load equipment for selected project
            if selected_project:
                equipment_list = Equipment.query.filter_by(project_id=selected_project.id).order_by(Equipment.maintenance_due).all()
        
            return render_template('projects/equipment.html', 
                                 equipment_list=equipment_list,
                                 accessible_projects=accessible_projects,
                                 selected_project=selected_project,
                                 can_manage=can_manage,
                                 user_role=current_user.role)
        except Exception as e:
            current_app.logger.error(f"Equipment page error: {str(e)}", exc_info=True)
            flash(f'Failed to load equipment page: {str(e)}', 'error')
            return redirect(url_for('project.project_home'))


# Edit Equipment
    @app.route('/project/equipment/<int:equipment_id>/edit', methods=['GET', 'POST'], endpoint='project.edit_equipment')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def edit_equipment(equipment_id):
        try:
            equipment = Equipment.query.get_or_404(equipment_id)
        
        # Check project access
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
            if equipment.project_id not in accessible_project_ids:
                flash('You do not have access to this equipment', 'error')
                return redirect(url_for('project.equipment', project_id=equipment.project_id))
        
            if request.method == 'POST':
                equipment.name = request.form.get('name')
                equipment.maintenance_due = datetime.strptime(request.form.get('maintenance_due'), '%Y-%m-%d').date() if request.form.get('maintenance_due') else None
                equipment.machine_hours = float(request.form.get('machine_hours', 0))
                equipment.diesel_consumption = float(request.form.get('diesel_consumption', 0))
                equipment.remarks = request.form.get('remarks', '')
                equipment.status = request.form.get('status', 'Active')
            
                try:
                    db.session.commit()
                    flash('Equipment updated successfully!', 'success')
                    return redirect(url_for('project.equipment', project_id=equipment.project_id))
                except Exception as e:
                    db.session.rollback()
                    current_app.logger.error(f"Error updating equipment: {str(e)}")
                    flash('Failed to update equipment', 'error')
                    return redirect(url_for('project.equipment', project_id=equipment.project_id))
        
        # GET request - show edit form
            accessible_projects_list = get_user_accessible_projects(current_user)
            return render_template('projects/edit_equipment.html',
                                 equipment=equipment,
                                 accessible_projects=accessible_projects_list,
                                 user_role=current_user.role)
                             
        except Exception as e:
            current_app.logger.error(f"Error editing equipment: {str(e)}")
            flash('Failed to edit equipment', 'error')
            return redirect(url_for('project.equipment'))


# Delete Equipment
    @app.route('/project/equipment/<int:equipment_id>/delete', methods=['POST'], endpoint='project.delete_equipment')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_equipment(equipment_id):
        try:
            equipment = Equipment.query.get_or_404(equipment_id)
            project_id = equipment.project_id
        
        # Check project access
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
            if equipment.project_id not in accessible_project_ids:
                flash('You do not have access to this equipment', 'error')
                return redirect(url_for('project.equipment', project_id=equipment.project_id))
        
            db.session.delete(equipment)
            db.session.commit()
        
            flash('Equipment deleted successfully!', 'success')
            return redirect(url_for('project.equipment', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting equipment: {str(e)}")
            flash('Failed to delete equipment', 'error')
            return redirect(url_for('project.equipment'))


# Materials Page - Filter by user's accessible projects
    @app.route('/project/materials', endpoint='project.materials')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def materials():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
            current_app.logger.info(f"User {current_user.id} ({current_user.role}) accessing materials for {len(accessible_projects)} projects")
        
        # For now, since Material model doesn't have project_id, we'll show all materials
        # but with context of accessible projects for future filtering
            materials_data = Material.query.order_by(Material.name).all()
        
        # In a real scenario, you might want to add project_id to Material model
        # For now, we'll pass accessible projects to the template for context
            return render_template('projects/materials.html', 
                                 materials=materials_data,
                                 accessible_projects=accessible_projects,
                                 user_role=current_user.role)
        except Exception as e:
            current_app.logger.error(f"Materials page error: {str(e)}")
            return render_template('error.html', error="Failed to load materials"), 500


# Analytics Page
    @app.route('/project/analytics', endpoint='project.analytics')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def analytics():
        from sqlalchemy import func
    
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
        # Get actual data from database
            current_date = datetime.now()
            current_year = current_date.year
        
        # Calculate real portfolio metrics
            total_projects = len(accessible_projects)
            active_projects = len([p for p in accessible_projects if p.status == 'Active'])
            completed_projects = len([p for p in accessible_projects if p.status == 'Completed'])
        
        # Calculate actual budget data from Budget and Expense models
            total_planned_value = 0
            total_actual_cost = 0
            total_earned_value = 0
        
            for project in accessible_projects:
            # Get project's actual budget allocations
                project_budgets = Budget.query.filter_by(project_id=project.id).all()
                project_allocated = sum(b.allocated_amount for b in project_budgets)
                project_spent = sum(b.spent_amount for b in project_budgets)
            
            # If no budget entries, use project.budget field
                if not project_budgets and project.budget:
                    project_allocated = project.budget
                # Estimate spent based on progress
                    if project.progress:
                        project_spent = project.budget * (project.progress / 100.0)
                    else:
                        project_spent = 0
            
                total_planned_value += project_allocated
                total_actual_cost += project_spent
            
            # Calculate earned value based on actual progress
                if project.progress and project_allocated:
                    total_earned_value += project_allocated * (project.progress / 100.0)
                elif project.status == 'Completed' and project_allocated:
                    total_earned_value += project_allocated
        
        # EVM Performance Indicators
            spi = total_earned_value / total_planned_value if total_planned_value > 0 else 0  # Schedule Performance Index
            cpi = total_earned_value / total_actual_cost if total_actual_cost > 0 else 0     # Cost Performance Index
        
        # Forecast calculations
            budget_at_completion = total_planned_value
            estimate_at_completion = budget_at_completion / cpi if cpi > 0 else budget_at_completion
            estimate_to_complete = estimate_at_completion - total_actual_cost
            variance_at_completion = budget_at_completion - estimate_at_completion
        
        # Get actual report data
            total_reports = Report.query.join(User).filter(User.id.in_([p.id for p in accessible_projects])).count() if accessible_projects else 0
            total_dprs = DailyProductionReport.query.filter(
                DailyProductionReport.project_id.in_([p.id for p in accessible_projects])
            ).count() if accessible_projects else 0
        
        # Get reports this month
            month_start = current_date.replace(day=1)
            reports_this_month = Report.query.filter(
                Report.date >= month_start,
                Report.uploader_id.in_([p.project_manager for p in accessible_projects if p.project_manager])
            ).count() if accessible_projects else 0
        
            dprs_this_month = DailyProductionReport.query.filter(
                DailyProductionReport.created_at >= month_start,
                DailyProductionReport.project_id.in_([p.id for p in accessible_projects])
            ).count() if accessible_projects else 0
        
        # Calculate monthly trending data based on actual progress
            pv_monthly = []
            ev_monthly = []
            ac_monthly = []
        
            for month in range(1, 13):
                month_factor = month / 12.0
                pv_monthly.append(int(total_planned_value * month_factor))
                ev_monthly.append(int(total_earned_value * month_factor))
                ac_monthly.append(int(total_actual_cost * month_factor))
        
        # Real quality metrics based on project data
            quality_index = calculate_real_quality_index(accessible_projects)
            safety_score = calculate_real_safety_score(accessible_projects)
        
        # Real resource utilization based on project assignments
            resource_data = calculate_real_resource_utilization(accessible_projects)
        
        # Material and equipment efficiency based on actual data
            material_efficiency = calculate_real_material_efficiency(accessible_projects)
            equipment_utilization = calculate_real_equipment_utilization(accessible_projects)
        
        # Risk assessment based on project characteristics
            portfolio_risk_score = calculate_real_portfolio_risk_score(accessible_projects)
        
        # Weather impact from DPR data
            weather_delays = calculate_real_weather_impact(accessible_projects)
        
        # Days without incident from DPR data
            days_without_incident = calculate_days_without_incident(accessible_projects)
        
        # Project status counts
            status_counts = {}
            for project in accessible_projects:
                status = project.status or 'Unknown'
                status_counts[status] = status_counts.get(status, 0) + 1
        
        # Compile real data
            data = {
            # Portfolio KPIs
                'portfolio_value': total_planned_value,
                'active_projects': active_projects,
                'completed_projects': completed_projects,
                'total_projects': total_projects,
            
            # EVM Metrics (actual calculations)
                'spi': round(spi, 3),
                'cpi': round(cpi, 3),
                'planned_value': total_planned_value,
                'earned_value': total_earned_value,
                'actual_cost': total_actual_cost,
                'eac': estimate_at_completion,
                'etc': estimate_to_complete,
                'vac': variance_at_completion,
            
            # Monthly trending data
                'pv_monthly': pv_monthly,
                'ev_monthly': ev_monthly,
                'ac_monthly': ac_monthly,
            
            # Real metrics
                'quality_index': quality_index,
                'safety_score': safety_score,
                'weather_delays': weather_delays,
                'days_without_incident': days_without_incident,
                'material_efficiency': material_efficiency,
                'equipment_utilization': equipment_utilization,
                'risk_score': portfolio_risk_score,
            
            # Report metrics
                'total_reports': total_reports,
                'total_dprs': total_dprs,
                'reports_this_month': reports_this_month,
                'dprs_this_month': dprs_this_month,
            
            # Resource data
                'resource_allocation': resource_data['allocation'],
                'resource_utilization': resource_data['utilization'],
            
            # Performance matrix data for table
                'performance_matrix': generate_real_performance_matrix(accessible_projects),
            
            # Legacy compatibility
                'project_status': status_counts,
                'budget_overview': {
                    'allocated': total_planned_value,
                    'spent': total_actual_cost,
                    'remaining': total_planned_value - total_actual_cost
                }
            }
        
            return render_template('projects/analytics.html', data=data, total_projects=total_projects)
        
        except Exception as e:
            current_app.logger.error(f"Analytics page error: {str(e)}")
            return render_template('error.html', error="Failed to load analytics"), 500


# Real Data Calculation Functions
    def calculate_real_quality_index(projects):
        """Calculate quality index based on actual project data"""
        if not projects:
            return 0
    
        total_quality = 0
        for project in projects:
        # Base quality score
            quality = 85
        
        # Adjust based on project completion and status
            if project.status == 'Completed':
                quality += 10  # Completed projects assumed higher quality
            elif project.status == 'Active' and project.progress:
            # Higher progress generally indicates better quality control
                if project.progress >= 80:
                    quality += 5
                elif project.progress >= 60:
                    quality += 3
        
        # Adjust based on budget performance (CPI)
            project_budgets = Budget.query.filter_by(project_id=project.id).all()
            if project_budgets:
                allocated = sum(b.allocated_amount for b in project_budgets)
                spent = sum(b.spent_amount for b in project_budgets)
                if allocated > 0 and spent > 0:
                    cpi = (project.progress or 0) / 100.0 * allocated / spent
                    if cpi >= 1.0:
                        quality += 3  # Good cost performance
                    elif cpi < 0.8:
                        quality -= 5  # Poor cost performance
        
            total_quality += min(100, max(60, quality))
    
        return round(total_quality / len(projects), 1)


    def calculate_real_safety_score(projects):
        """Calculate safety score based on project data and risk levels"""
        if not projects:
            return 0
    
        total_safety = 0
        for project in projects:
        # Base safety score
            safety = 88
        
        # Adjust based on risk level
            if project.risk_level == 'Low':
                safety += 5
            elif project.risk_level == 'High':
                safety -= 8
            elif project.risk_level == 'Critical':
                safety -= 15
        
        # Adjust based on safety requirements
            if project.safety_requirements == 'Enhanced':
                safety += 3
            elif project.safety_requirements == 'High Security':
                safety += 5
            elif project.safety_requirements == 'Specialized':
                safety += 7
        
        # Active projects with issues might have lower safety scores
            if project.status == 'Active':
            # Check for issues in DPRs
                recent_dprs = DailyProductionReport.query.filter(
                    DailyProductionReport.project_id == project.id,
                    DailyProductionReport.issues.isnot(None)
                ).limit(5).all()
            
                if len(recent_dprs) > 2:  # Multiple recent issues
                    safety -= 5
        
            total_safety += min(100, max(70, safety))
    
        return round(total_safety / len(projects), 1)


    def calculate_real_resource_utilization(projects):
        """Calculate resource allocation and utilization based on actual assignments"""
        if not projects:
            return {'allocation': {}, 'utilization': {}}
    
    # Get actual staff and employee assignments
    
    # Get staff assignments (no status field)
        staff_assignments = StaffAssignment.query.filter(
            StaffAssignment.project_id.in_([p.id for p in projects])
        ).all()
    
    # Get employee assignments (has status field)
        employee_assignments = EmployeeAssignment.query.filter(
            EmployeeAssignment.project_id.in_([p.id for p in projects])
        ).all()
    
    # Categorize by role
        allocation = {
            'engineers': 0,
            'supervisors': 0,
            'skilled_workers': 0,
            'general_labor': 0,
            'equipment_operators': 0
        }
    
        utilization = allocation.copy()
    
    # Process staff assignments (assume all active since no status field)
        for assignment in staff_assignments:
            if assignment.role:
                role_lower = assignment.role.lower()
                if 'engineer' in role_lower:
                    allocation['engineers'] += 1
                    utilization['engineers'] += 1  # Assume active
                elif 'supervisor' in role_lower or 'manager' in role_lower:
                    allocation['supervisors'] += 1
                    utilization['supervisors'] += 1
                elif 'skilled' in role_lower or 'technician' in role_lower:
                    allocation['skilled_workers'] += 1
                    utilization['skilled_workers'] += 1
                elif 'operator' in role_lower:
                    allocation['equipment_operators'] += 1
                    utilization['equipment_operators'] += 1
                else:
                    allocation['general_labor'] += 1
                    utilization['general_labor'] += 1
    
    # Process employee assignments (with status field)
        for assignment in employee_assignments:
            if assignment.role:
                role_lower = assignment.role.lower()
                if 'engineer' in role_lower:
                    allocation['engineers'] += 1
                    if assignment.status == 'Active':
                        utilization['engineers'] += 1
                elif 'supervisor' in role_lower or 'manager' in role_lower:
                    allocation['supervisors'] += 1
                    if assignment.status == 'Active':
                        utilization['supervisors'] += 1
                elif 'skilled' in role_lower or 'technician' in role_lower:
                    allocation['skilled_workers'] += 1
                    if assignment.status == 'Active':
                        utilization['skilled_workers'] += 1
                elif 'operator' in role_lower:
                    allocation['equipment_operators'] += 1
                    if assignment.status == 'Active':
                        utilization['equipment_operators'] += 1
                else:
                    allocation['general_labor'] += 1
                    if assignment.status == 'Active':
                        utilization['general_labor'] += 1
    
    # If no assignments found, return empty allocation
        if sum(allocation.values()) == 0:
            allocation = {'engineers': 0, 'supervisors': 0, 'skilled_workers': 0, 'general_labor': 0, 'equipment_operators': 0}
            utilization = {'engineers': 0, 'supervisors': 0, 'skilled_workers': 0, 'general_labor': 0, 'equipment_operators': 0}
    
        return {'allocation': allocation, 'utilization': utilization}


    def calculate_real_material_efficiency(projects):
        """Calculate material efficiency based on budget performance"""
        if not projects:
            return 92
    
        total_efficiency = 0
        project_count = 0
    
        for project in projects:
            if project.status in ['Active', 'Completed']:
            # Check budget efficiency for material categories
                material_budgets = Budget.query.filter(
                    Budget.project_id == project.id,
                    Budget.category.in_(['materials', 'procurement', 'supplies'])
                ).all()
            
                if material_budgets:
                    for budget in material_budgets:
                        if budget.allocated_amount > 0:
                            usage_efficiency = (budget.allocated_amount - budget.spent_amount) / budget.allocated_amount
                            efficiency = 85 + (usage_efficiency * 15)  # Convert to percentage
                            total_efficiency += min(98, max(75, efficiency))
                            project_count += 1
                else:
                # Use project-level budget if no material budgets
                    if project.budget and project.progress:
                        efficiency = 90 + (project.progress / 100 * 8)  # Higher progress = better efficiency
                        total_efficiency += min(98, max(80, efficiency))
                        project_count += 1
    
        if project_count == 0:
            return 92  # Default value
    
        return round(total_efficiency / project_count, 1)


    def calculate_real_equipment_utilization(projects):
        """Calculate equipment utilization based on project data"""
        if not projects:
            return 87
    
    # Base calculation on active projects
        active_projects = [p for p in projects if p.status == 'Active']
    
        if not active_projects:
            return 87
    
    # Higher utilization for projects with good progress
        total_utilization = 0
        for project in active_projects:
            if project.progress:
                if project.progress >= 80:
                    utilization = 92
                elif project.progress >= 60:
                    utilization = 88
                elif project.progress >= 40:
                    utilization = 85
                else:
                    utilization = 80
            else:
                utilization = 87
        
        # Adjust based on budget performance
            project_budgets = Budget.query.filter_by(project_id=project.id).all()
            if project_budgets:
                total_allocated = sum(b.allocated_amount for b in project_budgets)
                total_spent = sum(b.spent_amount for b in project_budgets)
                if total_allocated > 0:
                    budget_efficiency = total_spent / total_allocated
                    if budget_efficiency < 0.8:  # Under budget = efficient equipment use
                        utilization += 3
                    elif budget_efficiency > 1.2:  # Over budget = inefficient
                        utilization -= 5
        
            total_utilization += min(95, max(70, utilization))
    
        return round(total_utilization / len(active_projects), 1)


    def calculate_real_portfolio_risk_score(projects):
        """Calculate portfolio risk based on actual project risk levels"""
        if not projects:
            return 4
    
        risk_mapping = {
            'Low': 2,
            'Medium': 4,
            'High': 7,
            'Critical': 9
        }
    
        total_risk = 0
        for project in projects:
            project_risk = risk_mapping.get(project.risk_level, 4)
        
        # Adjust based on budget overruns
            project_budgets = Budget.query.filter_by(project_id=project.id).all()
            if project_budgets:
                for budget in project_budgets:
                    if budget.usage_percentage > 90:
                        project_risk += 1
        
        # Adjust based on project status
            if project.status == 'Active' and project.progress and project.progress < 50:
                project_risk += 0.5  # Behind schedule increases risk
        
            total_risk += min(10, project_risk)
    
        return round(total_risk / len(projects), 1)


    def calculate_real_weather_impact(projects):
        """Calculate weather delays from actual DPR data"""
        if not projects:
            return 0
    
    
    # Get current month's DPRs
        month_start = datetime.now().replace(day=1)
    
        dprs_with_weather_issues = DailyProductionReport.query.filter(
            DailyProductionReport.project_id.in_([p.id for p in projects]),
            DailyProductionReport.created_at >= month_start,
            DailyProductionReport.issues.like('%weather%')
        ).count()
    
        return dprs_with_weather_issues


    def calculate_days_without_incident(projects):
        """Calculate days without safety incidents from DPR data"""
        if not projects:
            return 0
    
    
    # Check last 90 days for incidents
        ninety_days_ago = datetime.now() - timedelta(days=90)
    
    # Look for DPRs with safety-related issues
        last_incident = DailyProductionReport.query.filter(
            DailyProductionReport.project_id.in_([p.id for p in projects]),
            DailyProductionReport.created_at >= ninety_days_ago,
            DailyProductionReport.issues.like('%incident%') | 
            DailyProductionReport.issues.like('%accident%') |
            DailyProductionReport.issues.like('%injury%') |
            DailyProductionReport.issues.like('%safety%')
        ).order_by(DailyProductionReport.created_at.desc()).first()
    
        if last_incident:
            days_since = (datetime.now() - last_incident.created_at).days
            return max(0, days_since)
        else:
        # No incidents found in last 90 days
            return 90


    def generate_real_performance_matrix(projects):
        """Generate performance matrix using real project data"""
        matrix_data = []
    
        for project in projects[:10]:  # Limit display
        # Get real budget data
            project_budgets = Budget.query.filter_by(project_id=project.id).all()
            planned_value = sum(b.allocated_amount for b in project_budgets) or project.budget or 0
            actual_cost = sum(b.spent_amount for b in project_budgets) or 0
        
        # Calculate earned value
            if project.progress and planned_value:
                earned_value = planned_value * (project.progress / 100.0)
            elif project.status == 'Completed':
                earned_value = planned_value
            else:
                earned_value = 0
        
        # Calculate performance indices
            spi = earned_value / planned_value if planned_value > 0 else 0
            cpi = earned_value / actual_cost if actual_cost > 0 else 0
        
            matrix_data.append({
                'project_name': project.name,
                'budget': planned_value,
                'spi': round(spi, 3),
                'cpi': round(cpi, 3),
                'quality': calculate_real_quality_index([project]),
                'safety': calculate_real_safety_score([project]),
                'status': project.status,
                'progress': project.progress or 0,
                'risk_level': project.risk_level or 'Medium'
            })
    
        return matrix_data


    @app.route('/project/analytics/data', endpoint='project.analytics_data')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def analytics_data():
        """API endpoint for real-time dashboard updates"""
    
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
        # Calculate current metrics
            total_pv = sum(p.budget or 0 for p in accessible_projects)
            total_ev = sum(calculate_earned_value(p) for p in accessible_projects)
            total_ac = sum(calculate_actual_cost(p) for p in accessible_projects)
        
            data = {
                'timestamp': datetime.now().isoformat(),
                'spi': round(total_ev / total_pv if total_pv > 0 else 0, 3),
                'cpi': round(total_ev / total_ac if total_ac > 0 else 0, 3),
                'portfolio_value': total_pv,
                'active_projects': len([p for p in accessible_projects if p.status == 'Active']),
                'quality_index': calculate_portfolio_quality_index(accessible_projects),
                'safety_score': calculate_portfolio_safety_score(accessible_projects),
                'weather_delays': sum(calculate_weather_impact(p) for p in accessible_projects),
                'evm_data': {
                    'pv': [int(total_pv * i / 12) for i in range(1, 13)],
                    'ev': [int(total_ev * i / 12) for i in range(1, 13)],
                    'ac': [int(total_ac * i / 12) for i in range(1, 13)]
                }
            }
        
            return jsonify(data)
        
        except Exception as e:
            current_app.logger.error(f"Analytics data API error: {str(e)}")
            return jsonify({'error': 'Failed to fetch analytics data'}), 500


# Construction PMO Calculation Functions
    def calculate_earned_value(project):
        """Calculate Earned Value based on project completion percentage"""
        if not project.budget:
            return 0
    
        if project.status == 'Completed':
            return project.budget
        elif project.status == 'Active':
        # Use project progress if available, otherwise simulate based on timeline
            if hasattr(project, 'progress') and project.progress:
                return int(project.budget * (project.progress / 100.0))
        
        # Simulate progress based on project timeline
            if hasattr(project, 'start_date') and project.start_date:
                days_elapsed = (datetime.now().date() - project.start_date).days
                if hasattr(project, 'end_date') and project.end_date:
                    total_days = (project.end_date - project.start_date).days
                    if total_days > 0:
                        progress = min(days_elapsed / total_days, 0.9)  # Cap at 90% for active projects
                        return int(project.budget * progress)
        
        # Default to 60% for active projects without dates
            return int(project.budget * 0.6)
        else:
            return 0


    def calculate_actual_cost(project):
        """Calculate Actual Cost incurred"""
        if not project.budget:
            return 0
    
        if project.status == 'Completed':
        # Completed projects typically have slight cost overrun
            return int(project.budget * 1.05)
        elif project.status == 'Active':
        # Active projects have spent proportional to earned value with some variance
            earned_value = calculate_earned_value(project)
            cost_efficiency = 0.95  # Assuming 5% cost efficiency
            return int(earned_value / cost_efficiency)
        else:
            return 0


    def calculate_quality_index(project):
        """Construction Quality Index (0-100)"""
        base_quality = 85  # Base quality score
    
    # Adjust based on project characteristics
        if project.status == 'Completed':
            return base_quality + 10  # Completed projects typically have higher quality scores
        elif project.status == 'Active':
            return base_quality + (hash(str(project.id)) % 10)  # Simulate variance
        else:
            return base_quality


    def calculate_safety_score(project):
        """Construction Safety Score (0-100)"""
        base_safety = 88  # Base safety score
    
    # Simulate variance based on project characteristics
        if project.status == 'Active':
            variance = (hash(str(project.id) + 'safety') % 8) - 4  # +/- 4 points variance
            return max(75, min(100, base_safety + variance))
    
        return base_safety


    def calculate_weather_impact(project):
        """Weather delay days this month"""
        if project.status == 'Active':
            return (hash(str(project.id) + 'weather') % 6)  # 0-5 delay days
        return 0


    def calculate_material_efficiency(project):
        """Material utilization efficiency percentage"""
        base_efficiency = 92
        if project.status == 'Active':
            variance = (hash(str(project.id) + 'material') % 6) - 3  # +/- 3% variance
            return max(85, min(98, base_efficiency + variance))
        return base_efficiency


    def calculate_equipment_utilization(project):
        """Equipment utilization percentage"""
        base_utilization = 87
        if project.status == 'Active':
            variance = (hash(str(project.id) + 'equipment') % 8) - 4  # +/- 4% variance
            return max(75, min(95, base_utilization + variance))
        return base_utilization


    def calculate_project_risk_score(project):
        """Project risk score (1-10, where 10 is highest risk)"""
        base_risk = 4  # Medium risk
    
    # Adjust based on project budget (larger projects = higher risk)
        if project.budget:
            if project.budget > 10000000:  # $10M+
                base_risk += 2
            elif project.budget > 5000000:  # $5M+
                base_risk += 1
    
    # Active projects have higher current risk
        if project.status == 'Active':
            base_risk += 1
    
        return min(10, base_risk)


    def get_critical_path_tasks(project):
        """Get critical path tasks for the project"""
    # In a real system, this would analyze the project schedule
    # For simulation, return sample critical tasks
        critical_tasks = [
            {'name': 'Foundation Work', 'duration': 14, 'status': 'completed'},
            {'name': 'Structural Steel', 'duration': 21, 'status': 'in_progress'},
            {'name': 'Electrical Rough-in', 'duration': 10, 'status': 'pending'},
            {'name': 'Final Inspection', 'duration': 3, 'status': 'pending'}
        ]
    
        return critical_tasks


    def generate_performance_matrix(projects):
        """Generate performance matrix data for all projects"""
        matrix_data = []
    
        for project in projects[:10]:  # Limit to first 10 projects for display
            earned_value = calculate_earned_value(project)
            actual_cost = calculate_actual_cost(project)
            planned_value = project.budget or 0
        
            spi = earned_value / planned_value if planned_value > 0 else 0
            cpi = earned_value / actual_cost if actual_cost > 0 else 0
        
            matrix_data.append({
                'project_name': project.name,
                'budget': planned_value,
                'spi': round(spi, 3),
                'cpi': round(cpi, 3),
                'quality': calculate_quality_index(project),
                'safety': calculate_safety_score(project),
                'status': project.status,
                'risk_level': 'High' if calculate_project_risk_score(project) > 7 else 
                            'Medium' if calculate_project_risk_score(project) > 4 else 'Low'
            })
    
        return matrix_data


    def calculate_portfolio_quality_index(projects):
        """Calculate overall portfolio quality index"""
        if not projects:
            return 0
    
        total_quality = sum(calculate_quality_index(p) for p in projects)
        return round(total_quality / len(projects), 1)


    def calculate_portfolio_safety_score(projects):
        """Calculate overall portfolio safety score"""
        if not projects:
            return 0
    
        total_safety = sum(calculate_safety_score(p) for p in projects)
        return round(total_safety / len(projects), 1)


    def calculate_portfolio_material_efficiency(projects):
        """Calculate overall portfolio material efficiency"""
        if not projects:
            return 0
    
        total_efficiency = sum(calculate_material_efficiency(p) for p in projects)
        return round(total_efficiency / len(projects), 1)


    def calculate_portfolio_equipment_utilization(projects):
        """Calculate overall portfolio equipment utilization"""
        if not projects:
            return 0
    
        total_utilization = sum(calculate_equipment_utilization(p) for p in projects)
        return round(total_utilization / len(projects), 1)


    def calculate_portfolio_risk_score(projects):
        """Calculate overall portfolio risk score"""
        if not projects:
            return 0
    
        total_risk = sum(calculate_project_risk_score(p) for p in projects)
        return round(total_risk / len(projects), 1)


# Calendar Page
    @app.route('/project/calendar', endpoint='project.calendar')
    @login_required
    def project_calendar():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
        # Get selected project from query parameter
            selected_project_id = request.args.get('project_id', type=int)
            if selected_project_id and selected_project_id in [p['id'] for p in accessible_projects]:
            # Load events for selected project
                events = get_project_calendar_events(selected_project_id)
                selected_project = Project.query.get(selected_project_id)
            else:
                events = []
                selected_project = None
            
            return render_template('projects/calendar.html', 
                                 accessible_projects=accessible_projects,
                                 selected_project=selected_project,
                                 calendar={'events': events})
        except Exception as e:
            current_app.logger.error(f"Calendar page error: {str(e)}")
            return render_template('error.html', error="Failed to load calendar"), 500

    @app.route('/project/calendar/events/<int:project_id>', endpoint='project.get_calendar_events')
    @login_required
    def get_calendar_events(project_id):
        """API endpoint to get calendar events for a specific project"""
        try:
        # Verify user has access to this project
            accessible_projects = get_user_accessible_projects(current_user)
            if project_id not in [p['id'] for p in accessible_projects]:
                return jsonify({'error': 'Access denied'}), 403
            
            events = get_project_calendar_events(project_id)
            return jsonify({'status': 'success', 'events': events})
        except Exception as e:
            current_app.logger.error(f"Error loading calendar events: {str(e)}")
            return jsonify({'error': 'Failed to load events'}), 500

    def get_project_calendar_events(project_id):
        """Helper function to get all calendar events for a project"""
        events = []
    
    # Get the project
        project = Project.query.get(project_id)
        if not project:
            return events
    
    # Project start and end dates
        if project.start_date:
            events.append({
                'id': f"project-start-{project.id}",
                'title': f" {project.name} - Start",
                'start': project.start_date.strftime('%Y-%m-%d'),
                'type': 'project-start',
                'backgroundColor': '#10B981',
                'borderColor': '#059669',
                'description': f"Project start date"
            })
    
        if project.end_date:
            events.append({
                'id': f"project-end-{project.id}",
                'title': f" {project.name} - End",
                'start': project.end_date.strftime('%Y-%m-%d'),
                'type': 'project-end',
                'backgroundColor': '#EF4444',
                'borderColor': '#DC2626',
                'description': f"Project end date"
            })
    
    # Milestones
        milestones = Milestone.query.filter_by(project_id=project_id).all()
        for milestone in milestones:
            if milestone.due_date:
                color = '#8B5CF6' if milestone.status == 'Pending' else '#10B981' if milestone.status == 'Completed' else '#F59E0B'
                events.append({
                    'id': f"milestone-{milestone.id}",
                    'title': f" {milestone.title}",
                    'start': milestone.due_date.strftime('%Y-%m-%d'),
                    'type': 'milestone',
                    'backgroundColor': color,
                    'borderColor': color,
                    'description': f"Milestone: {milestone.title} - Status: {milestone.status}"
                })
    
    # Tasks with due dates
        tasks = Task.query.filter_by(project_id=project_id).filter(Task.due_date.isnot(None)).all()
        for task in tasks:
            color = '#6B7280' if task.status == 'pending' else '#10B981' if task.status == 'completed' else '#F59E0B'
            events.append({
                'id': f"task-{task.id}",
                'title': f" {task.title}",
                'start': task.due_date.strftime('%Y-%m-%d'),
                'type': 'task',
                'backgroundColor': color,
                'borderColor': color,
                'description': f"Task: {task.title} - Status: {task.status}"
            })
    
    # Schedules
        schedules = Schedule.query.filter_by(project_id=project_id).all()
        for schedule in schedules:
            events.append({
                'id': f"schedule-{schedule.id}",
                'title': f" {schedule.title}",
                'start': schedule.start_time.strftime('%Y-%m-%dT%H:%M:%S'),
                'end': schedule.end_time.strftime('%Y-%m-%dT%H:%M:%S'),
                'type': 'schedule',
                'backgroundColor': '#3B82F6',
                'borderColor': '#2563EB',
                'description': f"Schedule: {schedule.title} - Type: {schedule.type}"
            })
    
    # DPR submissions for the project
        dprs = DailyProductionReport.query.filter_by(project_id=project_id).all()
        for dpr in dprs:
            if dpr.completed_at:  # Use completed_at instead of submitted_at
                events.append({
                    'id': f"dpr-{dpr.id}",
                    'title': f" DPR Submitted",
                    'start': dpr.completed_at.strftime('%Y-%m-%d'),
                    'type': 'dpr',
                    'backgroundColor': '#059669',
                    'borderColor': '#047857',
                    'description': f"Daily Production Report submitted for {dpr.completed_at.strftime('%B %d, %Y')}"
                })
    
    # Project expenses (based on staff assignments)
        project_staff = StaffAssignment.query.filter_by(project_id=project_id).all()
        staff_ids = [assignment.user_id for assignment in project_staff]
    
        if staff_ids:
            project_expenses = Expense.query.filter(Expense.user_id.in_(staff_ids)).order_by(
                Expense.date.desc()
            ).limit(20).all()  # Recent 20 expenses
        
            for expense in project_expenses:
                events.append({
                    'id': f"expense-{expense.id}",
                    'title': f" Expense: ${expense.amount:.2f}",
                    'start': expense.date.strftime('%Y-%m-%d'),
                    'type': 'expense',
                    'backgroundColor': '#DC2626',
                    'borderColor': '#B91C1C',
                    'description': f"Expense: {expense.description} - Amount: ${expense.amount:.2f} - Category: {expense.category}"
                })
    
        return events


# Staff Management - Filter by user's accessible projects
    @app.route('/project/staff', endpoint='project.staff')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def staff():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
            current_app.logger.info(f"User {current_user.id} ({current_user.role}) accessing staff for {len(accessible_projects)} projects")
        
        # Filter project managers and team members based on accessible projects
            managers_data = []
            members_data = []
        
            if accessible_projects:
            # Get project managers for accessible projects only
                accessible_project_managers = set()
                for project in accessible_projects:
                    if project.project_manager:
                        accessible_project_managers.add(project.project_manager)
            
            # Query managers who manage accessible projects
                if accessible_project_managers:
                    project_managers = User.query.filter(
                        User.name.in_(accessible_project_managers)
                    ).all()
                
                    for manager in project_managers:
                    # Only show projects that the current user has access to
                        manager_projects = [p for p in accessible_projects if p.project_manager == manager.name]
                        if manager_projects:
                            managers_data.append({
                                'id': manager.id,
                                'name': manager.name,
                                'role': manager.role,
                                'projects': [{'id': p.id, 'name': p.name} for p in manager_projects]
                            })
            
            # Get team members assigned to accessible projects
                staff_assignments = StaffAssignment.query.filter(
                    StaffAssignment.project_id.in_(accessible_project_ids)
                ).all()
            
            # Group assignments by staff member
                staff_projects = {}
                for assignment in staff_assignments:
                    if assignment.staff_id not in staff_projects:
                        staff_projects[assignment.staff_id] = []
                    project = Project.query.get(assignment.project_id)
                    if project:
                        staff_projects[assignment.staff_id].append({'id': project.id, 'name': project.name})
            
            # Get user details for staff members
                if staff_projects:
                    team_members = User.query.filter(
                        User.id.in_(staff_projects.keys())
                    ).all()
                
                    for member in team_members:
                        if member.id in staff_projects:
                            members_data.append({
                                'id': member.id,
                                'name': member.name,
                                'role': member.role,
                                'projects': staff_projects[member.id]
                            })
        
            return render_template('projects/staff.html', 
                                   project_managers=managers_data,
                                   team_members=members_data,
                                   accessible_projects=accessible_projects,
                                   user_role=current_user.role)
        except Exception as e:
            current_app.logger.error(f"Staff page error: {str(e)}")
            return render_template('error.html', error="Failed to load staff page"), 500


# Documents Page (File upload/download) - Filter by accessible projects
    @app.route('/project/documents', methods=['GET', 'POST'], endpoint='project.documents')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def documents():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
        # Only SUPER_HQ and PROJECT_MANAGER can upload documents
            can_upload = current_user.has_role(Roles.SUPER_HQ) or current_user.has_role(Roles.PROJECT_MANAGER)
        
        # Get selected project from request
            selected_project_id = request.args.get('project_id') or request.form.get('project_id')
            selected_project = None
            project_documents = []
            document_stats = {'total': 0, 'approved': 0, 'pending': 0, 'rejected': 0}
        
            if selected_project_id:
                try:
                    selected_project_id = int(selected_project_id)
                    if selected_project_id in accessible_project_ids:
                        selected_project = Project.query.get(selected_project_id)
                except (ValueError, TypeError):
                    selected_project_id = None
        
        # Handle POST request (file upload)
            if request.method == 'POST':
                if not can_upload:
                    flash('You do not have permission to upload documents', 'error')
                    return redirect(url_for('project.documents', project_id=selected_project_id))
                
                file = request.files.get('file')
                title = request.form.get('title')
                category = request.form.get('category')
                project_id = request.form.get('project_id')
            
            # Validate required fields
                if not file or not title or not category or not project_id:
                    flash('File, title, category, and project are required', 'error')
                    return redirect(url_for('project.documents', project_id=project_id))
                
            # Validate file
                if file.filename == '':
                    flash('No file selected', 'error')
                    return redirect(url_for('project.documents', project_id=project_id))
                
            # Validate file size (limit to 50MB)
                file.seek(0, 2)  # Seek to end of file
                file_size = file.tell()  # Get current position (file size)
                file.seek(0)  # Reset file pointer to beginning
            
                if file_size > 50 * 1024 * 1024:  # 50MB limit
                    flash('File size must be less than 50MB', 'error')
                    return redirect(url_for('project.documents', project_id=project_id))
            
            # Validate project access
                if int(project_id) not in accessible_project_ids:
                    flash('You do not have access to the selected project', 'error')
                    return redirect(url_for('project.documents'))
                
            # Get project details
                project = Project.query.get(project_id)
                if not project:
                    flash('Project not found', 'error')
                    return redirect(url_for('project.documents'))
            
            # Validate file type (basic validation)
                allowed_extensions = {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'jpg', 'jpeg', 'png', 'gif', 'zip', 'rar', 'txt', 'csv'}
                file_ext = file.filename.rsplit('.', 1)[-1].lower() if '.' in file.filename else ''
                if file_ext not in allowed_extensions:
                    flash(f'File type .{file_ext} not allowed. Allowed types: {", ".join(allowed_extensions)}', 'error')
                    return redirect(url_for('project.documents', project_id=project_id))
            
            # Create secure filename with timestamp to avoid conflicts
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                safe_filename = secure_filename(file.filename)
                if not safe_filename:
                    safe_filename = f'document.{file_ext}'
                filename_parts = safe_filename.rsplit('.', 1)
                if len(filename_parts) == 2:
                    secure_name = f"{filename_parts[0]}_{timestamp}.{filename_parts[1]}"
                else:
                    secure_name = f"{safe_filename}_{timestamp}"
            
            # Create project-specific directory
                project_upload_dir = os.path.join(current_app.config['UPLOAD_FOLDER'], 'projects', str(project_id))
                os.makedirs(project_upload_dir, exist_ok=True)
            
            # Save file
                filepath = os.path.join(project_upload_dir, secure_name)
                try:
                    file.save(filepath)
                except Exception as e:
                    current_app.logger.error(f"Failed to save file: {str(e)}")
                    flash('Failed to save file', 'error')
                    return redirect(url_for('project.documents', project_id=project_id))
            
            # Create document record
                document = Document(
                    filename=secure_name,
                    category=category,
                    project_id=int(project_id),
                    uploaded_at=datetime.now(),
                    uploader_id=current_user.id,
                    status='pending',
                    size=file_size
                )
            
                try:
                    db.session.add(document)
                    db.session.commit()
                
                    current_app.logger.info(f"Document '{title}' uploaded by user {current_user.id} for project {project_id}")
                    flash(f'Document "{title}" uploaded successfully!', 'success')
                    return redirect(url_for('project.documents', project_id=project_id))
                
                except Exception as e:
                    db.session.rollback()
                # Remove file if database operation failed
                    try:
                        os.remove(filepath)
                    except:
                        pass
                    current_app.logger.error(f"Database error during document upload: {str(e)}")
                    flash('Failed to save document information', 'error')
                    return redirect(url_for('project.documents', project_id=project_id))
        
        # GET request - load project documents
            if selected_project:
            # Get filter parameters
                category_filter = request.args.get('category_filter', '')
                status_filter = request.args.get('status_filter', '')
            
            # Base query for project documents
                docs_query = Document.query.filter_by(project_id=selected_project.id)
            
            # Apply filters
                if category_filter:
                    docs_query = docs_query.filter_by(category=category_filter)
                if status_filter:
                    docs_query = docs_query.filter_by(status=status_filter)
            
            # Get filtered documents
                project_documents = docs_query.order_by(Document.uploaded_at.desc()).all()
            
            # Calculate statistics for all documents in project (not filtered)
                all_project_docs = Document.query.filter_by(project_id=selected_project.id).all()
                document_stats = {
                    'total': len(all_project_docs),
                    'approved': len([d for d in all_project_docs if d.status == 'approved']),
                    'pending': len([d for d in all_project_docs if d.status == 'pending']),
                    'rejected': len([d for d in all_project_docs if d.status == 'rejected'])
                }
        
        # Get available categories from all documents
            all_categories = db.session.query(Document.category).distinct().all()
            available_categories = [c[0] for c in all_categories] if all_categories else [
                'Contract', 'Technical Drawing', 'Report', 'Certificate', 'Specification', 'BOQ', 'Other'
            ]
        
        # Get filter values for template
            category_filter = request.args.get('category_filter', '')
            status_filter = request.args.get('status_filter', '')
        
            return render_template('projects/documents.html',
                                 accessible_projects=accessible_projects,
                                 selected_project=selected_project,
                                 project_documents=project_documents,
                                 document_stats=document_stats,
                                 available_categories=available_categories,
                                 category_filter=category_filter,
                                 status_filter=status_filter,
                                 can_upload=can_upload,
                                 user_role=current_user.role)
                             
        except Exception as e:
            current_app.logger.error(f"Documents page error: {str(e)}")
            flash('Failed to load documents page', 'error')
            return redirect(url_for('project.list_projects'))


# Get documents for a specific project (API endpoint)
    @app.route('/project/documents/project/<int:project_id>', endpoint='project.get_project_documents')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def get_project_documents(project_id):
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
        # Validate project access
            if project_id not in accessible_project_ids:
                return jsonify({'error': 'Access denied to this project'}), 403
        
        # Get documents for the project
            documents = Document.query.filter_by(project_id=project_id).order_by(Document.uploaded_at.desc()).all()
        
        # Convert to JSON with proper metadata
            documents_data = []
            for doc in documents:
            # Get uploader name safely
                uploader_name = 'Unknown'
                try:
                    if doc.uploader_id:
                        uploader = User.query.get(doc.uploader_id)
                        if uploader:
                            uploader_name = f"{uploader.first_name} {uploader.last_name}".strip() or uploader.username or uploader.email
                except:
                    pass
                
                documents_data.append({
                    'id': doc.id,
                    'filename': doc.filename,
                    'category': doc.category,
                    'uploaded_at': doc.uploaded_at.isoformat() if doc.uploaded_at else None,
                    'uploader_name': uploader_name,
                    'status': doc.status or 'pending',
                    'size': doc.size or 0
                })
        
            return jsonify({'documents': documents_data})
        
        except Exception as e:
            current_app.logger.error(f"Error loading project documents: {str(e)}")
            return jsonify({'error': 'Failed to load documents'}), 500


# Download document
    @app.route('/project/documents/<int:doc_id>/download', endpoint='project.download_document')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def download_document(doc_id):
        try:
            document = Document.query.get_or_404(doc_id)
        
        # Check project access
            if document.project_id:
                accessible_projects = get_user_accessible_projects(current_user)
                accessible_project_ids = [p.id for p in accessible_projects]
            
                if document.project_id not in accessible_project_ids:
                    flash("You do not have access to this document", "error")
                    return redirect(url_for('project.documents'))
        
        # Try project-specific path first, then fallback to general uploads
            project_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'projects', str(document.project_id), document.filename)
            general_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], document.filename)
        
            file_path = None
            if os.path.exists(project_file_path):
                file_path = project_file_path
            elif os.path.exists(general_file_path):
                file_path = general_file_path
        
            if file_path and os.path.exists(file_path):
            # Use original filename for download (without timestamp)
                original_filename = document.filename
            # Try to extract original name by removing timestamp pattern
                parts = document.filename.rsplit('_', 1)
                if len(parts) == 2:
                    timestamp_part = parts[1]
                # Check if timestamp part matches our pattern (YYYYMMDD_HHMMSS.ext)
                    if len(timestamp_part) >= 15 and timestamp_part[:8].isdigit():
                        original_filename = f"{parts[0]}.{timestamp_part.split('.', 1)[-1]}" if '.' in timestamp_part else parts[0]
            
                return send_file(file_path, as_attachment=True, download_name=original_filename)
            else:
                flash("File not found", "error")
                return redirect(url_for('project.documents'))
            
        except Exception as e:
            current_app.logger.error(f"Error downloading document: {str(e)}")
            flash("Error downloading document", "error")
            return redirect(url_for('project.documents'))


# Delete document
    @app.route('/project/documents/<int:doc_id>/delete', methods=['POST'], endpoint='project.delete_document')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_document(doc_id):
        try:
            document = Document.query.get_or_404(doc_id)
            project_id = document.project_id
        
        # Check project access
            if document.project_id:
                accessible_projects = get_user_accessible_projects(current_user)
                accessible_project_ids = [p.id for p in accessible_projects]
            
                if document.project_id not in accessible_project_ids:
                    flash('Access denied to this document', 'error')
                    return redirect(url_for('project.documents', project_id=document.project_id))
        
        # Delete file from filesystem (try both locations)
            try:
                project_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'projects', str(document.project_id), document.filename)
                general_file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], document.filename)
            
            # Remove from project-specific directory if exists
                if os.path.exists(project_file_path):
                    os.remove(project_file_path)
                    current_app.logger.info(f"Deleted file from project directory: {project_file_path}")
            
            # Remove from general directory if exists
                if os.path.exists(general_file_path):
                    os.remove(general_file_path)
                    current_app.logger.info(f"Deleted file from general directory: {general_file_path}")
                
            except Exception as e:
                current_app.logger.warning(f"Failed to delete file from filesystem: {str(e)}")
        
        # Delete from database
            db.session.delete(document)
            db.session.commit()
        
            flash('Document deleted successfully!', 'success')
            return redirect(url_for('project.documents', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting document: {str(e)}")
            flash('Failed to delete document', 'error')
            return redirect(url_for('project.documents'))





# Document Approval/Rejection
    @app.route('/project/documents/<int:doc_id>/approve', methods=['POST'], endpoint='project.approve_document')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def approve_document(doc_id):
        try:
            document = Document.query.get_or_404(doc_id)
        
        # Check project access
            if document.project_id:
                accessible_projects = get_user_accessible_projects(current_user)
                accessible_project_ids = [p.id for p in accessible_projects]
            
                if document.project_id not in accessible_project_ids:
                    flash('Access denied to this document', 'error')
                    return redirect(url_for('project.documents', project_id=document.project_id))
        
            document.status = 'approved'
            document.approved_by = current_user.id
            document.approved_at = datetime.now()
            db.session.commit()
        
            flash('Document approved successfully!', 'success')
            return redirect(url_for('project.documents', project_id=document.project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error approving document: {str(e)}")
            flash('Failed to approve document', 'error')
            return redirect(url_for('project.documents'))

    @app.route('/project/documents/<int:doc_id>/reject', methods=['POST'], endpoint='project.reject_document')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def reject_document(doc_id):
        try:
            document = Document.query.get_or_404(doc_id)
        
        # Check project access
            if document.project_id:
                accessible_projects = get_user_accessible_projects(current_user)
                accessible_project_ids = [p.id for p in accessible_projects]
            
                if document.project_id not in accessible_project_ids:
                    flash('Access denied to this document', 'error')
                    return redirect(url_for('project.documents', project_id=document.project_id))
        
            document.status = 'rejected'
            document.approved_by = current_user.id
            document.approved_at = datetime.now()
            db.session.commit()
        
            flash('Document rejected successfully!', 'warning')
            return redirect(url_for('project.documents', project_id=document.project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error rejecting document: {str(e)}")
            flash('Failed to reject document', 'error')
            return redirect(url_for('project.documents'))

# Document Search
    @app.route('/project/documents/search', endpoint='project.search_documents')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def search_documents():
        try:
            query = request.args.get('q', '').strip()
            category = request.args.get('category', '').strip()
            status = request.args.get('status', '').strip()
            documents_query = Document.query
            if query:
                documents_query = documents_query.filter(Document.filename.ilike(f'%{query}%'))
            if category:
                documents_query = documents_query.filter_by(category=category)
            if status:
                documents_query = documents_query.filter_by(status=status)
            results = documents_query.order_by(Document.uploaded_at.desc()).all()
            return render_template('projects/documents_search.html', results=results, query=query, category=category, status=status)
        except Exception as e:
            current_app.logger.error(f"Document search error: {str(e)}")
            return render_template('error.html', error="Failed to search documents"), 500

# Upload/View/Download Reports as PDF/Excel - Filter by accessible projects
    @app.route('/project/reports/upload', methods=['GET', 'POST'], endpoint='project.upload_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def upload_report():
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
        # Only SUPER_HQ and PROJECT_MANAGER can upload reports
            can_upload = current_user.has_role(Roles.SUPER_HQ) or current_user.has_role(Roles.PROJECT_MANAGER)
        
            if request.method == 'POST':
                if not can_upload:
                    flash('You do not have permission to upload reports', 'error')
                    return redirect(url_for('project.reports_index'))
                
                file = request.files.get('report_file')
                report_type = request.form.get('type')
                project_id = request.form.get('project_id')  # Optional project association
            
                if not file or not report_type:
                    flash('File and report type required', 'error')
                    return redirect(url_for('project.upload_report'))
                
            # Validate project access if project_id is provided
                if project_id:
                    accessible_project_ids = [p.id for p in accessible_projects]
                    if int(project_id) not in accessible_project_ids:
                        flash('You do not have access to the selected project', 'error')
                        return redirect(url_for('project.upload_report'))
            
                filename = secure_filename(file.filename)
                filepath = os.path.join(current_app.config['REPORTS_UPLOAD_FOLDER'], filename)
                file.save(filepath)
            
                report = Report(
                    filename=filename, 
                    type=report_type, 
                    uploaded_at=datetime.now(), 
                    uploader_id=current_user.id
                )
            
            # If Report model has project_id field, uncomment:
            # if project_id:
            #     report.project_id = int(project_id)
            
                db.session.add(report)
                db.session.commit()
            
                current_app.logger.info(f"Report uploaded by user {current_user.id} for project {project_id or 'general'}")
                flash('Report uploaded successfully!', 'success')
                return redirect(url_for('project.reports_index'))
            
            return render_template('projects/upload_report.html', 
                                 accessible_projects=accessible_projects,
                                 can_upload=can_upload,
                                 user_role=current_user.role)
        except Exception as e:
            current_app.logger.error(f"Report upload error: {str(e)}")
            flash('Failed to upload report', 'error')
            return redirect(url_for('project.reports_index'))

    @app.route('/project/reports/download/<int:report_id>', endpoint='project.download_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF, Roles.HQ_FINANCE, Roles.HQ_PROCUREMENT])
    def download_report(report_id):
        try:
            report = Report.query.get_or_404(report_id)
        
        # Check if user has access to this report's project (if report has project_id)
        # For now, we'll allow download if user has any project access
            accessible_projects = get_user_accessible_projects(current_user)
        
        # If Report model has project_id field, add this check:
        # if hasattr(report, 'project_id') and report.project_id:
        #     accessible_project_ids = [p.id for p in accessible_projects]
        #     if report.project_id not in accessible_project_ids:
        #         flash('You do not have access to this report', 'error')
        #         return redirect(url_for('procurement.reports'))
        
            filepath = os.path.join(current_app.config['REPORTS_UPLOAD_FOLDER'], report.filename)
            current_app.logger.info(f"Report {report_id} downloaded by user {current_user.id}")
            return send_file(filepath, as_attachment=True)
        except Exception as e:
            current_app.logger.error(f"Report download error: {str(e)}")
            flash('Failed to download report', 'error')
            return redirect(url_for('project.reports_index'))


# Logout
    @app.route('/project/logout', endpoint='project.logout')
    @login_required
    def logout():
        try:
        # Log out the current user
            logout_user()
        # Clear the session
            session.clear()
            flash("You have been successfully logged out", "success")
            return redirect(url_for('login'))
        except Exception as e:
            current_app.logger.error(f"Logout error: {str(e)}")
            flash("Error during logout", "error")
            return redirect(url_for('login'))

# Settings
    @app.route('/project/settings', methods=['GET', 'POST'], endpoint='project.settings')
    @login_required
    def settings():
        try:
            if request.method == 'POST':
                form_type = request.args.get('form')
            
                if form_type == 'profile':
                    name = request.form.get('name')
                    email = request.form.get('email')
                    department = request.form.get('department')
                
                    user = User.query.get(current_user.id)
                    if not user:
                        flash("User not found", "error")
                        return redirect(url_for('project.settings'))
                
                # Validate email uniqueness (excluding current user)
                    existing_user = User.query.filter(User.email == email, User.id != current_user.id).first()
                    if existing_user:
                        flash("Email address is already in use by another account", "error")
                        return redirect(url_for('project.settings'))
                
                    user.name = name
                    user.email = email
                    if hasattr(user, 'department'):
                        user.department = department
                
                    db.session.commit()
                    flash("Profile updated successfully!", "success")
                
                elif form_type == 'security':
                    current_password = request.form.get('current_password')
                    new_password = request.form.get('new_password')
                    confirm_password = request.form.get('confirm_password')
                
                    user = User.query.get(current_user.id)
                    if not user:
                        flash("User not found", "error")
                        return redirect(url_for('project.settings'))
                
                # Validate current password
                    if not user.check_password(current_password):
                        flash("Current password is incorrect", "error")
                        return redirect(url_for('project.settings'))
                
                # Validate new password match
                    if new_password != confirm_password:
                        flash("New passwords do not match", "error")
                        return redirect(url_for('project.settings'))
                
                # Validate password strength
                    if len(new_password) < 8:
                        flash("Password must be at least 8 characters long", "error")
                        return redirect(url_for('project.settings'))
                
                    user.set_password(new_password)
                    db.session.commit()
                    flash("Password updated successfully!", "success")
                
                elif form_type == 'notifications':
                    email_notifications = request.form.get('email_notifications') == 'on'
                    task_reminders = request.form.get('task_reminders') == 'on'
                    project_updates = request.form.get('project_updates') == 'on'
                
                    user = User.query.get(current_user.id)
                    if not user:
                        flash("User not found", "error")
                        return redirect(url_for('project.settings'))
                
                # Store notification preferences (assuming these fields exist or we create them)
                    if hasattr(user, 'email_notifications'):
                        user.email_notifications = email_notifications
                    if hasattr(user, 'task_reminders'):
                        user.task_reminders = task_reminders
                    if hasattr(user, 'project_updates'):
                        user.project_updates = project_updates
                
                    db.session.commit()
                    flash("Notification preferences updated successfully!", "success")
            
                return redirect(url_for('project.settings'))
        
        # GET request - render settings page
            user = User.query.get(current_user.id)
            if not user:
                flash("User not found", "error")
                return redirect(url_for('project.project_home'))
        
        # Get user's accessible projects for display
            accessible_projects = get_user_accessible_projects(current_user)
        
            user_data = {
                'name': user.name or '',
                'email': user.email or '',
                'role': user.role or 'Staff',
                'department': getattr(user, 'department', ''),
                'notification_preferences': {
                    'email_notifications': getattr(user, 'email_notifications', True),
                    'task_reminders': getattr(user, 'task_reminders', True),
                    'project_updates': getattr(user, 'project_updates', True)
                }
            }
        
            return render_template('projects/settings.html', 
                                 user=user_data, 
                                 accessible_projects=accessible_projects)
                             
        except Exception as e:
            current_app.logger.error(f"Settings page error: {str(e)}")
            flash("Error processing settings request", "error")
            return render_template('error.html', error="Settings page error"), 500


# Weekly Site Report Endpoint
    @app.route('/project/weekly-site-report', methods=['GET', 'POST'], endpoint='project.weekly_site_report')
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def weekly_site_report():
        try:
            if request.method == 'POST':
            # Handle report upload (PDF/Excel)
                file = request.files.get('report_file')
                if file:
                    filename = secure_filename(file.filename)
                    filepath = os.path.join(current_app.config['REPORTS_UPLOAD_FOLDER'], filename)
                    file.save(filepath)
                # Save report record
                    report = Report(filename=filename, type='Weekly Site', uploaded_at=datetime.now(), uploader_id=current_user.id)
                    db.session.add(report)
                    db.session.commit()
                    flash('Weekly site report uploaded!', 'success')
                    return redirect(url_for('project.weekly_site_report'))
        # Labour Check
            staff_assignments = StaffAssignment.query.all()
            staff_categories = {}
            for s in staff_assignments:
                category = s.staff.role
                staff_categories.setdefault(category, []).append(s.staff)
        # Plant Check
            plant_data = Equipment.query.with_entities(Equipment.name, Equipment.machine_hours, Equipment.diesel_consumption).all()
        # Materials Check
            materials = Material.query.with_entities(Material.name, Material.delivered, Material.used, Material.balance).all()
        # Progress Check
            progress_items = Task.query.with_entities(Task.title, Task.from_item, Task.to_item, Task.quantity, Task.percent_complete).all()
        # Remarks
            equipment_remarks = Equipment.query.with_entities(Equipment.name, Equipment.remarks).all()
            manager_comment = ''  # Could be fetched from a model or form
        # Visitors
            visitors = Report.query.filter_by(type='Visitor').order_by(Report.date.desc()).limit(10).all()
        # Sign-off
            sign_off = {
                'project_manager': current_user.name,
                'md_ceo': '',  # Could be fetched from User model
                'site_file': ''  # Could be a file or record
            }
            return render_template('projects/weekly_site_report.html',
                staff_categories=staff_categories,
                plant_data=plant_data,
                materials=materials,
                progress_items=progress_items,
                equipment_remarks=equipment_remarks,
                manager_comment=manager_comment,
                visitors=visitors,
                sign_off=sign_off
            )
        except Exception as e:
            current_app.logger.error(f"Weekly Site Report error: {str(e)}")
            return render_template('error.html', error="Failed to load weekly site report"), 500


# Staff Removal from Project - Only SUPER_HQ and Project Managers can remove staff
    @app.route('/project/<int:project_id>/remove-staff', methods=['POST'], endpoint='project.remove_staff')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def remove_staff(project_id):
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check if user has permission to remove staff from this project
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied staff removal access to project {project_id}")
                flash("You don't have permission to remove staff from this project.", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
        
            staff_id = request.form.get('staff_id')
            assignment = StaffAssignment.query.filter_by(project_id=project_id, staff_id=staff_id).first()
            if assignment:
                db.session.delete(assignment)
                db.session.commit()
                current_app.logger.info(f"Staff {staff_id} removed from project {project_id} by user {current_user.id}")
                flash(f"Staff {staff_id} removed from project {project_id} successfully!", "success")
            else:
                flash("Staff assignment not found", "error")
            return redirect(url_for('project.project_details', project_id=project_id))
        except Exception as e:
            db.session.rollback()
            flash(f"Error removing staff: {str(e)}", "error")
            return redirect(url_for('project.project_details', project_id=project_id))


# ==================== API ENDPOINTS FOR PROJECT MANAGEMENT ====================

    @app.route('/project/api/projects/<int:project_id>/status', methods=['POST'], endpoint='project.update_project_status')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def update_project_status(project_id):
        """Update project status - Only SUPER_HQ and project managers can update their projects"""
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check if user has permission to update this project
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied status update access to project {project_id}")
                flash("You don't have permission to update this project's status.", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
        
            data = request.get_json() if request.is_json else request.form
            new_status = data.get('status')
        
            if not new_status:
                flash("Status is required", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
            
            old_status = project.status
            project.status = new_status
            project.updated_at = datetime.now(timezone.utc)
        
        # Auto-update progress based on status
            if new_status == 'Completed':
                project.progress = 100.0
            elif new_status == 'Active':
                if not project.progress:
                    project.progress = 10.0  # Start with 10% if active
        
            db.session.commit()
        
            current_app.logger.info(f"Project {project_id} status updated from {old_status} to {new_status} by user {current_user.id}")
        
            flash(f"Project status updated to {new_status} successfully!", "success")
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Update project status error: {str(e)}", exc_info=True)
            flash("Error updating project status", "error")
            return redirect(url_for('project.project_details', project_id=project_id))

    @app.route('/project/api/projects/<int:project_id>/progress', methods=['POST'], endpoint='project.update_project_progress')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def update_project_progress(project_id):
        """Update project progress - Only SUPER_HQ and project managers can update their projects"""
        try:
            project = Project.query.get_or_404(project_id)
        
        # Check if user has permission to update this project
            is_manager = project.project_manager == current_user.name
            is_super_hq = current_user.has_role(Roles.SUPER_HQ)
        
            if not (is_manager or is_super_hq):
                current_app.logger.warning(f"User {current_user.id} denied progress update access to project {project_id}")
                flash("You don't have permission to update this project's progress.", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
        
            data = request.get_json() if request.is_json else request.form
            progress = float(data.get('progress', 0))
        
            if progress < 0 or progress > 100:
                flash("Progress must be between 0 and 100", "error")
                return redirect(url_for('project.project_details', project_id=project_id))
            
            old_progress = project.progress
            project.progress = progress
            project.updated_at = datetime.now(timezone.utc)
        
        # Auto-update status based on progress
            if progress == 100:
                project.status = 'Completed'
            elif progress > 0 and project.status == 'Planning':
                project.status = 'Active'
        
            db.session.commit()
        
            current_app.logger.info(f"Project {project_id} progress updated from {old_progress}% to {progress}% by user {current_user.id}")
        
            flash(f"Project progress updated to {progress}% successfully!", "success")
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Update project progress error: {str(e)}", exc_info=True)
            flash("Error updating project progress", "error")
            return redirect(url_for('project.project_details', project_id=project_id))

    @app.route('/project/api/projects/<int:project_id>/progress', methods=['GET'], endpoint='project.get_project_progress')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def get_project_progress(project_id):
        """Get current project progress and metrics"""
        try:
            project = Project.query.get_or_404(project_id)
        
        # Get updated milestone counts
            milestones = Milestone.query.filter_by(project_id=project_id).all()
            completed_milestones = [m for m in milestones if m.status == 'Completed']
        
        # Get updated task counts
            tasks = Task.query.filter_by(project_id=project_id).all()
            completed_tasks = [t for t in tasks if t.status == 'completed']
        
        # Instead of returning JSON, redirect to project details which shows progress
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Get project progress error: {str(e)}", exc_info=True)
            flash("Error fetching project progress", "error")
            return redirect(url_for('project.project_details', project_id=project_id))

    @app.route('/project/api/projects/filter', endpoint='project.filter_projects')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def filter_projects():
        """Filter projects by various criteria"""
        try:
            status = request.args.get('status')
            search = request.args.get('search', '')
            sort_by = request.args.get('sort_by', 'created_at')
            sort_order = request.args.get('sort_order', 'desc')
        
            query = Project.query
        
        # Apply status filter
            if status and status != 'all':
                query = query.filter(Project.status == status)
        
        # Apply search filter
            if search:
                query = query.filter(
                    db.or_(
                        Project.name.ilike(f'%{search}%'),
                        Project.description.ilike(f'%{search}%'),
                        Project.project_manager.ilike(f'%{search}%')
                    )
                )
        
        # Apply sorting
            if hasattr(Project, sort_by):
                if sort_order == 'desc':
                    query = query.order_by(getattr(Project, sort_by).desc())
                else:
                    query = query.order_by(getattr(Project, sort_by))
        
            projects = query.all()
        
        # Instead of returning JSON, redirect to project home with filtered results
        # You could store filter criteria in session if needed
            if search:
                flash(f"Found {len(projects)} projects matching '{search}'", "info")
            return redirect(url_for('project.project_home'))
        
        except Exception as e:
            current_app.logger.error(f"Filter projects error: {str(e)}", exc_info=True)
            flash("Error filtering projects", "error")
            return redirect(url_for('project.project_home'))

    @app.route('/project/api/projects/<int:project_id>/details', endpoint='project.get_project_details')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def get_project_details(project_id):
        """Get comprehensive project details"""
        try:
            project = Project.query.get_or_404(project_id)
        
        # Get milestones
            milestones = project.milestones.all() if hasattr(project, 'milestones') else []
            milestone_data = []
            for milestone in milestones:
                milestone_data.append({
                    'id': milestone.id,
                    'title': milestone.title,
                    'description': milestone.description,
                    'due_date': milestone.due_date.strftime('%Y-%m-%d') if milestone.due_date else None,
                    'status': getattr(milestone, 'status', 'Pending'),
                    'progress': getattr(milestone, 'progress', 0)
                })
        
        # Get schedules/assignments
            schedules = project.schedules.all() if hasattr(project, 'schedules') else []
            schedule_data = []
            for schedule in schedules:
                schedule_data.append({
                    'id': schedule.id,
                    'task': getattr(schedule, 'task', 'No task specified'),
                    'assigned_to': getattr(schedule, 'assigned_to', 'Not assigned'),
                    'start_date': schedule.start_date.strftime('%Y-%m-%d') if hasattr(schedule, 'start_date') and schedule.start_date else None,
                    'end_date': schedule.end_date.strftime('%Y-%m-%d') if hasattr(schedule, 'end_date') and schedule.end_date else None,
                    'status': getattr(schedule, 'status', 'Pending')
                })
        
        # Calculate project health
            days_remaining = None
            is_overdue = False
            if project.end_date:
                days_remaining = (project.end_date - datetime.now().date()).days
                is_overdue = days_remaining < 0 and project.status != 'Completed'
        
            project_details = {
                'id': project.id,
                'name': project.name,
                'description': project.description or 'No description provided',
                'status': project.status or 'Planning',
                'progress': project.progress or 0,
                'manager': project.project_manager or 'Not assigned',
                'created_at': project.created_at.strftime('%Y-%m-%d %H:%M:%S') if project.created_at else None,
                'updated_at': project.updated_at.strftime('%Y-%m-%d %H:%M:%S') if project.updated_at else None,
                'start_date': project.start_date.strftime('%Y-%m-%d') if project.start_date else None,
                'end_date': project.end_date.strftime('%Y-%m-%d') if project.end_date else None,
                'budget': project.budget or 0,
                'spent': (project.budget * 0.6) if project.budget else 0,  # Simulated
                'milestones': milestone_data,
                'schedules': schedule_data,
                'milestone_count': len(milestone_data),
                'completed_milestones': len([m for m in milestone_data if m['status'] == 'Completed']),
                'team_size': len(schedule_data),
                'days_remaining': days_remaining,
                'is_overdue': is_overdue,
                'health_status': 'Critical' if is_overdue else 'Good' if days_remaining and days_remaining > 30 else 'Warning'
            }
        
        # Instead of returning detailed JSON, redirect to project details page
        # which already shows all this information
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Get project details error: {str(e)}", exc_info=True)
            flash("Error fetching project details", "error")
            return redirect(url_for('project.project_details', project_id=project_id))

    @app.route('/project/api/projects/statistics', endpoint='project.get_project_statistics')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def get_project_statistics():
        """Get comprehensive project statistics"""
        try:
        # Basic counts
            total_projects = Project.query.count()
            active_projects = Project.query.filter(Project.status.in_(['Active', 'In Progress'])).count()
            completed_projects = Project.query.filter_by(status='Completed').count()
            planning_projects = Project.query.filter_by(status='Planning').count()
            overdue_projects = Project.query.filter(
                Project.end_date < datetime.now().date(),
                Project.status != 'Completed'
            ).count()
        
        # Budget calculations
            total_budget = db.session.query(func.sum(Project.budget)).scalar() or 0
            avg_project_value = total_budget / total_projects if total_projects > 0 else 0
        
        # Progress calculations
            avg_progress = db.session.query(func.avg(Project.progress)).scalar() or 0
        
        # Monthly project creation trend (last 6 months)
            monthly_stats = []
            for i in range(6):
                month_start = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
                if i > 0:
                    if month_start.month > i:
                        month_start = month_start.replace(month=month_start.month - i)
                    else:
                        month_start = month_start.replace(year=month_start.year - 1, month=12 - (i - month_start.month))
            
                month_end = month_start.replace(day=28) + datetime.timedelta(days=4)
                month_end = month_end - datetime.timedelta(days=month_end.day)
            
                count = Project.query.filter(
                    Project.created_at >= month_start,
                    Project.created_at <= month_end
                ).count()
            
                monthly_stats.append({
                    'month': month_start.strftime('%B %Y'),
                    'count': count
                })
        
        # Status distribution
            status_distribution = {
                'Planning': planning_projects,
                'Active': active_projects,
                'Completed': completed_projects,
                'Overdue': overdue_projects
            }
        
            statistics = {
                'overview': {
                    'total_projects': total_projects,
                    'active_projects': active_projects,
                    'completed_projects': completed_projects,
                    'planning_projects': planning_projects,
                    'overdue_projects': overdue_projects,
                    'completion_rate': (completed_projects / total_projects * 100) if total_projects > 0 else 0
                },
                'financial': {
                    'total_budget': total_budget,
                    'average_project_value': avg_project_value,
                    'total_spent': total_budget * 0.6  # Simulated
                },
                'progress': {
                    'average_progress': round(avg_progress, 1),
                    'projects_on_track': active_projects - overdue_projects,
                    'projects_at_risk': overdue_projects
                },
                'trends': {
                    'monthly_creation': monthly_stats,
                    'status_distribution': status_distribution
                }
            }
        
            flash('Project statistics retrieved successfully', 'success')
            return redirect(url_for('project.project_home'))
        
        except Exception as e:
            current_app.logger.error(f"Get project statistics error: {str(e)}", exc_info=True)
            flash('Error fetching project statistics', 'error')
            return redirect(url_for('project.project_home'))


# ===== ENHANCED PROJECT MANAGEMENT ROUTES =====

    @app.route('/project/<int:project_id>/assign_staff', methods=['POST'], endpoint='project.assign_staff_enhanced')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def assign_staff_enhanced(project_id):
        """Enhanced staff assignment endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            staff_id = request.form.get('staff_id')
            role = request.form.get('role')
        
            if not staff_id or not role:
                flash('Staff ID and role are required', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Check if staff is already assigned
            existing_assignment = StaffAssignment.query.filter_by(
                project_id=project_id, 
                staff_id=staff_id
            ).first()
        
            if existing_assignment:
                flash('Staff member is already assigned to this project', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Get staff member details
            staff_member = User.query.get(staff_id)
            if not staff_member:
                flash('Staff member not found', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Create new assignment
            assignment = StaffAssignment(
                project_id=project_id,
                staff_id=staff_id,
                role=role,
                assigned_at=datetime.now(timezone.utc)
            )
        
            db.session.add(assignment)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='staff_assigned',
                description=f'{staff_member.name} was assigned as {role}',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'{staff_member.name} has been assigned as {role}', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error assigning staff: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while assigning staff', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/remove_staff', methods=['POST'], endpoint='project.remove_staff_new')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def remove_staff_new(project_id):
        """Enhanced staff removal endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            data = request.get_json()
            staff_id = data.get('staff_id')
        
            if not staff_id:
                flash('Staff ID is required', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Find and remove assignment
            assignment = StaffAssignment.query.filter_by(
                project_id=project_id,
                staff_id=staff_id
            ).first()
        
            if not assignment:
                flash('Staff assignment not found', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Get staff member details for logging
            staff_member = User.query.get(staff_id)
            staff_name = staff_member.name if staff_member else 'Unknown'
            role = assignment.role
        
            db.session.delete(assignment)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='staff_removed',
                description=f'{staff_name} was removed from {role} role',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'{staff_name} has been removed from the project', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error removing staff: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while removing staff', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/add_milestone', methods=['POST'], endpoint='project.add_milestone_enhanced')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def add_milestone_enhanced(project_id):
        """Enhanced milestone creation endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            milestone_name = request.form.get('milestone_name')
            milestone_description = request.form.get('milestone_description', '')
            due_date_str = request.form.get('due_date')
        
            if not milestone_name or not due_date_str:
                flash('Milestone name and due date are required', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Parse due date
            try:
                due_date = datetime.strptime(due_date_str, '%Y-%m-%d').date()
            except ValueError:
                flash('Invalid date format', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Create new milestone
            milestone = Milestone(
                project_id=project_id,
                title=milestone_name,
                due_date=due_date,
                status='Pending'
            )
        
        # Add description if Milestone model supports it
            if hasattr(milestone, 'description'):
                milestone.description = milestone_description
        
            db.session.add(milestone)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='milestone_added',
                description=f'Milestone "{milestone_name}" was created with due date {due_date.strftime("%B %d, %Y")}',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Milestone "{milestone_name}" has been created', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error adding milestone: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while adding milestone', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/milestones/<int:milestone_id>', methods=['DELETE'], endpoint='project.delete_milestone_new')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_milestone_new(project_id, milestone_id):
        """Enhanced milestone deletion endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            milestone = Milestone.query.filter_by(id=milestone_id, project_id=project_id).first()
        
            if not milestone:
                flash('Milestone not found', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            milestone_title = milestone.title
            db.session.delete(milestone)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='milestone_deleted',
                description=f'Milestone "{milestone_title}" was deleted',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Milestone "{milestone_title}" has been deleted', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error deleting milestone: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while deleting milestone', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/add_boq_item', methods=['POST'], endpoint='project.add_boq_item_enhanced')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def add_boq_item_enhanced(project_id):
        """Add BOQ (Bill of Quantities) item endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            item_description = request.form.get('item_description')
            quantity = request.form.get('quantity')
            unit = request.form.get('unit')
            unit_price = request.form.get('unit_price')
        
            if not all([item_description, quantity, unit, unit_price]):
                flash('All fields are required', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            try:
                quantity = float(quantity)
                unit_price = float(unit_price)
                total_cost = quantity * unit_price
            except ValueError:
                flash('Invalid numeric values', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Create new BOQ item
            boq_item = BOQItem(
                project_id=project_id,
                item_description=item_description,
                quantity=quantity,
                unit=unit,
                unit_price=unit_price,
                total_cost=total_cost
            )
        
            db.session.add(boq_item)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_added',
                description=f'BOQ item "{item_description}" was added ({total_cost:,.2f})',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'BOQ item "{item_description}" has been added', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error adding BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while adding BOQ item', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/boq_items/<int:item_id>', methods=['DELETE'], endpoint='project.delete_boq_item')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_boq_item(project_id, item_id):
        """Delete BOQ item endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            boq_item = BOQItem.query.filter_by(id=item_id, project_id=project_id).first()
        
            if not boq_item:
                flash('BOQ item not found', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            item_description = boq_item.item_description
            db.session.delete(boq_item)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='boq_item_deleted',
                description=f'BOQ item "{item_description}" was deleted',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'BOQ item "{item_description}" has been deleted', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error deleting BOQ item: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while deleting BOQ item', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/upload_document', methods=['POST'], endpoint='project.upload_document_enhanced')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def upload_document_enhanced(project_id):
        """Enhanced document upload endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            if 'document_file' not in request.files:
                flash('No file selected', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            file = request.files['document_file']
            document_type = request.form.get('document_type')
            description = request.form.get('document_description', '')
        
            if file.filename == '':
                flash('No file selected', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            if not document_type:
                flash('Document type is required', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Validate file type
            allowed_extensions = {'pdf', 'doc', 'docx', 'xls', 'xlsx', 'png', 'jpg', 'jpeg'}
            if not ('.' in file.filename and file.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
                flash('File type not allowed', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Create uploads directory if it doesn't exist
            upload_folder = os.path.join(current_app.root_path, 'uploads', 'projects', str(project_id))
            os.makedirs(upload_folder, exist_ok=True)
        
        # Generate secure filename
            filename = secure_filename(file.filename)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_')
            unique_filename = timestamp + filename
            file_path = os.path.join(upload_folder, unique_filename)
        
        # Save file
            file.save(file_path)
            file_size = os.path.getsize(file_path)
        
        # Create document record
            document = ProjectDocument(
                project_id=project_id,
                filename=unique_filename,
                original_filename=filename,
                document_type=document_type,
                description=description,
                file_size=file_size,
                file_path=file_path,
                uploader_id=current_user.id,
                uploader_name=current_user.name
            )
        
            db.session.add(document)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='document_uploaded',
                description=f'Document "{filename}" was uploaded ({document_type})',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Document "{filename}" has been uploaded successfully', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error uploading document: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while uploading document', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/documents/<int:document_id>/download', endpoint='project.download_project_document')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def download_project_document(project_id, document_id):
        """Enhanced document download endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            document = ProjectDocument.query.filter_by(id=document_id, project_id=project_id).first()
        
            if not document:
                flash('Document not found', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            if not os.path.exists(document.file_path):
                flash('File not found on disk', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            return send_file(
                document.file_path,
                as_attachment=True,
                download_name=document.original_filename,
                mimetype='application/octet-stream'
            )
        
        except Exception as e:
            current_app.logger.error(f"Error downloading document: {str(e)}", exc_info=True)
            flash('An error occurred while downloading the document', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/documents/<int:document_id>', methods=['DELETE'], endpoint='project.delete_document_enhanced')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_document_enhanced(project_id, document_id):
        """Enhanced document deletion endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
            document = ProjectDocument.query.filter_by(id=document_id, project_id=project_id).first()
        
            if not document:
                flash('Document not found', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
        # Delete file from disk
            if os.path.exists(document.file_path):
                os.remove(document.file_path)
        
            document_name = document.original_filename
            db.session.delete(document)
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='document_deleted',
                description=f'Document "{document_name}" was deleted',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Document "{document_name}" has been deleted', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error deleting document: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while deleting document', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


    @app.route('/project/<int:project_id>/update_progress', methods=['POST'], endpoint='project.update_progress_enhanced')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def update_progress_enhanced(project_id):
        """Enhanced progress update endpoint"""
        try:
            project = Project.query.get_or_404(project_id)
        
            data = request.get_json()
            progress = data.get('progress')
        
            if progress is None:
                flash('Progress value is required', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            try:
                progress = float(progress)
                if progress < 0 or progress > 100:
                    flash('Progress must be between 0 and 100', 'error')
                    return redirect(url_for('project.project_details', project_id=project_id))
            except ValueError:
                flash('Invalid progress value', 'error')
                return redirect(url_for('project.project_details', project_id=project_id))
        
            old_progress = project.progress or 0
            project.progress = progress
        
        # Log activity
            activity = ProjectActivity(
                project_id=project_id,
                user_id=current_user.id,
                action_type='progress_updated',
                description=f'Project progress updated from {old_progress}% to {progress}%',
                user_name=current_user.name
            )
            db.session.add(activity)
        
            db.session.commit()
        
            flash(f'Project progress updated to {progress}%', 'success')
            return redirect(url_for('project.project_details', project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error updating progress: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('An error occurred while updating progress', 'error')
            return redirect(url_for('project.project_details', project_id=project_id))


# API Endpoints for Adding Resources (Role-based restrictions)

    @app.route('/project/equipment/add', methods=['POST'], endpoint='project.add_equipment')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def add_equipment():
        """Add equipment - restricted to SUPER_HQ and PROJECT_MANAGER, REQUIRES project context"""
        try:
            data = request.get_json()
        
        # Validate required fields
            if not data.get('name') or not data.get('status'):
                return jsonify({'status': 'error', 'message': 'Missing required fields'}), 400
        
        # Project ID is REQUIRED - no global equipment allowed
            project_id = data.get('project_id')
            if not project_id:
                return jsonify({'status': 'error', 'message': 'Project selection is required. Equipment must be assigned to a specific project.'}), 400
        
        # Check if user has access to the specified project
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if int(project_id) not in accessible_project_ids:
                return jsonify({'status': 'error', 'message': 'You do not have access to the specified project'}), 403
        
        # Verify project exists
            project = Project.query.get(project_id)
            if not project:
                return jsonify({'status': 'error', 'message': 'Project not found'}), 404
        
        # Create new equipment
            equipment = Equipment(
                name=data['name'],
                status=data['status'],
                maintenance_due=datetime.strptime(data['maintenance_due'], '%Y-%m-%d').date() if data.get('maintenance_due') else None,
                assigned_to=data.get('assigned_to'),
                project_id=project_id
            )
        
            db.session.add(equipment)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} added equipment '{data['name']}' to project {project_id}")
            return jsonify({'status': 'success', 'message': f'Equipment added to project "{project.name}" successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error adding equipment: {str(e)}")
            db.session.rollback()
            return jsonify({'status': 'error', 'message': 'Failed to add equipment'}), 500


    @app.route('/project/materials/add', methods=['POST'], endpoint='project.add_material')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def add_material():
        """Add material - restricted to SUPER_HQ and PROJECT_MANAGER, REQUIRES project context"""
        try:
            data = request.get_json()
        
        # Validate required fields
            if not data.get('name') or not data.get('quantity') or not data.get('unit'):
                return jsonify({'status': 'error', 'message': 'Missing required fields'}), 400
        
        # Project ID is REQUIRED - no global materials allowed
            project_id = data.get('project_id')
            if not project_id:
                return jsonify({'status': 'error', 'message': 'Project selection is required. Materials must be assigned to a specific project.'}), 400
        
        # Check if user has access to the specified project
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if int(project_id) not in accessible_project_ids:
                return jsonify({'status': 'error', 'message': 'You do not have access to the specified project'}), 403
        
        # Verify project exists
            project = Project.query.get(project_id)
            if not project:
                return jsonify({'status': 'error', 'message': 'Project not found'}), 404
        
        # Create new material
            material = Material(
                name=data['name'],
                quantity=int(data['quantity']),
                unit=data['unit'],
                delivered=int(data['quantity']),  # Initially, delivered = quantity
                status='In Stock',  # Default status
                last_updated=datetime.now().strftime('%Y-%m-%d'),
                project_id=project_id
            )
        
            db.session.add(material)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} added material '{data['name']}' to project {project_id}")
            return jsonify({'status': 'success', 'message': f'Material added to project "{project.name}" successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error adding material: {str(e)}")
            db.session.rollback()
            return jsonify({'status': 'error', 'message': 'Failed to add material'}), 500


    @app.route('/project/staff/add', methods=['POST'], endpoint='project.add_staff')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def add_staff():
        """Add staff member - restricted to SUPER_HQ and PROJECT_MANAGER, REQUIRES project context"""
        try:
            data = request.get_json()
        
        # Validate required fields
            if not data.get('name') or not data.get('role'):
                return jsonify({'status': 'error', 'message': 'Missing required fields'}), 400
        
        # Project ID is REQUIRED - no global staff assignment allowed
            project_id = data.get('project_id')
            if not project_id:
                return jsonify({'status': 'error', 'message': 'Project selection is required. Staff must be assigned to a specific project.'}), 400
        
        # Check if user has access to the specified project
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if int(project_id) not in accessible_project_ids:
                return jsonify({'status': 'error', 'message': 'You do not have access to the specified project'}), 403
        
        # Verify project exists
            project = Project.query.get(project_id)
            if not project:
                return jsonify({'status': 'error', 'message': 'Project not found'}), 404
        
        # For now, this is a placeholder since we need user registration logic
        # In a real system, you'd create a User and then assign to projects via StaffAssignment
            current_app.logger.info(f"User {current_user.id} initiated staff addition to project {project_id}")
        
            return jsonify({
                'status': 'success', 
                'message': f'Staff member addition to project "{project.name}" initiated (requires full user registration and assignment process)'
            })
        
        except Exception as e:
            current_app.logger.error(f"Error adding staff: {str(e)}")
            return jsonify({'status': 'error', 'message': 'Failed to add staff member'}), 500
        
        except Exception as e:
            current_app.logger.error(f"Error adding staff: {str(e)}")
            return jsonify({'status': 'error', 'message': 'Failed to add staff member'}), 500


# Generate Reports Endpoints (Project-based)

    @app.route('/project/equipment/report', methods=['POST'], endpoint='project.generate_equipment_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def generate_equipment_report():
        """Generate equipment report for accessible projects"""
        try:
            data = request.get_json() or {}
            project_id = data.get('project_id')
        
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
        # Filter equipment by project if specified
            if project_id:
                if int(project_id) not in accessible_project_ids:
                    return jsonify({'status': 'error', 'message': 'No access to specified project'}), 403
                equipment_query = Equipment.query.filter_by(project_id=project_id)
                project_name = Project.query.get(project_id).name
            else:
            # For now, show all equipment (in future, filter by accessible projects)
                equipment_query = Equipment.query
                project_name = "All Accessible Projects"
        
            equipment_list = equipment_query.all()
        
        # This would generate actual report in real system
            return jsonify({
                'status': 'success', 
                'message': f'Equipment report generated for {project_name}',
                'report_data': {
                    'project': project_name,
                    'equipment_count': len(equipment_list),
                    'available_count': len([e for e in equipment_list if e.status == 'Available']),
                    'in_use_count': len([e for e in equipment_list if e.status == 'In Use']),
                    'maintenance_count': len([e for e in equipment_list if e.status == 'Maintenance'])
                }
            })
        
        except Exception as e:
            current_app.logger.error(f"Error generating equipment report: {str(e)}")
            return jsonify({'status': 'error', 'message': 'Failed to generate report'}), 500


    @app.route('/project/materials/export', methods=['POST'], endpoint='project.export_materials')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def export_materials():
        """Export materials inventory for accessible projects"""
        try:
            data = request.get_json() or {}
            project_id = data.get('project_id')
        
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
            accessible_project_ids = [p.id for p in accessible_projects]
        
        # Filter materials by project if specified
            if project_id:
                if int(project_id) not in accessible_project_ids:
                    return jsonify({'status': 'error', 'message': 'No access to specified project'}), 403
                materials_query = Material.query.filter_by(project_id=project_id)
                project_name = Project.query.get(project_id).name
            else:
            # For now, show all materials (in future, filter by accessible projects)
                materials_query = Material.query
                project_name = "All Accessible Projects"
        
            materials_list = materials_query.all()
        
        # This would generate actual export in real system
            return jsonify({
                'status': 'success', 
                'message': f'Materials inventory exported for {project_name}',
                'export_data': {
                    'project': project_name,
                    'materials_count': len(materials_list),
                    'in_stock_count': len([m for m in materials_list if m.status == 'In Stock']),
                    'low_stock_count': len([m for m in materials_list if m.status == 'Low Stock']),
                    'out_of_stock_count': len([m for m in materials_list if m.status == 'Out of Stock'])
                }
            })
        
        except Exception as e:
            current_app.logger.error(f"Error exporting materials: {str(e)}")
            return jsonify({'status': 'error', 'message': 'Failed to export materials'}), 500


# --- Daily Production Report (DPR) Routes ---

    @app.route('/project/dpr', endpoint='project.dpr_list')
    @app.route('/project/dpr/<int:selected_project_id>', endpoint='project.dpr_list_with_id')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def dpr_list(selected_project_id=None):
        """List DPRs - Project Managers can create, Staff can fill, Admins can view all"""
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
        # Initialize data variables
            project_staff = []
            project_dprs = []
            selected_project = None
        
        # Check for project ID in query parameters if not in URL path
            if not selected_project_id:
                selected_project_id = request.args.get('selected_project_id')
        
        # If a project is selected, load its staff and DPRs
            if selected_project_id:
                try:
                    selected_project_id = int(selected_project_id)
                    accessible_project_ids = get_user_accessible_project_ids(current_user)
                
                    if selected_project_id in accessible_project_ids:
                        selected_project = Project.query.get(selected_project_id)
                        current_app.logger.info(f"Loading staff for project {selected_project_id}: {selected_project.name if selected_project else 'Not found'}")
                    
                    # Get staff assigned to this project (both users and employees)
                        staff_assignments = StaffAssignment.query.filter_by(project_id=selected_project_id).all()
                        employee_assignments = EmployeeAssignment.query.filter_by(project_id=selected_project_id).all()
                    
                        current_app.logger.info(f"Found {len(staff_assignments)} staff assignments and {len(employee_assignments)} employee assignments")
                    
                    # Collect staff members with their details
                        for assignment in staff_assignments:
                            user = User.query.get(assignment.staff_id)
                            if user:
                                project_staff.append({
                                    'id': user.id,
                                    'name': user.name,
                                    'email': user.email,
                                    'role': assignment.role,
                                    'type': 'user'
                                })
                    
                        for assignment in employee_assignments:
                            employee = Employee.query.get(assignment.employee_id)
                            if employee:
                                project_staff.append({
                                    'id': employee.id,
                                    'name': employee.name,
                                    'email': employee.email,
                                    'role': assignment.role,
                                    'type': 'employee'
                                })
                    
                        current_app.logger.info(f"Final project_staff list has {len(project_staff)} members")
                    
                    # Get DPRs for this project
                        dprs = DailyProductionReport.query.filter_by(project_id=selected_project_id).order_by(
                            DailyProductionReport.report_date.desc()
                        ).all()
                    
                        for dpr in dprs:
                            project_dprs.append({
                                'id': dpr.id,
                                'report_date': dpr.report_date,
                                'status': dpr.status,
                                'created_by': dpr.created_by.name if dpr.created_by else 'Unknown',
                                'assigned_to': dpr.assigned_to.name if dpr.assigned_to else 'Unassigned',
                                'completed_by': dpr.completed_by.name if dpr.completed_by else None,
                                'created_at': dpr.created_at,
                                'completed_at': dpr.completed_at,
                                'project_name': selected_project.name if selected_project else 'Unknown'
                            })
                    else:
                        current_app.logger.warning(f"User {current_user.id} does not have access to project {selected_project_id}")
                except ValueError:
                    current_app.logger.error(f"Invalid project ID: {selected_project_id}")
                    selected_project_id = None
        
            return render_template('projects/dpr.html', 
                                 accessible_projects=accessible_projects,
                                 selected_project=selected_project,
                                 project_staff=project_staff,
                                 project_dprs=project_dprs,
                                 user_role=current_user.role)
        except Exception as e:
            current_app.logger.error(f"DPR list error: {str(e)}")
            return render_template('error.html', error="Failed to load DPR page"), 500


    @app.route('/project/dpr/create', methods=['POST'], endpoint='project.create_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def create_dpr():
        """Create new DPR - Project Managers only"""
        try:
        # Get form data instead of JSON
            project_id = request.form.get('project_id')
            report_date_str = request.form.get('report_date')
            assigned_to_id = request.form.get('assigned_to_id')
            action = request.form.get('action', 'save_draft')
        
        # Validate required fields
            if not project_id or not report_date_str:
                flash('Missing required fields: project and report date', 'error')
                return redirect(url_for('project.dpr_list'))
        
        # Check project access
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if int(project_id) not in accessible_project_ids:
                flash('You do not have access to the specified project', 'error')
                return redirect(url_for('project.dpr_list'))
        
        # Verify project exists
            project = Project.query.get(project_id)
            if not project:
                flash('Project not found', 'error')
                return redirect(url_for('project.dpr_list'))
        
        # Parse report date
            report_date = datetime.strptime(report_date_str, '%Y-%m-%d').date()
        
        # Check if DPR already exists for this date
            existing_dpr = DailyProductionReport.query.filter_by(
                project_id=project_id,
                report_date=report_date
            ).first()
        
            if existing_dpr:
                flash('DPR already exists for this date', 'error')
                return redirect(url_for('project.dpr_list', selected_project_id=project_id))
        
        # Create DPR
            dpr = DailyProductionReport(
                project_id=project_id,
                report_date=report_date,
                created_by_id=current_user.id,
                assigned_to_id=assigned_to_id if assigned_to_id else None,
                status='sent_to_staff' if action == 'send_to_staff' else 'draft',
                sent_at=datetime.now(timezone.utc) if action == 'send_to_staff' else None
            )
        
            db.session.add(dpr)
            db.session.flush()  # Get the DPR ID
        
        # Process production items from form data
            production_items_data = [
                {'code': '1.01', 'description': 'Soft Cut Works', 'unit': 'M3'},
                {'code': '1.02', 'description': 'Fill works', 'unit': 'M3'},
                {'code': '1.03', 'description': 'Scarification', 'unit': 'M2'},
                {'code': '2.01', 'description': 'Blinding', 'unit': 'M3'},
                {'code': '2.02', 'description': 'Base/Top Slab concrete', 'unit': 'M3'},
            ]
        
            for item_data in production_items_data:
                code = item_data['code']
                location = request.form.get(f'location_{code}', '')
                target_qty = request.form.get(f'target_qty_{code}', '0')
                daily_qty = request.form.get(f'daily_qty_{code}', '0')
            
            # Only create production item if any data is provided
                if location or float(target_qty or 0) > 0 or float(daily_qty or 0) > 0:
                    production_item = DPRProductionItem(
                        dpr_id=dpr.id,
                        item_code=code,
                        description=item_data['description'],
                        location=location,
                        unit=item_data['unit'],
                        target_qty=float(target_qty or 0),
                        day_production=float(daily_qty or 0)
                    )
                    db.session.add(production_item)
        
        # Process material usage from form data
            material_items_data = [
                {'number': 1, 'description': 'Cement', 'unit': 'bag'},
                {'number': 2, 'description': 'Earthfill works', 'unit': 'trucks'},
                {'number': 3, 'description': 'Cut work', 'unit': 'trucks'},
                {'number': 4, 'description': 'Diesel', 'unit': 'ltr'},
                {'number': 5, 'description': 'Concrete Mixer small truck', 'unit': 'trucks'},
            ]
        
            for material_data in material_items_data:
                number = material_data['number']
                quantity = request.form.get(f'material_qty_{number}', '0')
            
            # Only create material item if quantity is provided
                if float(quantity or 0) > 0:
                    material_item = DPRMaterialUsage(
                        dpr_id=dpr.id,
                        item_number=number,
                        description=material_data['description'],
                        unit=material_data['unit'],
                        quantity_used=float(quantity or 0)
                    )
                    db.session.add(material_item)
        
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} created DPR for project {project_id} on {report_date}")
        
        # Send email notification if DPR is assigned to staff
            if action == 'send_to_staff' and dpr.assigned_to_id:
                assigned_staff = User.query.get(dpr.assigned_to_id)
                if assigned_staff and assigned_staff.email:
                    try:
                        email_subject = f"Daily Production Report Assignment - {project.name}"
                        email_body = f"""
    Dear {assigned_staff.name},

    You have been assigned a Daily Production Report to fill out for the project: {project.name}

    Report Date: {report_date.strftime('%B %d, %Y')}
    Created By: {current_user.name}
    Project: {project.name}

    Please log in to your dashboard to fill out the DPR:
    {url_for('project.fill_dpr', dpr_id=dpr.id, _external=True)}

    This DPR includes production items and material usage that need to be completed.

    Best regards,
    SammyA Project Management System
                        """
                    
                        send_email_notification(
                            to_email=assigned_staff.email,
                            subject=email_subject,
                            body=email_body
                        )
                    
                        current_app.logger.info(f"Email notification sent to {assigned_staff.email} for DPR {dpr.id}")
                    
                    except Exception as email_error:
                        current_app.logger.error(f"Failed to send email notification: {str(email_error)}")
                    # Don't fail the DPR creation if email fails
        
            message = f"DPR created successfully for {project.name}"
            if action == 'send_to_staff':
                if dpr.assigned_to_id:
                    assigned_staff = User.query.get(dpr.assigned_to_id)
                    message += f" and sent to {assigned_staff.name if assigned_staff else 'staff'}"
                    if assigned_staff and assigned_staff.email:
                        message += f" (email notification sent to {assigned_staff.email})"
                else:
                    message += " (no staff member assigned)"
        
            flash(message, 'success')
            return redirect(url_for('project.dpr_list', selected_project_id=project_id))
        
        except Exception as e:
            current_app.logger.error(f"Error creating DPR: {str(e)}")
            db.session.rollback()
            flash('Failed to create DPR. Please try again.', 'error')
            return redirect(url_for('project.dpr_list'))


    @app.route('/project/dpr/<int:dpr_id>/fill', methods=['GET', 'POST'], endpoint='project.fill_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def fill_dpr(dpr_id):
        """Fill/Complete DPR - Staff fills, Managers can view"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access - must be assigned to DPR or have manager access
            has_access = (
                dpr.assigned_to_id == current_user.id or  # Assigned staff
                dpr.created_by_id == current_user.id or   # Creating manager
                current_user.has_role(Roles.SUPER_HQ) or  # Admin
                (current_user.has_role(Roles.PROJECT_MANAGER) and dpr.project.project_manager == current_user.name)
            )
        
            if not has_access:
                return render_template('error.html', error="No access to this DPR"), 403
        
            if request.method == 'GET':
                return render_template('projects/dpr_fill.html', dpr=dpr)
        
        # POST - Save DPR data
            action = request.form.get('action')
        
        # Update production items
            for item in dpr.production_items:
                location = request.form.get(f'location_{item.id}')
                previous_qty = request.form.get(f'previous_qty_{item.id}')
                day_production = request.form.get(f'day_production_{item.id}')
                total_qty = request.form.get(f'total_qty_{item.id}')
            
                if location is not None:
                    item.location = location
                if previous_qty is not None:
                    item.previous_qty_done = float(previous_qty) if previous_qty else 0
                if day_production is not None:
                    item.day_production = float(day_production) if day_production else 0
                if total_qty is not None:
                    item.total_qty_done = float(total_qty) if total_qty else 0
        
        # Update material usage
            for material in dpr.material_usage:
                previous_qty = request.form.get(f'material_previous_{material.id}')
                day_usage = request.form.get(f'material_day_{material.id}')
                total_qty = request.form.get(f'material_total_{material.id}')
            
                if previous_qty is not None:
                    material.previous_qty_used = float(previous_qty) if previous_qty else 0
                if day_usage is not None:
                    material.day_usage = float(day_usage) if day_usage else 0
                if total_qty is not None:
                    material.total_qty_used = float(total_qty) if total_qty else 0
        
        # Update DPR metadata
            dpr.issues = request.form.get('issues', '')
            dpr.prepared_by = request.form.get('prepared_by', '')
            dpr.checked_by = request.form.get('checked_by', '')
        
            if action == 'submit_completed':
                dpr.status = 'completed'
                dpr.completed_at = datetime.now(timezone.utc)
                dpr.completed_by_id = current_user.id
        
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} updated DPR {dpr_id} - action: {action}")
        
            message = "DPR saved successfully"
            if action == 'submit_completed':
                message = "DPR submitted successfully"
        
            return jsonify({'status': 'success', 'message': message})
        
        except Exception as e:
            current_app.logger.error(f"Error filling DPR: {str(e)}")
            db.session.rollback()
            return jsonify({'status': 'error', 'message': 'Failed to save DPR'}), 500


    @app.route('/project/dpr/project/<int:project_id>', endpoint='project.get_project_dprs')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def get_project_dprs(project_id):
        """Get DPRs for a specific project"""
        try:
        # Check project access
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if project_id not in accessible_project_ids:
                return jsonify({'status': 'error', 'message': 'No access to project'}), 403
        
            dprs = DailyProductionReport.query.filter_by(project_id=project_id).order_by(
                DailyProductionReport.report_date.desc()
            ).all()
        
            dpr_data = []
            for dpr in dprs:
                dpr_data.append({
                    'id': dpr.id,
                    'report_date': dpr.report_date.strftime('%Y-%m-%d'),
                    'status': dpr.status,
                    'created_by': dpr.created_by.name if dpr.created_by else 'Unknown',
                    'assigned_to': dpr.assigned_to.name if dpr.assigned_to else 'Unassigned',
                    'completed_by': dpr.completed_by.name if dpr.completed_by else None,
                    'created_at': dpr.created_at.strftime('%Y-%m-%d %H:%M'),
                    'completed_at': dpr.completed_at.strftime('%Y-%m-%d %H:%M') if dpr.completed_at else None
                })
        
            return jsonify({'status': 'success', 'dprs': dpr_data})
        
        except Exception as e:
            current_app.logger.error(f"Error getting project DPRs: {str(e)}")
            return jsonify({'status': 'error', 'message': 'Failed to load DPRs'}), 500


    @app.route('/project/reports', endpoint='project.reports_index')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def reports_index():
        """Project Reports page with server-side data loading"""
    # Handle project selection from form
        selected_project_id = request.args.get('selected_project_id', type=int)
        return reports_view(selected_project_id)

    @app.route('/project/reports/<int:selected_project_id>', endpoint='project.reports_project')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def reports_project(selected_project_id):
        """Project Reports page for a specific project"""
        return reports_view(selected_project_id)

    def reports_view(selected_project_id=None):
        """Project Reports page with server-side data loading"""
        try:
        # Get user's accessible projects
            accessible_projects = get_user_accessible_projects(current_user)
        
        # Get report types for form dropdown
            report_types = ['Progress Report', 'Financial Report', 'Material Report', 'Equipment Report']
        
        # Initialize data variables
            project_reports = []
            project_dprs = []
            dpr_summary = {'total': 0, 'pending': 0, 'completed': 0, 'monthly': 0}
            selected_project = None
        
        # If a project is selected, load its data
            if selected_project_id:
                accessible_project_ids = get_user_accessible_project_ids(current_user)
            
                if selected_project_id in accessible_project_ids:
                    selected_project = Project.query.get(selected_project_id)
                
                # Load reports (all reports since Report model doesn't have project_id)
                    reports = Report.query.order_by(Report.date.desc()).limit(20).all()
                
                    for report in reports:
                        uploader = User.query.get(report.uploader_id) if report.uploader_id else None
                        project_reports.append({
                            'id': report.id,
                            'title': getattr(report, 'title', None) or f"{report.type} Report",
                            'type': report.type,
                            'date': report.date,
                            'author': uploader.name if uploader else 'Unknown',
                            'status': getattr(report, 'status', 'Draft'),
                            'description': getattr(report, 'description', f'Report file: {report.filename}'),
                            'filename': report.filename
                        })
                
                # Load DPRs for the selected project
                    try:
                        dprs = DailyProductionReport.query.filter_by(project_id=selected_project_id).order_by(
                            DailyProductionReport.report_date.desc()
                        ).all()
                    
                        current_month = date.today().month
                        current_year = date.today().year
                    
                        for dpr in dprs:
                            try:
                                project_dprs.append({
                                    'id': dpr.id,
                                    'report_date': dpr.report_date,
                                    'status': dpr.status,
                                    'created_by': dpr.created_by.name if dpr.created_by else 'Unknown',
                                    'assigned_to': dpr.assigned_to.name if dpr.assigned_to else 'Unassigned',
                                    'completed_by': dpr.completed_by.name if dpr.completed_by else None,
                                    'created_at': dpr.created_at,
                                    'completed_at': dpr.completed_at,
                                    'issues': dpr.issues,
                                    'prepared_by': dpr.prepared_by,
                                    'checked_by': dpr.checked_by
                                })
                            except Exception as dpr_error:
                                current_app.logger.error(f"Error processing DPR {dpr.id}: {str(dpr_error)}")
                            # Add a basic entry for this DPR with safe data
                                project_dprs.append({
                                    'id': dpr.id,
                                    'report_date': dpr.report_date,
                                    'status': dpr.status,
                                    'created_by': 'Unknown',
                                    'assigned_to': 'Unassigned',
                                    'completed_by': None,
                                    'created_at': dpr.created_at,
                                    'completed_at': dpr.completed_at,
                                    'issues': getattr(dpr, 'issues', ''),
                                    'prepared_by': getattr(dpr, 'prepared_by', ''),
                                    'checked_by': getattr(dpr, 'checked_by', '')
                                })
                    
                    # Calculate DPR summary
                        dpr_summary = {
                            'total': len(dprs),
                            'pending': len([d for d in dprs if d.status == 'sent_to_staff']),
                            'completed': len([d for d in dprs if d.status == 'completed']),
                            'monthly': len([d for d in dprs if d.report_date.month == current_month and d.report_date.year == current_year])
                        }
                    except Exception as dpr_loading_error:
                        current_app.logger.error(f"Error loading DPRs for project {selected_project_id}: {str(dpr_loading_error)}")
                    # Set empty DPR data if there's an error
                        project_dprs = []
                        dpr_summary = {'total': 0, 'pending': 0, 'completed': 0, 'monthly': 0}
        
            return render_template('projects/reports.html', 
                                 accessible_projects=accessible_projects,
                                 user_role=current_user.role,
                                 selected_project=selected_project,
                                 project_reports=project_reports,
                                 project_dprs=project_dprs,
                                 dpr_summary=dpr_summary,
                                 data={'report_types': report_types})
        except Exception as e:
            current_app.logger.error(f"Reports page error: {str(e)}")
            return render_template('error.html', error="Failed to load reports page"), 500



    @app.route('/project/reports/project/<int:project_id>', endpoint='project.get_project_reports')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def get_project_reports(project_id):
        """Get general reports for a specific project"""
        try:
            current_app.logger.info(f"Fetching reports for project {project_id}")
        
        # Check project access
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if project_id not in accessible_project_ids:
                return jsonify({'status': 'error', 'message': 'No access to project'}), 403
        
        # Since the Report model doesn't have project_id, we'll create sample reports for now
        # In a real implementation, you'd either add project_id to Report model or link through another table
            current_app.logger.info(f"Report model structure: {Report.__table__.columns.keys()}")
        
        # For now, return all reports (could be filtered by uploader if they're project staff)
            reports = Report.query.order_by(Report.date.desc()).limit(10).all()
        
            report_data = []
            for report in reports:
            # Get uploader info for the report
                uploader = User.query.get(report.uploader_id) if report.uploader_id else None
            
                report_data.append({
                    'id': report.id,
                    'title': getattr(report, 'title', None) or f"{report.type} Report",
                    'type': report.type,
                    'date': report.date.strftime('%Y-%m-%d') if report.date else 'Unknown',
                    'author': uploader.name if uploader else 'Unknown',
                    'status': getattr(report, 'status', 'Draft'),
                    'description': getattr(report, 'description', f'Report file: {report.filename}')
                })
        
            current_app.logger.info(f"Found {len(report_data)} reports")
            return jsonify({'status': 'success', 'reports': report_data})
        
        except Exception as e:
            current_app.logger.error(f"Error getting project reports: {str(e)}")
            current_app.logger.error(f"Traceback: {traceback.format_exc()}")
            return jsonify({'status': 'error', 'message': f'Failed to load reports: {str(e)}'}), 500


    @app.route('/project/reports/create', methods=['POST'], endpoint='project.create_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def create_report():
        """Create a new report"""
        try:
        # Handle both JSON and form data
            if request.is_json:
                data = request.get_json()
            else:
                data = request.form.to_dict()
        
        # Validate required fields
            if not data.get('title') or not data.get('type'):
                if request.is_json:
                    return jsonify({'status': 'error', 'message': 'Missing required fields'}), 400
                else:
                    flash('Missing required fields', 'error')
                    return redirect(url_for('project.reports_index'))
        
            project_id = data.get('project_id')
            if project_id:
            # Check project access if project_id is provided
                accessible_project_ids = get_user_accessible_project_ids(current_user)
                if int(project_id) not in accessible_project_ids:
                    if request.is_json:
                        return jsonify({'status': 'error', 'message': 'No access to specified project'}), 403
                    else:
                        flash('No access to specified project', 'error')
                        return redirect(url_for('project.reports_index'))
        
        # Create filename based on title and type
            title = data['title'].replace(' ', '_').lower()
            report_type = data['type'].replace(' ', '_').lower()
            filename = f"{report_type}_{title}_{datetime.now().strftime('%Y%m%d')}.pdf"
        
        # Create report record
            report = Report(
                filename=filename,
                type=data['type'],
                date=datetime.now(),
                uploader_id=current_user.id,
                uploaded_at=datetime.now()
            )
        
            db.session.add(report)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} created report: {data['title']}")
        
            if request.is_json:
                return jsonify({
                    'status': 'success', 
                    'message': f"Report '{data['title']}' created successfully",
                    'report_id': report.id
                })
            else:
                flash(f"Report '{data['title']}' created successfully", 'success')
                if project_id:
                    return redirect(url_for('project.reports_index', selected_project_id=project_id))
                else:
                    return redirect(url_for('project.reports_index'))
        
        except Exception as e:
            current_app.logger.error(f"Error creating report: {str(e)}")
            db.session.rollback()
            if request.is_json:
                return jsonify({'status': 'error', 'message': 'Failed to create report'}), 500
            else:
                flash('Failed to create report', 'error')
                return redirect(url_for('project.reports_index'))


    @app.route('/project/dpr/<int:dpr_id>/details', endpoint='project.get_dpr_details')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def get_dpr_details(dpr_id):
        """Get detailed DPR information including production items and material usage"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access - must be assigned to DPR or have manager access
            has_access = (
                dpr.assigned_to_id == current_user.id or  # Assigned staff
                dpr.created_by_id == current_user.id or   # Creating manager
                current_user.has_role(Roles.SUPER_HQ) or  # Admin
                (current_user.has_role(Roles.PROJECT_MANAGER) and dpr.project.project_manager == current_user.name)
            )
        
            if not has_access:
                return jsonify({'status': 'error', 'message': 'No access to this DPR'}), 403
        
        # Build production items data
            production_items = []
            for item in dpr.production_items:
                production_items.append({
                    'id': item.id,
                    'item_code': item.item_code,
                    'description': item.description,
                    'location': item.location,
                    'unit': item.unit,
                    'target_qty': float(item.target_qty),
                    'previous_qty_done': float(item.previous_qty_done),
                    'day_production': float(item.day_production),
                    'total_qty_done': float(item.total_qty_done)
                })
        
        # Build material usage data
            material_usage = []
            for material in dpr.material_usage:
                material_usage.append({
                    'id': material.id,
                    'item_number': material.item_number,
                    'description': material.description,
                    'unit': material.unit,
                    'previous_qty_used': float(material.previous_qty_used),
                    'day_usage': float(material.day_usage),
                    'total_qty_used': float(material.total_qty_used)
                })
        
            dpr_data = {
                'id': dpr.id,
                'report_date': dpr.report_date.strftime('%Y-%m-%d'),
                'status': dpr.status,
                'created_by': dpr.created_by.name if dpr.created_by else 'Unknown',
                'assigned_to': dpr.assigned_to.name if dpr.assigned_to else 'Unassigned',
                'completed_by': dpr.completed_by.name if dpr.completed_by else None,
                'created_at': dpr.created_at.strftime('%Y-%m-%d %H:%M'),
                'completed_at': dpr.completed_at.strftime('%Y-%m-%d %H:%M') if dpr.completed_at else None,
                'issues': dpr.issues,
                'prepared_by': dpr.prepared_by,
                'checked_by': dpr.checked_by,
                'production_items': production_items,
                'material_usage': material_usage
            }
        
            return jsonify({'status': 'success', 'dpr': dpr_data})
        
        except Exception as e:
            current_app.logger.error(f"Error getting DPR details: {str(e)}")
            return jsonify({'status': 'error', 'message': 'Failed to load DPR details'}), 500


    @app.route('/project/dpr/<int:dpr_id>/view', endpoint='project.view_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def view_dpr(dpr_id):
        """View DPR details in web interface"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access - must be assigned to DPR or have manager access
            has_access = (
                dpr.assigned_to_id == current_user.id or  # Assigned staff
                dpr.created_by_id == current_user.id or   # Creating manager
                current_user.has_role(Roles.SUPER_HQ) or  # Admin
                (current_user.has_role(Roles.PROJECT_MANAGER) and 
                 dpr.project_id in get_user_accessible_project_ids(current_user))
            )
        
            if not has_access:
                flash('You do not have access to view this DPR.', 'error')
                return redirect(url_for('project.dpr_list'))
        
        # Get production items and material usage
            production_items = dpr.production_items
            material_usage = dpr.material_usage
        
            return render_template('projects/dpr_view.html',
                                 dpr=dpr,
                                 production_items=production_items,
                                 material_usage=material_usage,
                                 user_role=current_user.role)
        
        except Exception as e:
            current_app.logger.error(f"Error viewing DPR: {str(e)}")
            flash('Failed to load DPR details.', 'error')
            return redirect(url_for('project.dpr_list'))


    @app.route('/project/dpr/<int:dpr_id>/approve', methods=['POST'], endpoint='project.approve_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def approve_dpr(dpr_id):
        """Approve a completed DPR"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access - must be manager or admin
            has_access = (
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER) and 
                 dpr.project_id in get_user_accessible_project_ids(current_user))
            )
        
            if not has_access:
                return jsonify({'success': False, 'message': 'No access to approve this DPR'}), 403
        
            if dpr.status not in ['completed', 'sent_to_staff']:
                return jsonify({'success': False, 'message': 'DPR must be completed before approval'}), 400
        
        # Update DPR status
            dpr.status = 'approved'
            dpr.reviewed_at = datetime.now(timezone.utc)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} approved DPR {dpr_id}")
        
            return jsonify({'success': True, 'message': 'DPR approved successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error approving DPR: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to approve DPR'}), 500


    @app.route('/project/dpr/<int:dpr_id>/reject', methods=['POST'], endpoint='project.reject_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def reject_dpr(dpr_id):
        """Reject a completed DPR"""
        try:
            data = request.get_json()
            reason = data.get('reason', '').strip()
        
            if not reason:
                return jsonify({'success': False, 'message': 'Rejection reason is required'}), 400
        
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access - must be manager or admin
            has_access = (
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER) and 
                 dpr.project_id in get_user_accessible_project_ids(current_user))
            )
        
            if not has_access:
                return jsonify({'success': False, 'message': 'No access to reject this DPR'}), 403
        
            if dpr.status not in ['completed', 'sent_to_staff']:
                return jsonify({'success': False, 'message': 'DPR must be completed before rejection'}), 400
        
        # Update DPR status and add rejection reason
            dpr.status = 'rejected'
            dpr.issues = f"REJECTED: {reason}\n\n{dpr.issues or ''}"
            dpr.reviewed_at = datetime.now(timezone.utc)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} rejected DPR {dpr_id}: {reason}")
        
            return jsonify({'success': True, 'message': 'DPR rejected successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error rejecting DPR: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to reject DPR'}), 500


# ============================================================================
# COMPREHENSIVE REPORTS CRUD OPERATIONS
# ============================================================================

    @app.route('/project/reports/list', endpoint='project.reports_list')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def reports_list():
        """List reports with project selection - supports both HTML and JSON"""
        try:
            project_id = request.args.get('project_id', type=int)
            current_app.logger.info(f"User {current_user.id} requesting reports list for project {project_id}")
        
        # Check if this is an AJAX request expecting JSON
            if request.headers.get('Content-Type') == 'application/json' or request.args.get('format') == 'json':
            # Return JSON data for AJAX calls
                if project_id:
                    accessible_project_ids = get_user_accessible_project_ids(current_user)
                
                    if project_id not in accessible_project_ids:
                        return jsonify({'success': False, 'message': 'No access to project'}), 403
                
                # Get reports (simplified since Report model doesn't have project_id)
                    reports = Report.query.order_by(Report.date.desc()).limit(20).all()
                
                    reports_data = []
                    for report in reports:
                        uploader = User.query.get(report.uploader_id) if report.uploader_id else None
                        reports_data.append({
                            'id': report.id,
                            'title': getattr(report, 'title', None) or f"{report.type} Report",
                            'type': report.type,
                            'date': report.date.strftime('%Y-%m-%d') if report.date else 'Unknown',
                            'author': uploader.name if uploader else 'Unknown',
                            'status': getattr(report, 'status', 'Draft'),
                            'description': getattr(report, 'description', f'Report file: {report.filename}'),
                            'filename': report.filename
                        })
                
                    return jsonify({'success': True, 'reports': reports_data})
                else:
                    return jsonify({'success': False, 'message': 'No project selected'})
            else:
            # Return HTML page for regular requests
                return reports_view(project_id)
            
        except Exception as e:
            current_app.logger.error(f"Error in reports_list: {str(e)}")
            current_app.logger.error(f"Traceback: {traceback.format_exc()}")
        
        # Return appropriate error response based on request type
            if request.headers.get('Content-Type') == 'application/json' or request.args.get('format') == 'json':
                return jsonify({'success': False, 'message': 'Failed to load reports'}), 500
            else:
                return render_template('error.html', error="Failed to load reports"), 500


    @app.route('/project/reports/<int:report_id>/view', endpoint='project.view_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def view_report(report_id):
        """View a specific report"""
        try:
            report = Report.query.get_or_404(report_id)
        
        # Check access permissions
            uploader = User.query.get(report.uploader_id) if report.uploader_id else None
        
            return render_template('projects/report_view.html',
                                 report=report,
                                 uploader=uploader,
                                 user_role=current_user.role)
        
        except Exception as e:
            current_app.logger.error(f"Error viewing report: {str(e)}")
            flash('Failed to load report details.', 'error')
            return redirect(url_for('project.reports_index'))


    @app.route('/project/reports/<int:report_id>/edit', methods=['GET', 'POST'], endpoint='project.edit_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def edit_report(report_id):
        """Edit a specific report"""
        try:
            report = Report.query.get_or_404(report_id)
        
        # Check if user can edit this report
            can_edit = (
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER)) or
                (report.uploader_id == current_user.id)
            )
        
            if not can_edit:
                flash('You do not have permission to edit this report.', 'error')
                return redirect(url_for('project.view_report', report_id=report_id))
        
            if request.method == 'POST':
            # Update report details
                if hasattr(report, 'title'):
                    report.title = request.form.get('title', report.filename)
                if hasattr(report, 'description'):
                    report.description = request.form.get('description', '')
            
                report.type = request.form.get('type', report.type)
            
                db.session.commit()
            
                current_app.logger.info(f"User {current_user.id} updated report {report_id}")
                flash('Report updated successfully.', 'success')
                return redirect(url_for('project.view_report', report_id=report_id))
        
            return render_template('projects/report_edit.html',
                                 report=report,
                                 user_role=current_user.role)
        
        except Exception as e:
            current_app.logger.error(f"Error editing report: {str(e)}")
            flash('Failed to edit report.', 'error')
            return redirect(url_for('project.reports_index'))


    @app.route('/project/reports/<int:report_id>/delete', methods=['DELETE'], endpoint='project.delete_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_report(report_id):
        """Delete a specific report"""
        try:
            report = Report.query.get_or_404(report_id)
        
        # Check if user can delete this report
            can_delete = (
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER))
            )
        
            if not can_delete:
                return jsonify({'success': False, 'message': 'No permission to delete this report'}), 403
        
        # Delete the report file if it exists
            if report.filename:
                try:
                    file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'reports', report.filename)
                    if os.path.exists(file_path):
                        os.remove(file_path)
                except Exception as file_error:
                    current_app.logger.warning(f"Could not delete report file: {file_error}")
        
        # Delete the database record
            db.session.delete(report)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} deleted report {report_id}")
        
            return jsonify({'success': True, 'message': 'Report deleted successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error deleting report: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to delete report'}), 500


    @app.route('/project/reports/<int:report_id>/approve', methods=['POST'], endpoint='project.approve_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def approve_report(report_id):
        """Approve a report"""
        try:
            report = Report.query.get_or_404(report_id)
        
        # Add status field if it doesn't exist
            if not hasattr(report, 'status'):
            # For existing reports without status, we'll use a different approach
                current_app.logger.info(f"Report {report_id} approved by user {current_user.id}")
                return jsonify({'success': True, 'message': 'Report approved successfully'})
        
            report.status = 'approved'
        
        # Add approved_at field if it exists
            if hasattr(report, 'approved_at'):
                report.approved_at = datetime.now(timezone.utc)
        
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} approved report {report_id}")
        
            return jsonify({'success': True, 'message': 'Report approved successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error approving report: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to approve report'}), 500


    @app.route('/project/reports/<int:report_id>/reject', methods=['POST'], endpoint='project.reject_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def reject_report(report_id):
        """Reject a report"""
        try:
            data = request.get_json()
            reason = data.get('reason', '').strip()
        
            if not reason:
                return jsonify({'success': False, 'message': 'Rejection reason is required'}), 400
        
            report = Report.query.get_or_404(report_id)
        
        # Add status field if it doesn't exist
            if not hasattr(report, 'status'):
                current_app.logger.info(f"Report {report_id} rejected by user {current_user.id}: {reason}")
                return jsonify({'success': True, 'message': 'Report rejected successfully'})
        
            report.status = 'rejected'
        
        # Add rejection reason to description or comments
            if hasattr(report, 'rejection_reason'):
                report.rejection_reason = reason
            elif hasattr(report, 'description'):
                report.description = f"REJECTED: {reason}\n\n{report.description or ''}"
        
        # Add rejected_at field if it exists
            if hasattr(report, 'rejected_at'):
                report.rejected_at = datetime.now(timezone.utc)
        
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} rejected report {report_id}: {reason}")
        
            return jsonify({'success': True, 'message': 'Report rejected successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error rejecting report: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to reject report'}), 500


    @app.route('/project/reports/<int:report_id>/export', endpoint='project.export_report')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def export_report(report_id):
        """Export a specific report"""
        try:
            report = Report.query.get_or_404(report_id)
        
        # If the report has a file, serve it
            if report.filename:
                file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'reports', report.filename)
                if os.path.exists(file_path):
                    return send_file(file_path, as_attachment=True, download_name=report.filename)
        
        # Otherwise, generate a PDF export
            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import letter
        
            buffer = io.BytesIO()
            p = canvas.Canvas(buffer, pagesize=letter)
        
        # Add report content to PDF
            p.drawString(100, 750, f"Report: {getattr(report, 'title', report.filename)}")
            p.drawString(100, 730, f"Type: {report.type}")
            p.drawString(100, 710, f"Date: {report.date.strftime('%Y-%m-%d') if report.date else 'Unknown'}")
        
            if hasattr(report, 'description') and report.description:
                p.drawString(100, 690, "Description:")
            # Split long text into lines
                lines = report.description.split('\n')
                y = 670
                for line in lines:
                    if len(line) > 80:
                    # Split long lines
                        words = line.split(' ')
                        current_line = ''
                        for word in words:
                            if len(current_line + word) < 80:
                                current_line += word + ' '
                            else:
                                p.drawString(100, y, current_line.strip())
                                y -= 20
                                current_line = word + ' '
                        if current_line:
                            p.drawString(100, y, current_line.strip())
                            y -= 20
                    else:
                        p.drawString(100, y, line)
                        y -= 20
        
            p.showPage()
            p.save()
        
            buffer.seek(0)
        
            response = make_response(buffer.getvalue())
            response.headers['Content-Type'] = 'application/pdf'
            response.headers['Content-Disposition'] = f'attachment; filename=report_{report_id}.pdf'
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Error exporting report: {str(e)}")
            flash('Failed to export report.', 'error')
            return redirect(url_for('project.view_report', report_id=report_id))


# ============================================================================
# DPR CRUD OPERATIONS ADDITIONS
# ============================================================================

    @app.route('/project/dpr/<int:dpr_id>/edit', methods=['GET', 'POST'], endpoint='project.edit_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def edit_dpr(dpr_id):
        """Edit an existing DPR"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access permissions
            has_access = (
                dpr.assigned_to_id == current_user.id or
                dpr.created_by_id == current_user.id or
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER) and 
                 dpr.project_id in get_user_accessible_project_ids(current_user))
            )
        
            if not has_access:
                flash('You do not have access to edit this DPR.', 'error')
                return redirect(url_for('project.view_dpr', dpr_id=dpr_id))
        
            if request.method == 'POST':
            # Update DPR fields
                dpr.issues = request.form.get('issues', dpr.issues)
                dpr.prepared_by = request.form.get('prepared_by', dpr.prepared_by)
                dpr.checked_by = request.form.get('checked_by', dpr.checked_by)
            
            # Update production items and material usage would go here
            # This would require more complex form handling
            
                db.session.commit()
            
                current_app.logger.info(f"User {current_user.id} updated DPR {dpr_id}")
                flash('DPR updated successfully.', 'success')
                return redirect(url_for('project.view_dpr', dpr_id=dpr_id))
        
        # Get production items and material usage
            production_items = dpr.production_items
            material_usage = dpr.material_usage
        
            return render_template('projects/dpr_edit.html',
                                 dpr=dpr,
                                 production_items=production_items,
                                 material_usage=material_usage,
                                 user_role=current_user.role)
        
        except Exception as e:
            current_app.logger.error(f"Error editing DPR: {str(e)}")
            flash('Failed to edit DPR.', 'error')
            return redirect(url_for('project.dpr_list'))


    @app.route('/project/dpr/<int:dpr_id>/delete', methods=['DELETE'], endpoint='project.delete_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER])
    def delete_dpr(dpr_id):
        """Delete a specific DPR"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access permissions
            has_access = (
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER) and 
                 dpr.project_id in get_user_accessible_project_ids(current_user))
            )
        
            if not has_access:
                return jsonify({'success': False, 'message': 'No permission to delete this DPR'}), 403
        
        # Delete related records first
            DPRProductionItem.query.filter_by(dpr_id=dpr_id).delete()
            DPRMaterialUsage.query.filter_by(dpr_id=dpr_id).delete()
        
        # Delete the DPR
            db.session.delete(dpr)
            db.session.commit()
        
            current_app.logger.info(f"User {current_user.id} deleted DPR {dpr_id}")
        
            return jsonify({'success': True, 'message': 'DPR deleted successfully'})
        
        except Exception as e:
            current_app.logger.error(f"Error deleting DPR: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to delete DPR'}), 500


    @app.route('/project/dpr/<int:dpr_id>/export', endpoint='project.export_dpr')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def export_dpr(dpr_id):
        """Export a specific DPR to PDF"""
        try:
            dpr = DailyProductionReport.query.get_or_404(dpr_id)
        
        # Check access permissions
            has_access = (
                dpr.assigned_to_id == current_user.id or
                dpr.created_by_id == current_user.id or
                current_user.has_role(Roles.SUPER_HQ) or
                (current_user.has_role(Roles.PROJECT_MANAGER) and 
                 dpr.project_id in get_user_accessible_project_ids(current_user))
            )
        
            if not has_access:
                return jsonify({'success': False, 'message': 'No access to export this DPR'}), 403
        
        # Generate PDF export using reportlab
            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.lib import colors
            from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet
        
            buffer = io.BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=A4)
            styles = getSampleStyleSheet()
            story = []
        
        # Title
            title = f"Daily Production Report - {dpr.report_date.strftime('%B %d, %Y')}"
            story.append(Paragraph(title, styles['Title']))
            story.append(Spacer(1, 20))
        
        # Header info
            header_data = [
                ['Project:', dpr.project.name if dpr.project else 'Unknown'],
                ['Date:', dpr.report_date.strftime('%Y-%m-%d')],
                ['Status:', dpr.status.replace('_', ' ').title()],
                ['Created By:', dpr.created_by.name if dpr.created_by else 'Unknown'],
                ['Assigned To:', dpr.assigned_to.name if dpr.assigned_to else 'Unassigned']
            ]
        
            header_table = Table(header_data, colWidths=[100, 300])
            header_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.grey),
                ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
                ('BACKGROUND', (1, 0), (1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
        
            story.append(header_table)
            story.append(Spacer(1, 20))
        
        # Production Items
            if dpr.production_items:
                story.append(Paragraph("Production Items", styles['Heading2']))
            
                prod_data = [['Item Code', 'Description', 'Location', 'Unit', 'Target Qty', 'Daily Qty', 'Total Done']]
            
                for item in dpr.production_items:
                    prod_data.append([
                        item.item_code or '',
                        item.description or '',
                        item.location or '',
                        item.unit or '',
                        f"{item.target_qty:.2f}" if item.target_qty else '',
                        f"{item.day_production:.2f}" if item.day_production else '',
                        f"{item.total_qty_done:.2f}" if item.total_qty_done else ''
                    ])
            
                prod_table = Table(prod_data, colWidths=[60, 120, 80, 40, 60, 60, 60])
                prod_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
            
                story.append(prod_table)
                story.append(Spacer(1, 20))
        
        # Material Usage
            if dpr.material_usage:
                story.append(Paragraph("Material Usage", styles['Heading2']))
            
                mat_data = [['Item #', 'Description', 'Unit', 'Previous Used', 'Daily Usage', 'Total Used']]
            
                for material in dpr.material_usage:
                    mat_data.append([
                        material.item_number or '',
                        material.description or '',
                        material.unit or '',
                        f"{material.previous_qty_used:.2f}" if material.previous_qty_used else '',
                        f"{material.day_usage:.2f}" if material.day_usage else '',
                        f"{material.total_qty_used:.2f}" if material.total_qty_used else ''
                    ])
            
                mat_table = Table(mat_data, colWidths=[60, 140, 60, 80, 80, 80])
                mat_table.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                    ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 8),
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                    ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black)
                ]))
            
                story.append(mat_table)
                story.append(Spacer(1, 20))
        
        # Issues and Comments
            if dpr.issues:
                story.append(Paragraph("Issues and Comments", styles['Heading2']))
                story.append(Paragraph(dpr.issues, styles['Normal']))
                story.append(Spacer(1, 20))
        
        # Signatures
            sig_data = [
                ['Prepared By:', dpr.prepared_by or ''],
                ['Checked By:', dpr.checked_by or '']
            ]
        
            sig_table = Table(sig_data, colWidths=[100, 200])
            sig_table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 12)
            ]))
        
            story.append(sig_table)
        
        # Build PDF
            doc.build(story)
            buffer.seek(0)
        
            response = make_response(buffer.getvalue())
            response.headers['Content-Type'] = 'application/pdf'
            response.headers['Content-Disposition'] = f'attachment; filename=DPR_{dpr.project.name}_{dpr.report_date.strftime("%Y%m%d")}.pdf'
        
            current_app.logger.info(f"User {current_user.id} exported DPR {dpr_id}")
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Error exporting DPR: {str(e)}")
            current_app.logger.error(f"Traceback: {traceback.format_exc()}")
            return jsonify({'success': False, 'message': 'Failed to export DPR'}), 500


# ============================================================================
# BULK OPERATIONS AND EXPORT ROUTES
# ============================================================================

    @app.route('/project/reports/export_selected', methods=['POST'], endpoint='project.export_selected_reports')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def export_selected_reports():
        """Export selected reports"""
        try:
            report_ids = request.form.getlist('report_ids')
            if not report_ids:
                return jsonify({'success': False, 'message': 'No reports selected'}), 400
        
        # Convert to integers
            try:
                report_ids = [int(rid) for rid in report_ids]
            except ValueError:
                return jsonify({'success': False, 'message': 'Invalid report IDs'}), 400
        
        # Get the selected reports
            reports = Report.query.filter(Report.id.in_(report_ids)).all()
        
            if not reports:
                return jsonify({'success': False, 'message': 'No reports found'}), 404
        
        # Create ZIP export for multiple reports
        
            zip_buffer = io.BytesIO()
        
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # Add a summary text file
                summary = f"Selected Reports Export\n"
                summary += f"Export Date: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')}\n"
                summary += f"Total Reports: {len(reports)}\n\n"
            
                for report in reports:
                    summary += f"- {report.type} Report ({report.date.strftime('%Y-%m-%d') if report.date else 'Unknown Date'})\n"
                    summary += f"  ID: {report.id}\n"
                    summary += f"  File: {report.filename}\n"
                    if hasattr(report, 'description') and report.description:
                        summary += f"  Description: {report.description[:100]}...\n"
                    summary += "\n"
            
                zip_file.writestr('selected_reports_summary.txt', summary)
            
            # Add individual report files if they exist
                for report in reports:
                    if report.filename:
                        file_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'reports', report.filename)
                        if os.path.exists(file_path):
                            zip_file.write(file_path, f"reports/{report.filename}")
        
            zip_buffer.seek(0)
        
            response = make_response(zip_buffer.getvalue())
            response.headers['Content-Type'] = 'application/zip'
            response.headers['Content-Disposition'] = f'attachment; filename=selected_reports_{datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")}.zip'
        
            current_app.logger.info(f"User {current_user.id} exported {len(reports)} selected reports")
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Error exporting selected reports: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to export reports'}), 500


    @app.route('/project/reports/project/<int:project_id>/export', endpoint='project.export_project_reports')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def export_project_reports(project_id):
        """Export all reports for a project"""
        try:
        # Check project access
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if project_id not in accessible_project_ids:
                return jsonify({'success': False, 'message': 'No access to project'}), 403
        
            project = Project.query.get_or_404(project_id)
        
        # For now, create a summary report
        
            zip_buffer = io.BytesIO()
        
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # Add a summary text file
                summary = f"Project Reports Summary\n"
                summary += f"Project: {project.name}\n"
                summary += f"Export Date: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            
                reports = Report.query.order_by(Report.date.desc()).limit(20).all()
                summary += f"Total Reports: {len(reports)}\n\n"
            
                for report in reports:
                    summary += f"- {report.type} Report ({report.date.strftime('%Y-%m-%d') if report.date else 'Unknown Date'})\n"
                    summary += f"  File: {report.filename}\n\n"
            
                zip_file.writestr('reports_summary.txt', summary)
        
            zip_buffer.seek(0)
        
            response = make_response(zip_buffer.getvalue())
            response.headers['Content-Type'] = 'application/zip'
            response.headers['Content-Disposition'] = f'attachment; filename={project.name}_reports.zip'
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Error exporting project reports: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to export reports'}), 500


    @app.route('/project/dpr/export_selected', methods=['POST'], endpoint='project.export_selected_dprs')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def export_selected_dprs():
        """Export selected DPRs"""
        try:
            dpr_ids = request.form.getlist('dpr_ids')
            if not dpr_ids:
                return jsonify({'success': False, 'message': 'No DPRs selected'}), 400
        
        # Convert to integers
            try:
                dpr_ids = [int(did) for did in dpr_ids]
            except ValueError:
                return jsonify({'success': False, 'message': 'Invalid DPR IDs'}), 400
        
        # Get the selected DPRs
            dprs = DailyProductionReport.query.filter(DailyProductionReport.id.in_(dpr_ids)).all()
        
            if not dprs:
                return jsonify({'success': False, 'message': 'No DPRs found'}), 404
        
        # Create Excel export for multiple DPRs
        
        # Prepare DPR data
            dpr_data = []
            prod_data = []
            mat_data = []
        
            for dpr in dprs:
                dpr_data.append({
                    'DPR ID': dpr.id,
                    'Date': dpr.report_date.strftime('%Y-%m-%d'),
                    'Project': dpr.project.name if dpr.project else 'Unknown',
                    'Status': dpr.status,
                    'Created By': dpr.created_by.name if dpr.created_by else 'Unknown',
                    'Assigned To': dpr.assigned_to.name if dpr.assigned_to else 'Unassigned',
                    'Completed At': dpr.completed_at.strftime('%Y-%m-%d %H:%M') if dpr.completed_at else '',
                    'Issues': dpr.issues or '',
                    'Prepared By': dpr.prepared_by or '',
                    'Checked By': dpr.checked_by or ''
                })
            
            # Production items
                for item in dpr.production_items:
                    prod_data.append({
                        'DPR ID': dpr.id,
                        'DPR Date': dpr.report_date.strftime('%Y-%m-%d'),
                        'Item Code': item.item_code,
                        'Description': item.description,
                        'Location': item.location,
                        'Unit': item.unit,
                        'Target Qty': item.target_qty,
                        'Previous Done': item.previous_qty_done,
                        'Daily Production': item.day_production,
                        'Total Done': item.total_qty_done
                    })
            
            # Material usage
                for material in dpr.material_usage:
                    mat_data.append({
                        'DPR ID': dpr.id,
                        'DPR Date': dpr.report_date.strftime('%Y-%m-%d'),
                        'Item Number': material.item_number,
                        'Description': material.description,
                        'Unit': material.unit,
                        'Previous Used': material.previous_qty_used,
                        'Daily Usage': material.day_usage,
                        'Total Used': material.total_qty_used
                    })
        
        # Create Excel file
            output = io.BytesIO()
        
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # DPR Summary sheet
                df_summary = pd.DataFrame(dpr_data)
                df_summary.to_excel(writer, sheet_name='Selected DPRs Summary', index=False)
            
            # Production Items sheet
                if prod_data:
                    df_production = pd.DataFrame(prod_data)
                    df_production.to_excel(writer, sheet_name='Production Items', index=False)
            
            # Material Usage sheet
                if mat_data:
                    df_materials = pd.DataFrame(mat_data)
                    df_materials.to_excel(writer, sheet_name='Material Usage', index=False)
        
            output.seek(0)
        
            response = make_response(output.getvalue())
            response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            response.headers['Content-Disposition'] = f'attachment; filename=selected_DPRs_{datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")}.xlsx'
        
            current_app.logger.info(f"User {current_user.id} exported {len(dprs)} selected DPRs")
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Error exporting selected DPRs: {str(e)}")
            return jsonify({'success': False, 'message': 'Failed to export DPRs'}), 500


    @app.route('/project/dpr/project/<int:project_id>/export', endpoint='project.export_project_dprs')
    @login_required
    @role_required([Roles.SUPER_HQ, Roles.PROJECT_MANAGER, Roles.PROJECT_STAFF])
    def export_project_dprs(project_id):
        """Export all DPRs for a project"""
        try:
        # Check project access
            accessible_project_ids = get_user_accessible_project_ids(current_user)
            if project_id not in accessible_project_ids:
                return jsonify({'success': False, 'message': 'No access to project'}), 403
        
            project = Project.query.get_or_404(project_id)
            dprs = DailyProductionReport.query.filter_by(project_id=project_id).order_by(
                DailyProductionReport.report_date.desc()
            ).all()
        
        # Create Excel export
        
        # Prepare DPR data
            dpr_data = []
            for dpr in dprs:
                dpr_data.append({
                    'Date': dpr.report_date.strftime('%Y-%m-%d'),
                    'Status': dpr.status,
                    'Created By': dpr.created_by.name if dpr.created_by else 'Unknown',
                    'Assigned To': dpr.assigned_to.name if dpr.assigned_to else 'Unassigned',
                    'Completed At': dpr.completed_at.strftime('%Y-%m-%d %H:%M') if dpr.completed_at else '',
                    'Issues': dpr.issues or '',
                    'Prepared By': dpr.prepared_by or '',
                    'Checked By': dpr.checked_by or ''
                })
        
        # Create Excel file
            output = io.BytesIO()
        
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
            # DPR Summary sheet
                df_summary = pd.DataFrame(dpr_data)
                df_summary.to_excel(writer, sheet_name='DPR Summary', index=False)
            
            # Production Items sheet
                prod_data = []
                for dpr in dprs:
                    for item in dpr.production_items:
                        prod_data.append({
                            'DPR Date': dpr.report_date.strftime('%Y-%m-%d'),
                            'Item Code': item.item_code,
                            'Description': item.description,
                            'Location': item.location,
                            'Unit': item.unit,
                            'Target Qty': item.target_qty,
                            'Previous Done': item.previous_qty_done,
                            'Daily Production': item.day_production,
                            'Total Done': item.total_qty_done
                        })
            
                if prod_data:
                    df_production = pd.DataFrame(prod_data)
                    df_production.to_excel(writer, sheet_name='Production Items', index=False)
            
            # Material Usage sheet
                mat_data = []
                for dpr in dprs:
                    for material in dpr.material_usage:
                        mat_data.append({
                            'DPR Date': dpr.report_date.strftime('%Y-%m-%d'),
                            'Item Number': material.item_number,
                            'Description': material.description,
                            'Unit': material.unit,
                            'Previous Used': material.previous_qty_used,
                            'Daily Usage': material.day_usage,
                            'Total Used': material.total_qty_used
                        })
            
                if mat_data:
                    df_materials = pd.DataFrame(mat_data)
                    df_materials.to_excel(writer, sheet_name='Material Usage', index=False)
        
            output.seek(0)
        
            response = make_response(output.getvalue())
            response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            response.headers['Content-Disposition'] = f'attachment; filename={project.name}_DPRs.xlsx'
        
            current_app.logger.info(f"User {current_user.id} exported all DPRs for project {project_id}")
        
            return response
        
        except Exception as e:
            current_app.logger.error(f"Error exporting project DPRs: {str(e)}")
            current_app.logger.error(f"Traceback: {traceback.format_exc()}")
            return jsonify({'success': False, 'message': 'Failed to export DPRs'}), 500


    # ==================== USER MANAGEMENT ROUTES ====================
    
    @app.route('/admin/users', endpoint='admin.users')
    @role_required([Roles.SUPER_HQ])
    def admin_users():
        """Display all users with role management capabilities"""
        try:
            # Get filter parameters
            role_filter = request.args.get('role', None)
            search_query = request.args.get('search', '')
            status_filter = request.args.get('status', 'all')
            
            # Base query
            query = User.query
            
            # Apply filters
            if role_filter:
                query = query.filter(User.role == role_filter)
            
            if search_query:
                query = query.filter(
                    db.or_(
                        User.name.ilike(f'%{search_query}%'),
                        User.email.ilike(f'%{search_query}%')
                    )
                )
            
            if status_filter == 'verified':
                query = query.filter(User.is_verified == True)
            elif status_filter == 'unverified':
                query = query.filter(User.is_verified == False)
            
            # Get users
            users = query.order_by(User.created_at.desc()).all()
            
            # Calculate statistics
            total_users = User.query.count()
            verified_users = User.query.filter_by(is_verified=True).count()
            unverified_users = User.query.filter_by(is_verified=False).count()
            
            # Count by role
            role_counts = {}
            for role in Roles.get_all_roles():
                role_counts[role] = User.query.filter_by(role=role).count()
            
            stats = {
                'total': total_users,
                'verified': verified_users,
                'unverified': unverified_users,
                'role_counts': role_counts
            }
            
            current_app.logger.info(f"User {current_user.id} accessed user management")
            
            return render_template('admin/users.html', 
                                 users=users, 
                                 stats=stats,
                                 Roles=Roles,
                                 role_filter=role_filter,
                                 search_query=search_query,
                                 status_filter=status_filter)
        except Exception as e:
            current_app.logger.error(f"Error loading users: {str(e)}")
            flash(f'Error loading users: {str(e)}', 'error')
            return render_template('error.html'), 500
    
    @app.route('/admin/users/<int:user_id>', endpoint='admin.user_details')
    @role_required([Roles.SUPER_HQ])
    def admin_user_details(user_id):
        """View detailed information about a specific user"""
        try:
            user = User.query.get_or_404(user_id)
            
            # Get user activity (you can extend this based on your activity logging)
            activity_count = 0  # Placeholder for activity tracking
            
            return render_template('admin/user_details.html', 
                                 user=user, 
                                 Roles=Roles,
                                 activity_count=activity_count)
        except Exception as e:
            current_app.logger.error(f"Error loading user details: {str(e)}")
            flash(f'Error loading user details: {str(e)}', 'error')
            return redirect(url_for('admin.users'))
    
    @app.route('/admin/users/<int:user_id>/edit-role', methods=['POST'], endpoint='admin.edit_user_role')
    @role_required([Roles.SUPER_HQ])
    def edit_user_role(user_id):
        """Edit a user's role (SUPER_HQ only)"""
        try:
            user = User.query.get_or_404(user_id)
            
            # Prevent self role modification
            if user.id == current_user.id:
                return jsonify({
                    'success': False,
                    'message': 'You cannot modify your own role'
                }), 400
            
            new_role = request.form.get('role')
            
            # Validate role
            if new_role not in Roles.get_all_roles():
                return jsonify({
                    'success': False,
                    'message': 'Invalid role selected'
                }), 400
            
            old_role = user.role
            user.role = new_role
            db.session.commit()
            
            current_app.logger.info(
                f"User {current_user.id} changed user {user_id} role from {old_role} to {new_role}"
            )
            
            return jsonify({
                'success': True,
                'message': f'User role updated to {Roles.ROLE_NAMES.get(new_role, new_role)}'
            })
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error updating user role: {str(e)}")
            return jsonify({
                'success': False,
                'message': f'Error updating role: {str(e)}'
            }), 500
    
    @app.route('/admin/users/<int:user_id>/toggle-status', methods=['POST'], endpoint='admin.toggle_user_status')
    @role_required([Roles.SUPER_HQ])
    def toggle_user_status(user_id):
        """Toggle user verification status (activate/deactivate)"""
        try:
            user = User.query.get_or_404(user_id)
            
            # Prevent self-deactivation
            if user.id == current_user.id:
                return jsonify({
                    'success': False,
                    'message': 'You cannot deactivate your own account'
                }), 400
            
            user.is_verified = not user.is_verified
            db.session.commit()
            
            status = 'activated' if user.is_verified else 'deactivated'
            current_app.logger.info(f"User {current_user.id} {status} user {user_id}")
            
            return jsonify({
                'success': True,
                'message': f'User {status} successfully',
                'is_verified': user.is_verified
            })
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error toggling user status: {str(e)}")
            return jsonify({
                'success': False,
                'message': f'Error toggling status: {str(e)}'
            }), 500
    
    @app.route('/admin/users/<int:user_id>/delete', methods=['POST'], endpoint='admin.delete_user')
    @role_required([Roles.SUPER_HQ])
    def delete_user(user_id):
        """Delete a user (SUPER_HQ only)"""
        try:
            user = User.query.get_or_404(user_id)
            
            # Prevent self-deletion
            if user.id == current_user.id:
                return jsonify({
                    'success': False,
                    'message': 'You cannot delete your own account'
                }), 400
            
            user_email = user.email
            db.session.delete(user)
            db.session.commit()
            
            current_app.logger.warning(f"User {current_user.id} deleted user {user_id} ({user_email})")
            
            return jsonify({
                'success': True,
                'message': f'User {user_email} deleted successfully'
            })
        
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error deleting user: {str(e)}")
            return jsonify({
                'success': False,
                'message': f'Error deleting user: {str(e)}'
            }), 500

    
    return app

if __name__ == '__main__':
    try:
        app = create_app()
        if app is None:
            print("ERROR: create_app() returned None!")
            exit(1)
        with app.app_context():
            db.create_all()
        app.run(debug=True, host='0.0.0.0', port=5000)
    except Exception as e:
        print(f"ERROR creating app: {e}")
        import traceback
        traceback.print_exc()
        exit(1)


